---
title: 找中位数问题
categories: 
- interview
tags:
---



中位数即是排过序后的处于数组最中间的元素。 不考虑数组长度为偶数的情况。设集合元素个数为n。

简单的想了下：
思路1） 把无序数组排好序，取出中间的元素
            时间复杂度 采用普通的比较排序法 O(N*logN)
            如果采用非比较的计数排序等方法， 时间复杂度 O(N), 空间复杂度也是O(N).

思路2）
          2.1）将前(n+1)/2个元素调整为一个小顶堆，
          2.2）对后续的每一个元素，和堆顶比较，如果小于等于堆顶，丢弃之，取下一个元素。 如果大于堆顶，用该元素取代堆顶，调整堆，取下一元素。重复2.2步
          2.3）  当遍历完所有元素之后，堆顶即是中位数。

思路3） 熟话说，想让算法跑的更快，用分治！
            快速排序之所以得名"快排",绝非浪得虚名！因为快排就是一种分治排序法！
            同样，找中位数也可以用快排分治的思想。具体如下：
            任意挑一个元素，以改元素为支点，划分集合为两部分，如果左侧集合长度恰为 (n-1)/2，那么支点恰为中位数。如果左侧长度<(n-1)/2, 那么中位点在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位点。
            这种方法很快，但是在最坏的情况下时间复杂度为O(N^2), 不过平均时间复杂度好像是O(N)。

思路4) 快排的方法存在不确定性,导致其最坏和最好的时候差别很大, 那么有没有一种确定性的方法呢? 答案是有的
            貌似算法导论里有讲到. 这里我就先不深究了, 可以参考如下的文章,
            O(n)时间快速选择
            http://www.shadowxh.com/?p=598
            以及本文的别人的评论

引申一：
查找N个元素中的第K个小的元素（来自编程珠玑）
编程珠玑给出了一个时间复杂度O（N），的解决方案。该方案改编自快速排序。
经过快排的一次划分，
   1）如果左半部份的长度>K-1，那么这个元素就肯定在左半部份了
   2）如果左半部份的长度==K-1，那么当前划分元素就是结果了。
   3）如果。。。。。。。<K-1,那么这个元素就肯定在右半部分了。
  并且，该方法可以用尾递归实现。效率更高。

时间复杂度分析， 由于差不多每次都是把序列划分为一半。。。假设划分的元素做了随机优化，时间复杂度近似于
N+N/2+N/4.... = 2N*(1-2^-(logN)) 当N较大时 约等于 2N 也就是 O（N）。

看来，快速排需的用处可大着咧。。。

也用来查找可以N个元素中的前K个小的元素，前K个大的元素。。。。等等。

引申二：
查找N个元素中的第K个小的元素，假设内存受限，仅能容下K/4个元素。
分趟查找，
第一趟，用堆方法查找最小的K/4个小的元素，同时记录剩下的N-K/4个元素到外部文件。
第二趟，用堆方法从第一趟筛选出的N-K/4个元素中查找K/4个小的元素，同时记录剩下的N-K/2个元素到外部文件。
。。。
第四趟，用堆方法从第一趟筛选出的N-K/3个元素中查找K/4个小的元素，这是的第K/4小的元素即使所求。







题目的意思是如果多个有序数组能在一起排序，则取位置为中间的数字，如果有奇数个数字则中位数只有一个;若为偶数个则有两个，一般取第一个，也称下中位。但不能把数组合在一起做插入或快速排序，因为数据可能是海量的。


该题目可能有很多种实现方法，而我们给出一种仅依赖中位数性质的算法。如果存在一个已经排好序的大数组（有序数列），则会发现几个性质：


	1. 对称性：中位数前面的数字与后面的数字一样多（在偶数元素情况下或相差1）
	2. 确定性：若某个数字前后的数字数量相同（或相差1）则为该数列的中位数
	3. 不变性：删除前N个元素与后N个元素后，中位数不变
	4. 关联性：从大数组中按顺序任意取走n-1组元素，与剩下的元素共构成n个子列，每个子列存在中位数：m1,m1...mn,min，max分别为其中最小者与最大者，则原数列的中位数m满足：min<=m<=max
该性质可通过反证法获得

根据上述性质构造下面基于3分查找的算法：

	1. 输入多个有序数组查找其中位数m
	2. 计算个数组的中位数，并计算其最小者min与最大者max，则m必满足min<=m<=max
	3. 计算min之前所有的数字lTripCount（在所有数组）及max之后所有的数字rTripCount，如果二者相同，则min与max都为中位数，递归结束
	4. 计算所有数组中属于区间[min,max]的中位数（小于min或大于max的全被舍弃）m1,如果m1满足lTripCount==rTripCount，则为中位数，递归结束
	5. 如果lTripCount<rTripCount，则中位数m一定属于区间[min,m1]
	6. 如果lTripCount>rTripCount，则中位数m一定属于区间(m1,max]
	7. 递归上述过程
	8. 若某个递归后发现各数组剩余的数据小于某个阀值，则考虑一起计算，从而终止递归

该算法的主要思想是利用子数组的中位数逼近全数组的中位数，具体过程如下： 
要排序的全数组：

其中10便是要求解的中位数，数组A被划分为下面三个子数组：

计算步骤：

	1. 分别计算A1,A2，A3的中位数,分别为7,9,11
	2. 根据关联性，则要寻找的中位数（10）必定满足7<=m<=11
	3. 从A1,A2，A3中去除小于7,大于11的数，此时各子数组的数据情况如下：


	4. 继续计算各子数组的中位数，可的A1：10,A2：9,A3：11,因为此时各数组只剩一个元素，故根据假设可在一起计算其中位数10
	5. 以10为中心计算lTripCount、rTripCount，经过计算二者相同，根据确定性可断定10为最终的中位数;如果lTreipCount与rTripCount不同，则可推导中位数会落在哪个区间（参考上面的算法描述），从而递归上面的过程

因为每次都根据最小中位数与最大中位数过滤，故每次计算可大约砍掉2/3的数据，算法大约以3n的速度收敛。
上述算法可能会产生一个无法收敛的特殊场景：如果某个计算过程出现最小中位数为当前有效数据的最小值，而最大中位数为最大值，则无法过滤掉更多的数据，解决该问题的办法是根据不变性，同时删除最小中位数与最大中位数。





100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？


链接：https://www.nowcoder.com/questionTerminal/359d6869d5ce4738bf9c9a42b67d9568
来源：牛客网

假设整数是32位的，根据每个整数二进制前的5位，可以划分为32个不同的桶，如果某个桶的个数在内存中放不下，则继续划分，知道内存可以放下为止；然后统计每个桶中的数的个数，就可以中位数一定出现在哪个桶中，而且知道是该桶中第几大数，因为桶的划分是根据二进制前缀来进行划分的，桶之间是排好序的。


链接：https://www.nowcoder.com/questionTerminal/359d6869d5ce4738bf9c9a42b67d9568
来源：牛客网

内存足够的情况： 可以使用类似quick sort的思想进行，均摊复杂度为O(n)，算法思想如下：
• 随机选取一个元素，将比它小的元素放在它左边，比它大的元素放在右边
• 如果它恰好在中位数的位置，那么它就是中位数，可以直接返回
• 如果小于它的数超过一半，那么中位数一定在左半边，递归到左边处理
• 否则，中位数一定在右半边，根据左半边的元素个数计算出中位数是右半边的第几大，然后递归到右半边处理
内存不足的情况：
方法：分法
思路：一个重要的线索是，这些数都是整数。整数就有范围了，32位系统中就是[-2^32, 2^32- 1]， 有了范围我们就可以对这个范围进行二分，然后找有多少个数⼩于Mid,多少数大于mid，然后递归，和基于quicksort思想的第k大方法类似
方法二：分桶法 思路：化大为小，把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则 继续划分




链接：https://www.nowcoder.com/questionTerminal/359d6869d5ce4738bf9c9a42b67d9568
来源：牛客网

中位数定义：数字排序之后，位于中间的那个数。比如将100亿个数字进行排序，排序之后，位于第50亿个位置的那个数 就是中位数。

①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以...然后找到中间那个就可以了。但是你以为面试官会给你内存？？

②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。
假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。
从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中）
现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。
现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。
抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。

按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。

题目和基本思路都来源网上，本人加以整理。
题目：在一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可（内存限制为 2G的意思就是，可以使用2G的空间来运行程序，而不考虑这台机器上的其他软件的占用内存）。
关于中位数：数据排序后，位置在最中间的数值。即将数据分成两部分，一部分大于该数值，一部分小于该数值。中位数的位置：当样本数为奇数时，中位数=(N+1)/2 ; 当样本数为偶数时，中位数为N/2与1+N/2的均值（那么10G个数的中位数，就第5G大的数与第5G+1大的数的均值了）。
分析：明显是一道工程性很强的题目，和一般的查找中位数的题目有几点不同。
1. 原数据不能读进内存，不然可以用快速选择，如果数的范围合适的话还可以考虑桶排序或者计数排序，但这里假设是32位整数，仍有4G种取值，需要一个16G大小的数组来计数。
2. 若看成从N个数中找出第K大的数，如果K个数可以读进内存，可以利用最小或最大堆，但这里K=N/2,有5G个数，仍然不能读进内存。
3. 接上，对于N个数和K个数都不能一次读进内存的情况，《编程之美》里给出一个方案：设k<K,且k个数可以完全读进内存，那么先构建k个数的堆，先找出第0到k大的数，再扫描一遍数组找出第k+1到2k的数，再扫描直到找出第K个数。虽然每次时间大约是nlog(k)，但需要扫描ceil(K/k)次，这里要扫描5次。
解法：首先假设是32位无符号整数。
1. 读一遍10G个整数，把整数映射到256M个区段中，用一个64位无符号整数给每个相应区段记数。
说明：整数范围是0 - 2^32 - 1，一共有4G种取值，映射到256M个区段，则每个区段有16（4G/256M = 16）种值，每16个值算一段， 0～15是第1段，16～31是第2段，……2^32-16 ～2^32-1是第256M段。一个64位无符号整数最大值是0～8G-1，这里先不考虑溢出的情况。总共占用内存256M×8B=2GB。
2. 从前到后对每一段的计数累加，当累加的和超过5G时停止，找出这个区段（即累加停止时达到的区段，也是中位数所在的区段）的数值范围，设为[a，a+15]，同时记录累加到前一个区段的总数，设为m。然后，释放除这个区段占用的内存。
3. 再读一遍10G个整数，把在[a，a+15]内的每个值计数，即有16个计数。
4. 对新的计数依次累加，每次的和设为n，当m+n的值超过5G时停止，此时的这个计数所对应的数就是中位数。
总结：
1.以上方法只要读两遍整数，对每个整数也只是常数时间的操作，总体来说是线性时间。
2. 考虑其他情况。
若是有符号的整数，只需改变映射即可。若是64为整数，则增加每个区段的范围，那么在第二次读数时，要考虑更多的计数。若过某个计数溢出，那么可认定所在的区段或代表整数为所求，这里只需做好相应的处理。噢，忘了还要找第5G+1大的数了，相信有了以上的成果，找到这个数也不难了吧。
3. 时空权衡。
花费256个区段也许只是恰好配合2GB的内存（其实也不是，呵呵）。可以增大区段范围，减少区段数目，节省一些内存，虽然增加第二部分的对单个数值的计数，但第一部分对每个区段的计数加快了（总体改变？？待测）。

4. 映射时尽量用位操作，由于每个区段的起点都是2的整数幂，映射起来也很方便。


