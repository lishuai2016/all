数组问题总结
首先一般考虑“万能的”暴力穷举（递归、回溯），如求n个数的全排列或八皇后（N皇后问题）。但因为穷举时间复杂度通常过高，所以需要考虑更好的方法，如分治法（通过分而治之，然后归并），以及空间换时间（如活用哈希表）。

此外，选择合适的数据结构可以显著提升效率，如寻找最小的k个数中，用堆代替数组。

再有，如果题目允许排序，则可以考虑排序。比如，寻找和为定值的两个数中，先排序，然后用前后两个指针往中间扫。而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分。但是，如果题目不允许排序呢？这个时候，我们可以考虑不改变数列顺序的贪心算法（如最小生成树Prim、Kruskal及最短路dijkstra），或动态规划（如 01背包问题，每一步都在决策）。


最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。

寻找最小的k个数

题目描述

输入n个整数，输出其中最小的k个。

分析与解法

解法一（直接排序）

要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为n*logn），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。


解法三（堆排序）

更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：

- 1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
- 2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
- 3、遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果x < kmax，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。

这样下来，总的时间复杂度:O（k+（n-k）*logk）=O（n*logk）。此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)（若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。

解法四（类快速排序算法）

在《数据结构与算法分析--c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为O（N）的快速选择算法。如下述文字：

- 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
    - 如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
    - 如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
    - 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。

此算法的平均运行时间为O(n)。



举一反三

1、谷歌面试题：输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？

分析：

“假设两个整数数组为A和B，各有N个元素，任意两个数的和组成的数组C有N^2个元素。
  那么可以把这些和看成N个有序数列：
          A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <=…
          A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <=…
          …
        A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <=…
    问题转变成，在这N^2个有序数列里，找到前k小的元素”


2、有两个序列A和B,A=(a1,a2,...,ak),B=(b1,b2,...,bk)，A和B都按升序排列。对于1<=i,j<=k，求k个最小的（ai+bj）。要求算法尽量高效。

3、给定一个数列a1,a2,a3,...,an和m个三元组表示的查询，对于每个查询(i，j，k)，输出ai，ai+1，...，aj的升序排列中第k个数。




寻找和为定值的两个数

题目描述

输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。

要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。

例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。

分析与解法

咱们试着一步一步解决这个问题（注意阐述中数列有序无序的区别）：

直接穷举，从数组中任意选取两个数，判定它们的和是否为输入的那个数字。此举复杂度为O(N^2)。很显然，我们要寻找效率更高的解法

题目相当于，对每个a[i]，查找sum-a[i]是否也在原始序列中，每一次要查找的时间都要花费为O(N)，这样下来，最终找到两个数还是需要O（N^2）的复杂度。那如何提高查找判断的速度呢？

答案是二分查找，可以将O(N)的查找时间提高到O(log N)，这样对于N个a[i]，都要花logN的时间去查找相对应的sum-a[i]是否在原始序列中，总的时间复杂度已降为O(N log N)，且空间复杂度为O(1)。 （如果有序，直接二分O(N log N)，如果无序，先排序后二分，复杂度同样为O（N log N + N log N）= O(N log N)，空间复杂度总为O(1)）。

可以继续优化做到时间O(N)么？

解法一

根据前面的分析，a[i]在序列中，如果a[i]+a[k]=sum的话，那么sum-a[i]（a[k])也必然在序列中。 举个例子，如下： 原始序列：

- 1、 2、 4、 7、11、15

用输入数字15减一下各个数，得到对应的序列为：

- 14、13、11、8、4、 0

第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果第一个数组出现了和第二个数组一样的数，即a[i]=a[j]，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组。

解法二

当题目对时间复杂度要求比较严格时，我们可以考虑下用空间换时间，上述解法一即是此思想，此外，构造hash表也是典型的用空间换时间的处理办法。

即给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，前提是经过O(N)时间的预处理，和用O(N)的空间构造hash表。

但能否做到在时间复杂度为O(N)的情况下，空间复杂度能进一步降低达到O(1)呢？

解法三

如果数组是无序的，先排序(N log N)，然后用两个指针i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后i++，j--，逐次判断a[i]+a[j]?=sum，

- 如果某一刻a[i]+a[j] > sum，则要想办法让sum的值减小，所以此刻i不动，j--；
- 如果某一刻a[i]+a[j] < sum，则要想办法让sum的值增大，所以此刻i++，j不动。

所以，数组无序的时候，时间复杂度最终为O(N log N + N)=O(N log N)。

如果原数组是有序的，则不需要事先的排序，直接用两指针分别从头和尾向中间扫描，O(N)搞定，且空间复杂度还是O(1)。

下面，咱们先来实现此思路（这里假定数组已经是有序的），代码可以如下编写：

void TwoSum(int data[], unsigned int length, int sum){
    //sort(s, s+n);  如果数组非有序的，那就事先排好序O(N log N)

    int begin = 0;
    int end = length - 1;

    //俩头夹逼，或称两个指针两端扫描法，很经典的方法，O(N)
    while (begin < end)
    {
        long currSum = data[begin] + data[end];

        if (currSum == sum)
        {
            //题目只要求输出满足条件的任意一对即可
            printf("%d %d\n", data[begin], data[end]);

            //如果需要所有满足条件的数组对，则需要加上下面两条语句：
            //begin++
            //end--
            break;
        }
        else{
            if (currSum < sum)
                begin++;
            else
                end--;
        }
    }
}


解法总结

不论原序列是有序还是无序，解决这类题有以下三种办法：

- 1、二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；
- 2、扫描一遍X-S[i] 映射到一个数组或构造hash表，时间复杂度为O(N)，空间复杂度为O(N)；
- 3、两个指针两端扫描（若无序，先排序后扫描），时间复杂度最后为：有序O(N)，无序O(N log N + N)=O(N log N)，空间复杂度都为O(1)。

所以，要想达到时间O(N)，空间O(1)的目标，除非原数组是有序的（指针扫描法），不然，当数组无序的话，就只能先排序，后指针扫描法或二分（时间 O(Nlog N)，空间O(1)），或映射或hash（时间O(N)，空间O(N)）。时间或空间，必须牺牲一个，达到平衡。

综上，若是数组有序的情况下，优先考虑两个指针两端扫描法，以达到最佳的时O(N)，空O(1)效应。否则，如果要排序的话，时间复杂度最快当然是只能达到O(N log N)，空间O(1)则不在话下。

问题扩展

- 如果在返回找到的两个数的同时，还要求你返回这两个数的位置列？
- 如果需要输出所有满足条件的整数对呢?
- 如果把题目中的要你寻找的两个数改为“多个数”，或任意个数列?

举一反三

1、在二元树中找出和为某一值的所有路径 输入一个整数和一棵二元树，从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径，然后打印出和与输入整数相等的所有路径。 例如输入整数22和如下二元树

10


/ \
5 12
/ \
4 7

则打印出两条路径：10, 12和10, 5, 7。 其中，二元树节点的数据结构定义为：

struct BinaryTreeNode // a node in the binary tree
{
    int m_nValue; // value of node
    BinaryTreeNode *m_pLeft; // left child of node
    BinaryTreeNode *m_pRight; // right child of node
};


2、有一个数组a，设有一个值n。在数组中找到两个元素a[i]和a[j]，使得a[i]+a[j]等于n，求出所有满足以上条件的i和j。

+

3、3-sum问题

给定一个整数数组，判断能否从中找出3个数a、b、c，使得他们的和为0，如果能，请找出所有满足和为0个3个数对。

4、4-sum问题

给定一个整数数组，判断能否从中找出4个数a、b、c、d，使得他们的和为0，如果能，请找出所有满足和为0个4个数对。






```
数组



找数组中的最大和最小值
1、直接遍历一次，求出最大和最小。需要比较2N次
2、把数组逻辑分组，每相邻的两个一组比较（同时维护两个全局变量，意义是到当前的最大和最小）。比较次数为1.5N
3、分治思想，把分别求出前N/2和后N/2比较他们的最大和最小。一直递归下去

循环移位的问题转化为翻转问题

public class ShiftRight {

    /**
     * @param args
     */
    public static void main(String[] args) {
        int[] a = {3,4,5,1,2};
        reverse(a,0,4);

System.out.println();
    }
    // abcd1234
    //1 dcba1234
    //2 dcba4321
    //3 1234abcd
    public static void shriftRightK(int[] a,int k) {
        if (a == null || a.length == 0 || k <= 0 || k % a.length == 0) {
            return;
        }
        int n = a.length;
        k = k % n;
        reverse(a,0,n - 1 - k);
        reverse(a,n - k,n - 1);
        reverse(a,0,n - 1);
    }
    public static void reverse(int[] a,int start,int end) {
        if (a == null ||  start >= end) {
            return ;
        }
        int temp;
        while(start < end){
            temp = a[end];
            a[end] = a[start];
            a[start] = temp;
            start++;
            end--;
        }
    }
    public static void shriftRight(int[] a,int k) {
        if (a == null || a.length == 0 || k <= 0 || k % a.length == 0) {
            return;
        }
        int temp;
        k = k % a.length;
        while (k-- > 0) {
            temp = a[a.length - 1];
            for (int i = a.length - 1;i > 0;i--) {
                a[i] = a[i-1];
            }
            a[0] = temp;
        }
    }
}

一维数组中连个元素差值最小的两个元素
1、直接遍历所有N*N
2、先排序，然后遍历一次即可N*logN+N

在坐标平面找距离最近的两个点（？？？）


长度为N的数组求其中N-1个元素的乘积最大
1、借助于两个数组s[i],t[i]，分别前0到i-1的元素乘积;i+1到最后的成绩，p[i] = s[i]*t[i]表示出去i出元素的成绩，时间复杂度N
2、算出N个数的乘积P的正负（直接相乘可能溢出），可以通过统计正负0元素的个数来判断
p大于0，要是数组中有正值取出最小的，否则都为负数的话取出绝对值最大的
p小于0，去掉负数绝对值最小的即可
p为0，取出数组中的一个0，剩下元素的正负为Q
若Q为0，返回0；
若Q大于0，返回Q；
若小于0，返回0；

1、给定一副由N*N矩阵表示的图像，其中每个像素的大小为4字节，编写一个方法，将图像旋转90度。不占用额外的存储空间能否做到。
123
456
789

741
852
963

思路：1、按照规律如下
2、从外层一层层的旋转（麻烦一点）


/*
     * clockwise rotate
     * first reverse up to down, then swap the symmetry
     * 1 2 3     7 8 9     7 4 1
     * 4 5 6  => 4 5 6  => 8 5 2
     * 7 8 9     1 2 3     9 6 3
    */

  /*
     * anticlockwise rotate
     * first reverse left to right, then swap the symmetry
     * 1 2 3     3 2 1     3 6 9
     * 4 5 6  => 6 5 4  => 2 5 8
     * 7 8 9     9 8 7     1 4 7
    */
顺时针代码
public static void rotate(int[][] matrix) {
        for(int i = 0; i < matrix.length / 2; i++){
            int[] temp = matrix[i];
            matrix[i] = matrix[matrix.length - i - 1];
            matrix[matrix.length - i - 1] = temp;
        }

        for(int i = 0; i < matrix.length; i++){
            for(int j = i+1; j < matrix[i].length; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }

2、编写一个算法、若M*N矩阵中某个元素为0，则将其所在的行和列清零。
有个陷阱不能直接遍历把对应的行和列清零，否则整个都变成了零

思路：
1、借助一个和原矩阵一样大小的空间，记录哪个位置的元素为零，然后遍历这个矩阵，把对应的行和列清零，M*N
2、优化，其实只要记录要清零元素的行和列号就行
使用两个数组分别记录邀请了的行号和列号就行了M+N

public static void setzero(int [][] a) {
        if (a == null || a.length == 0) {
            return ;
        }
        boolean[] row = new boolean[a.length];
        boolean[] column = new boolean[a[0].length];
        //记录值位0元素所在的行和列的索引
        for (int i = 0; i< a.length;i++) {
            for (int j = 0;j< a[0].length;j++) {
                if (a[i][j] == 0) {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        //若i行或者j列有个元素为0，那么将a[i][j]=0;
        for (int i = 0; i< a.length;i++) {
            for (int j = 0;j< a[0].length;j++) {
                if (row[i]||column[j]) {
                    a[i][j] = 0;
                }
                }
        }

    }


73. Set Matrix Zeroes把矩阵中有0的行和列设置为0
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-6 上午11:01:26
 */

public class SetMatrixZeroes {

     /**
      * @author lishuai
      * @data 2016-12-6 上午11:01:26
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

Follow up:
Did you use extra space?
A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?

1 4 2
3 0 5
6 7 8
      */

     public static void main(String[] args) {
          int[][] a = {{1,4,2},{3,0,5},{6,7,8}};
     }

     //0
    public static void setZeroes0(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
          return;
        }
        int rows = matrix.length;
        int colums = matrix[0].length;
     boolean row0 = false;
     boolean colum0 = false;
     for (int i = 0; i < rows; i++) {
          if (matrix[i][0] == 0) {
              colum0 = true;
              break;
          }
     }
     for (int i = 0; i < colums; i++) {
          if (matrix[0][i] == 0) {
              row0 = true;
              break;
          }
     }
     for (int i = 1; i < rows; i++) {
          for (int j = 1; j < colums; j++) {
              if (matrix[i][j] == 0) {
                   matrix[0][j] = 0;
                   matrix[i][0] = 0;
              }
          }
     }
     for (int i = 1; i < rows; i++) {
          for (int j = 1; j < colums; j++) {
              if (matrix[0][j] == 0 || matrix[i][0] == 0) {
                   matrix[i][j] = 0;
              }
          }
     }
     if (row0) {
          for (int i = 0; i < colums; i++) {
              matrix[0][i] = 0;
          }
     }
     if (colum0) {
          for (int i = 0; i < rows; i++) {
              matrix[i][0] = 0;
          }
     }


    }

    //1 九章
    // using O(m+n) is easy, to enable O(1), we have to use the space within the matrix
    //思想：第一步，首先把第一行和第一列遍历看看是否有0，设置两个标志位；
    //第二步，然后从第二行第二列开始遍历，要是遇到一个0，把它对应的第一行和第一列元素设置为0，作为标志
    //第三步，再次从第二行第二列开始遍历，判断要是其对应的第一行或者第一列元素设置为0，就把该元素设置为0
    //第四步，根据第一步的标志判断是否需要对第一步进行处理
   public void setZeroes1(int[][] matrix) {
       if(matrix == null || matrix.length == 0)
           return;

       int rows = matrix.length;
       int cols = matrix[0].length;

       boolean empty_row0 = false;
       boolean empty_col0 = false;
       for(int i = 0; i < cols; i++){
           if(matrix[0][i] == 0){
               empty_row0 = true;
               break;
           }
       }

       for(int i = 0; i < rows; i++){
           if(matrix[i][0] == 0){
               empty_col0 = true;
               break;
           }
       }

       for(int i = 1; i < rows; i++) {
           for(int j =1; j<cols; j++){
               if(matrix[i][j] == 0){
                   matrix[0][j] = 0;
                   matrix[i][0] = 0;
               }
           }
       }

       for(int i = 1; i<rows; i++) {
           for (int j=1; j< cols; j++) {
               if(matrix[0][j] == 0 || matrix[i][0] == 0)
                   matrix[i][j] = 0;
           }
       }

       if(empty_row0){
           for(int i = 0; i < cols; i++){
               matrix[0][i] = 0;
           }
       }

       if(empty_col0){
           for(int i = 0; i < rows; i++){
               matrix[i][0] = 0;
           }
       }

   }
   /**
  My idea is simple: store states of each row in the first of that row,
  and store states of each column in the first of that column.
  Because the state of row0 and the state of column0 would occupy the same cell,
  I let it be the state of row0, and use another variable "col0" for column0.
  In the first phase, use matrix elements to set states in a top-down way.
  In the second phase, use states to set matrix elements in a bottom-up way.
1 4 2
3 0 5
6 7 8
    */
   //2 和1的思路类似简化代码(有点不太好理解)
   //单独处理第一列
   public void setZeroes(int[][] matrix) {
        int col0 = 1, rows = matrix.length, cols = matrix[0].length;

         for (int i = 0; i < rows; i++) {
             if (matrix[i][0] == 0) col0 = 0;
             for (int j = 1; j < cols; j++)
                 if (matrix[i][j] == 0)
                     matrix[i][0] = matrix[0][j] = 0;
         }

         for (int i = rows - 1; i >= 0; i--) {
             for (int j = cols - 1; j >= 1; j--)
                 if (matrix[i][0] == 0 || matrix[0][j] == 0)
                     matrix[i][j] = 0;
             if (col0 == 0) matrix[i][0] = 0;
         }
   }
}

3、在一个数组中找两个元素的和等于目标元素
思路：
1、直接查找a[i]+a[j] = sum 时间复杂度N*N
2、先排序在二分查找sum-a[i]是否存在。时间复杂度N*logN
3、借助于map空间复杂度N
4、首先排序，然后一个在前一个在后，查找即可。时间复杂度N*logN

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].


法1：比较容易想到，效率不高（算法复杂度N*logN???）
public class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        for (int i = 0;i < nums.length;i++) {
            for (int j = i+1;j < nums.length;j++) {
                if (nums[i] + nums[j] == target) {
                    res[0] = i;
                    res[1] = j;
                }
            }
        }
        return res;
    }
}
法2：使用hashmap实现（时间复杂度N，空间复杂度N）
public class Solution {
    public int[] twoSum(int[] nums, int target) {
       int[] res = new int[2];
       Map<Integer,Integer> map = new HashMap<Integer,Integer>();
       for (int i = 0;i < nums.length;i++) {
           if(map.containsKey(target - nums[i])) {
               res[1] = i;
               res[0] = map.get(target-nums[i]);
               return res;
           }
           map.put(nums[i],i);
       }
       return res;
    }
}






4、在一个数组中找三个元素的和等于目标元素

Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a = {-1, 0, 1, 2, -1, -4};

        System.out.println(threeSum(a));
    }
    //1 回溯法  Time Limit Exceeded
    public  List<List<Integer>> threeSum1(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        backtrack(res, new ArrayList<Integer>(),nums, 0, 3, 0);
        return res;
    }
    public  void backtrack(List<List<Integer>> res,List<Integer> list,int[] nums,int target,int k,int start) {
        if (target == 0 && k == 0) {
            List<Integer> t = new ArrayList<Integer>(list);
            if (!res.contains(t)) res.add(t);
        }
        for (int i = start;i < nums.length;i++) {
            list.add(nums[i]);
            backtrack(res, list, nums, target-nums[i], k-1, i+1);
            list.remove(list.size()-1);
        }
    }
    /**
The idea is to sort an input array and then run through all indices of a possible first element of a triplet.
For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array.
 Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that.
     */
-1, 0, 1, 2, -1, -4       -4 -1 -1 0 1 2
    //2      时间复杂度N*N
    public static List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < nums.length-2; i++) {
            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {
                int lo = i+1, hi = nums.length-1, sum = 0 - nums[i];
                while (lo < hi) {
                    if (nums[lo] + nums[hi] == sum) {
                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                        //两个while的作用跳过重复的元素
                        while (lo < hi && nums[lo] == nums[lo+1]) lo++;
                        while (lo < hi && nums[hi] == nums[hi-1]) hi--;
                        lo++; hi--;
                    } else if (nums[lo] + nums[hi] < sum) {
                        lo++;
                    } else {
                        hi--;
                    }
               }
            }
        }
        return res;
    }

}


5、四个元素的和等于目标值
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target?
Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.

For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a = {1, 0, -1, 0, -2, 2};

        System.out.println(fourSum3(a,0));
    }

    //1 回溯法  Time Limit Exceeded
    public static  List<List<Integer>> fourSum1(int[] nums, int target) {
        Arrays.sort(nums);
          List<List<Integer>> res = new ArrayList<List<Integer>>();
          backtrack(res, new ArrayList<Integer>(),nums, target, 4, 0);
          return res;
    }
    public static void backtrack(List<List<Integer>> res,List<Integer> list,int[] nums,int target,int k,int start) {
        if (target == 0 && k == 0) {
            List<Integer> t = new ArrayList<Integer>(list);
            if (!res.contains(t)) res.add(t);
        }
        for (int i = start;i < nums.length;i++) {
            list.add(nums[i]);
            backtrack(res, list, nums, target-nums[i], k-1, i+1);
            list.remove(list.size()-1);
        }
    }

/**
The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum,
and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.
 */
    //2
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
        int len = nums.length;
        if (nums == null || len < 4)
            return res;

        Arrays.sort(nums);

        int max = nums[len - 1];
        if (4 * nums[0] > target || 4 * max < target)
            return res;

        int i, z;
        for (i = 0; i < len; i++) {
            z = nums[i];
            if (i > 0 && z == nums[i - 1])// avoid duplicate
                continue;
            if (z + 3 * max < target) // z is too small
                continue;
            if (4 * z > target) // z is too large
                break;
            if (4 * z == target) { // z is the boundary
                if (i + 3 < len && nums[i + 3] == z)
                    res.add(Arrays.asList(z, z, z, z));
                break;
            }

            threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);
        }

        return res;
    }

    /*
     * Find all possible distinguished three numbers adding up to the target
     * in sorted array nums[] between indices low and high. If there are,
     * add all of them into the ArrayList fourSumList, using
     * fourSumList.add(Arrays.asList(z1, the three numbers))
     */
    public static void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
            int z1) {
        if (low + 1 >= high)
            return;

        int max = nums[high];
        if (3 * nums[low] > target || 3 * max < target)
            return;

        int i, z;
        for (i = low; i < high - 1; i++) {
            z = nums[i];
            if (i > low && z == nums[i - 1]) // avoid duplicate
                continue;
            if (z + 2 * max < target) // z is too small
                continue;

            if (3 * z > target) // z is too large
                break;

            if (3 * z == target) { // z is the boundary
                if (i + 1 < high && nums[i + 2] == z)
                    fourSumList.add(Arrays.asList(z1, z, z, z));
                break;
            }

            twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);
        }

    }

    /*
     * Find all possible distinguished two numbers adding up to the target
     * in sorted array nums[] between indices low and high. If there are,
     * add all of them into the ArrayList fourSumList, using
     * fourSumList.add(Arrays.asList(z1, z2, the two numbers))
     */
    public static void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
            int z1, int z2) {

        if (low >= high)
            return;

        if (2 * nums[low] > target || 2 * nums[high] < target)
            return;

        int i = low, j = high, sum, x;
        while (i < j) {
            sum = nums[i] + nums[j];
            if (sum == target) {
                fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));

                x = nums[i];
                while (++i < j && x == nums[i]) // avoid duplicate
                    ;
                x = nums[j];
                while (i < --j && x == nums[j]) // avoid duplicate
                    ;
            }
            if (sum < target)
                i++;
            if (sum > target)
                j--;
        }
        return;
    }
    //3 原理和2类似
    public static List<List<Integer>> fourSum3(int[] num, int target) {
        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(num);

        for (int i = 0; i < num.length - 3; i++) {
            if (i != 0 && num[i] == num[i - 1]) {
                continue;
            }

            for (int j = i + 1; j < num.length - 2; j++) {
                if (j != i + 1 && num[j] == num[j - 1])
                    continue;

                int left = j + 1;
                int right = num.length - 1;
                while (left < right) {
                    int sum = num[i] + num[j] + num[left] + num[right];
                    if (sum < target) {
                        left++;
                    } else if (sum > target) {
                        right--;
                    } else {
                        List<Integer> tmp = new ArrayList<Integer>();
                        tmp.add(num[i]);
                        tmp.add(num[j]);
                        tmp.add(num[left]);
                        tmp.add(num[right]);
                        rst.add(tmp);
                        left++;
                        right--;
                        while (left < right && num[left] == num[left - 1]) {
                            left++;
                        }
                        while (left < right && num[right] == num[right + 1]) {
                            right--;
                        }
                    }
                }
            }
        }

        return rst;
    }

}


6 、3Sum Closest
    /**
Given an array S of n integers,
find three integers in S such that the sum is closest to a given number, target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

     */
    public static void main(String[] args) {
        int[] a = {-1 ,2 ,1 ,-4};
        System.out.println(threeSumClosest(a,1));
    }
//1 思路，首先排序，然后通过一个for循环把数量降1，
//  然后再在一个while循环中用两个指针，一前一后锁定可能的值，
//  并用一个全局变量保存最接近目标的值，并不断更新，直至遍历所有
//时间复杂度N*N
    public static int threeSumClosest(int[] nums, int target) {
        int sum = 0;
        Arrays.sort(nums);
        if (nums == null) return 0;
        if (nums.length <= 3) {
            for (int i = 0;i < nums.length;i++) {
                sum += nums[i];
            }
            return sum;
        }
        sum = nums[0] + nums[1] + nums[2];
        for (int i = 0;i < nums.length - 2;i++) {
            int start = i + 1;
            int end = nums.length - 1;
            while (start < end) {
                int temp = nums[i] + nums[start] + nums[end];
                if (temp == target) return temp;
                if (Math.abs(target - temp) < Math.abs(target - sum)) sum = temp;
                if (temp > target) end--;
                else start++;
            }
        }
        return sum;
    }


}



Remove Duplicates from Sorted Array


Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the new length.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a = {1,1,2,3,4,5,6,6,6,7};
        System.out.println(removeDuplicates2(a));
    }
   
思路：把后面的元素前移即可。
    //2 和1的思路一样，但是减少一个变量，优化代码。时间复杂度N
    public static int removeDuplicates2(int[] nums) {
        if (nums == null || nums.length == 0) return 0;       
        int k = 1;
        for (int i = 1;i < nums.length;i++) {
           if (nums[i - 1] != nums[i]) {
               nums[k++] = nums[i];
           }
        }
        return k;
    }



}


27. Remove Element
答案：要是不考虑数组元素之间的相对位置，解法2最优；考虑相对位置不改变，法1最优
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-2 下午3:56:53
 */

public class RemoveElement {

    /**
     * @author lishuai
     * @data 2016-12-2 下午3:56:53
Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example:
Given input array nums = [3,2,2,3], val = 3

Your function should return length = 2, with the first two elements of nums being 2.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a = {1,3,2,2,3,4,4};
        System.out.println(removeElement(a,3));
    }
    //1 思路：遍历数组跳过指定元素 （保持元素之间的相对位置）时间复杂度为N
    public static int removeElement1(int[] nums, int val) {   
       int k=0;
       for (int i = 0;i < nums.length; i++) {
           if (nums[i] != val) {
               nums[k++] = nums[i];
           }
       }       
       return k;
   }
    //2 思路：当遍历的当前元素等于指定元素时，把数组最后的元素替换当前元素，并把指针前移（可能会提高点效率，减少元素的移动，但是会打乱原来数组元素的相对位置）
    public static int removeElement(int[] A, int elem) {
        int i = 0;
        int pointer = A.length - 1;
        while(i <= pointer){
            if(A[i] == elem){
                A[i] = A[pointer];
                pointer--;
            } else {
                i++;
            }
        }
        return pointer + 1;
    }

}



给定一个旋转排序数组，在原地恢复其排序。

您在真实的面试中是否遇到过这个题？

Yes

说明
什么是旋转数组？
- 比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]

样例

[4, 5, 1, 2, 3] -> [1, 2, 3, 4, 5]




public void recoverRotatedSortedArray(List<Integer> nums) {
        // write your code here
        if (nums == null || nums.size() == 0) {
            return;
        }
        int pos = getpos(nums);
        if (pos == 0) {
            return;
        }//循环移位
        while (pos > 0) {
            int val = nums.get(0);
            for (int i = 1;i < nums.size();i++) {
                nums.set(i-1,nums.get(i));
            }
            nums.set(nums.size() -1,val);
            pos--;
        }
    }
获取旋转数组的位置
   public  int getpos(List<Integer> nums) {
        if (nums == null || nums.size() == 0) {
            return -1;
        }
        int left = 0;
        int right = nums.size() - 1;
        int mid = left;
        while (nums.get(left) >= nums.get(right)) {
            if (left + 1 == right) {
                mid = right;
                break;
            }
            mid = left + (right - left) / 2;
            //找最小元素的下标
            if (nums.get(left) == nums.get(mid) && nums.get(right) == nums.get(mid)) {
                int result = nums.get(mid);
                int index = mid;
                for (int i = left+1;i <= right;i++) {
                    if (nums.get(i) < result) {
                        result = nums.get(i);
                        index = i;
                    } 
                }
                return index;
            }
            if (nums.get(mid) >= nums.get(left)) {
                left = mid;
            } else if(nums.get(mid) <= nums.get(right)){
                right = mid;
            }
        } 
        return mid;
    }

33. Search in Rotated Sorted Array
在旋转数组中查找
思路：找到旋转位置（就是原来数组的第一个元素的下标）、然后按照二分查找即可，需要注意此时的中点位置的处理
优解：二分查找
package array;

public class SearchinRotatedSortedArray {

    /**
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search.
If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a = {4, 5 ,6 ,7 ,0 ,1, 2};
        System.out.println(search3(a,0));

    }
    //4 九章算法答案（查找范围的确定，不太好想到，确定一种可能的情况，别的都是另外的）
    public int search(int[] A, int target) {
        if (A == null || A.length == 0) {
            return -1;
        }

        int start = 0;
        int end = A.length - 1;
        int mid;

        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid;
            }
            if (A[start] < A[mid]) {
                // situation 1, red line
                if (A[start] <= target && target <= A[mid]) {
                    end = mid;
                } else {
                    start = mid;
                }
            } else {
                // situation 2, green line
                if (A[mid] <= target && target <= A[end]) {
                    start = mid;
                } else {
                    end = mid;
                }
            }
        } // while

        if (A[start] == target) {
            return start;
        }
        if (A[end] == target) {
            return end;
        }
        return -1;
    }

    //3 二分法查找   找旋转点的下标  然后根据旋转点和数组的长度，
    //获取旋转前数组中间值，然后和目标值比较，二分查找
    public static int search3(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] > nums[high]) low = mid + 1;
            else high = mid;
        }
        int rot = low;
        low = 0;
        high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int realmid = (rot + mid) % nums.length;
            if (nums[realmid] == target) return realmid;
            else if (nums[realmid] > target) high = mid - 1;
            else low = mid + 1;
        }
        return -1;
    }


思路：根据中间节点落在前半段还是后半段划分，每次判断目标值在递增端的情况

    public int search(int[] A, int target) {
        // write your code here
        if (A == null) {
            return -1;
        } 
        int left = 0;
        int right = A.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) {
                return mid;
            }
            if (A[left] == target) {
                return left;
            }
            if (A[right] == target) {
                return right;
            }
            if (A[left] < A[mid]) {
                if (A[left] < target && target < A[mid]) {
                    right = mid -1;
                } else {
                    left = mid + 1; 
                }
            } else {
                if (A[mid] < target && target < A[right] ) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
81. Search in Rotated Sorted Array I
Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Write a function to determine if a given target is in the array.

The array may contain duplicates.

Since we will have some duplicate elements in this problem, it is a little tricky because sometimes we cannot decide whether to go to the left side or right side. So for this condition, I have to probe both left and right side simultaneously to decide which side we need to find the number. Only in this condition, the time complexity may be O(n). The rest conditions are always O(log n).

For example:

input: 113111111111, Looking for target 3.

Is my solution correct? My code is as followed:


public boolean search(int[] A, int target) {
        
        int i = 0;
        int j = A.length - 1;
        while(i <= j){
            int mid = (i + j) / 2;
            if(A[mid] == target)
                return true;
            else if(A[mid] < A[i]){
                if(target > A[j])
                    j = mid - 1;
                else if(target < A[mid])
                    j = mid - 1;
                else
                    i = mid + 1;
            }else if(A[mid] > A[i]){
                if(target < A[mid] && target >= A[i])
                    j = mid - 1;
                else
                    i = mid + 1;
            }else{ // A[mid] == A[i]
                if(A[mid] != A[j])
                    i = mid + 1;
                else{
                    boolean flag = true;
                    for(int k = 1; mid - k >= i && mid + k <= j; k++){
                        if(A[mid] != A[mid - k]){
                            j = mid - k;
                            flag = false;
                            break;
                        }else if(A[mid] != A[mid + k]){
                            i = mid + k;
                            flag = false;
                            break;
                        }
                    }
                    if(flag)
                        return false;
                }
            }
        }
        return false;
    }

34. Search for a Range
最优解：二分查找
package array;

public class SearchforaRange {

    /**
Given a sorted array of integers,
find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

 For example,
 Given [5, 7, 7, 8, 8, 10] and target value 8,
 return [3, 4].

     */
    public static void main(String[] args) {
        int[] a = {5, 7, 7, 8, 8, 10};
        System.out.println(searchRange(a, 8));

    }
//1 二分查找
    public static int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target) {
                //1朝前找第一个不为target的元素
                int start = 0;
                int end = 0;
                for (int i = mid - 1;i >= low;i--) {
                    if (nums[i] == target) start++;
                    else break;
                }
                //2朝后找第一个不为target的元素
                for (int i = mid + 1;i <= high;i++) {
                    if (nums[i] == target) end++;
                    else break;
                }
                return new int[]{mid - start,mid + end};
            } else if (nums[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return new int[]{-1,-1};
    }
    //2 九章的答案 原理也是二分查找
    public int[] searchRange1(int[] A, int target) {
        if (A.length == 0) {
            return new int[]{-1, -1};
        }

        int start, end, mid;
        int[] bound = new int[2];

        // search for left bound
        start = 0;
        end = A.length - 1;
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                end = mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (A[start] == target) {
            bound[0] = start;
        } else if (A[end] == target) {
            bound[0] = end;
        } else {
            bound[0] = bound[1] = -1;
            return bound;
        }

        // search for right bound
        start = 0;
        end = A.length - 1;
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                start = mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (A[end] == target) {
            bound[1] = end;
        } else if (A[start] == target) {
            bound[1] = start;
        } else {
            bound[0] = bound[1] = -1;
            return bound;
        }

        return bound;
    }
}
 

35. Search Insert Position
最优解：二分查找
package array;

public class SearchInsertPosition {

    /**
Given a sorted array and a target value,
return the index if the target is found.
If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

 Here are few examples.
 [1,3,5,6], 5 → 2
 [1,3,5,6], 2 → 1
 [1,3,5,6], 7 → 4
 [1,3,5,6], 0 → 0

     */
    public static void main(String[] args) {
        int[] a = {1,3,5,6};
        System.out.println(searchInsert3(a,2));
    }

    //3 优化后的二分查找
    public static int searchInsert3(int[] A, int target) {
        int low = 0, high = A.length-1;
        while(low <= high){
            int mid =low + (high - low) / 2;
            if(A[mid] == target) return mid;
            else if(A[mid] > target) high = mid-1;
            else low = mid+1;
        }
        return low;
    }
    //2 二分查找 找到第一个比指定元素大的位置(需要排除两头的情况)
    public static int searchInsert2(int[] nums, int target) {
        if (nums == null || nums[0] >= target) return 0;
        if (nums != null && nums[nums.length - 1] < target) return nums.length;
        if (nums != null && nums[nums.length - 1] == target) return nums.length - 1;
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (mid == left) return left + 1;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
    //1 直接遍历数组，找到第一个比指定元素大或者相等的位置即可。时间复杂度为N
     public static int searchInsert1(int[] nums, int target) {
            int i = 0;
            if (nums != null && nums[nums.length - 1] < target) return nums.length;
            for (i = 0;i < nums.length;i++) {
                if (nums[i] >= target) return i;
            }
            return i;
        }



}

39. Combination Sum
优解是：DFS深度遍历算法

package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CombinationSum {

    /**
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note:

•All numbers (including target) will be positive integers.
•The solution set must not contain duplicate combinations.

For example, given candidate set [2, 3, 6, 7] and target 7,
A solution set is:

[
  [7],
  [2, 2, 3]
]

     */
    public static void main(String[] args) {
        int[] a = {1,1,2};
        System.out.println(combinationSum21(a,3));
    }


    public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);


        return null;
    }
    // 1 DFS深度遍历算法
    public static List<List<Integer>> combinationSum21(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        back(res, new ArrayList<Integer>(), candidates, target, 0);
        return res;
    }
//第一种方式去重
    public static void back(List<List<Integer>> res,List<Integer> list,int[] nums,int target,int start) {
        if (target == 0) {
            List<Integer> t = new ArrayList<Integer>(list);
            res.add(t);
        }
        //这句代码作用，提前结束
        if (start > nums.length || target < 0) return; //不加这一句话时 Time Limit Exceeded
        for (int i = start;i < nums.length;i++) {
            //去重
            if (i > start && nums[i] == nums[i-1]) continue;
            list.add(nums[i]);
            back(res, list, nums, target - nums[i], i);
            list.remove(list.size() - 1);
        }
    }
 //第二种方式去重
    public static void back1(List<List<Integer>> res,List<Integer> list,int[] nums,int target,int start) {
        if (target == 0) {
            List<Integer> t = new ArrayList<Integer>(list);
            //去重
            if (!res.contains(t)) res.add(t);
        }
        //这句代码作用，提前结束
        if (start > nums.length || target < 0) return; //不加这一句话时 Time Limit Exceeded
        for (int i = start;i < nums.length && target >= nums[i];i++) {
            list.add(nums[i]);
            back(res, list, nums, target - nums[i], i);
            list.remove(list.size() - 1);
        }
    }


}
九章算法答案：和上面的解法原理一样

public  ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int target) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if (candidates == null) {
            return result;
        }

        ArrayList<Integer> path = new ArrayList<Integer>();
        Arrays.sort(candidates);
        helper(candidates, target, path, 0, result);

        return result;
    }

    void helper(int[] candidates, int target, ArrayList<Integer> path, int index,
        ArrayList<ArrayList<Integer>> result) {
        if (target == 0) {
            result.add(new ArrayList<Integer>(path));
            return;
        }

        int prev = -1;
        for (int i = index; i < candidates.length; i++) {
            if (candidates[i] > target) {
                break;
            }

            if (prev != -1 && prev == candidates[i]) {
                continue;
            }

            path.add(candidates[i]);
            helper(candidates, target - candidates[i], path, i, result);
            path.remove(path.size() - 1);

            prev = candidates[i];
        }
    }

40. Combination Sum II

优解是：DFS深度遍历算法，法1与法2原理一样，但是法2简化代码
package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class CombinationSumII {

    /**
Given a collection of candidate numbers (C) and a target number (T),
find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:

•All numbers (including target) will be positive integers.
•The solution set must not contain duplicate combinations.

For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:

[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
[1,1,2,5,6,7,10]
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a = {10, 1, 2, 7, 6, 1, 5};
        System.out.println(combinationSum22(a,8));

    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        Set<Integer> set  = new HashSet<Integer>();
        for (int i = 0;i < candidates.length;i++) {
            set.add(candidates[i]);
        }


        return null;
    }


  //1 回溯法Time Limit Exceeded（当数组较大时，因为压站出站耗时）
    public static List<List<Integer>> combinationSum21(int[] candidates, int target) {
        Arrays.sort(candidates);
        int len = 0;
        for (int i = 0;i < candidates.length;i++) {
            if (candidates[i] <= target) {
                len++;
            }
        }
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        back(res, new ArrayList<Integer>(), candidates, target, len, 0);
        return res;
    }

    public static void back(List<List<Integer>> res,List<Integer> list,int[] nums,int target,int len,int start) {
        if (target == 0) {
            List<Integer> t = new ArrayList<Integer>(list);
            if (!res.contains(t)) res.add(t);
        }
        //这句代码作用，提前结束
        if (start > len || target < 0) return; //不加这一句话时 Time Limit Exceeded
        for (int i = start;i < len;i++) {
            list.add(nums[i]);
            back(res, list, nums, target - nums[i], len, i + 1);
            list.remove(list.size() - 1);
        }
    }
    //2  原理同1
    public static List<List<Integer>> combinationSum22(int[] cand, int target) {
        Arrays.sort(cand);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> path = new ArrayList<Integer>();
        dfs_com(cand, 0, target, path, res);
        return res;
    }
   public static void  dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {
        if (target == 0) {
            res.add(new ArrayList(path));
            return ;
        }
        if (cur > cand.length || target < 0) return;
        for (int i = cur; i < cand.length; i++){
            //跳过重复元素，原理
            if (i > cur && cand[i] == cand[i-1]) continue;
            path.add(path.size(), cand[i]);
            dfs_com(cand, i+1, target - cand[i], path, res);
            path.remove(path.size()-1);
        }
    }

}
九章算法的答案（基本思想一样，细节处理有点差异）
public class Solution {

    private ArrayList<ArrayList<Integer>> results;

    public ArrayList<ArrayList<Integer>> combinationSum2(int[] candidates,
            int target) {
        if (candidates.length < 1) {
            return results;
        }

        ArrayList<Integer> path = new ArrayList<Integer>();
        java.util.Arrays.sort(candidates);
        results = new ArrayList<ArrayList<Integer>> ();
        combinationSumHelper(path, candidates, target, 0);

        return results;
    }

    private void combinationSumHelper(ArrayList<Integer> path, int[] candidates, int sum, int pos) {
        if (sum == 0) {
            results.add(new ArrayList<Integer>(path));
        }

        if (pos >= candidates.length || sum < 0) {
            return;
        }

        int prev = -1;
        for (int i = pos; i < candidates.length; i++) {
            if (candidates[i] != prev) {
                path.add(candidates[i]);
                combinationSumHelper(path, candidates, sum - candidates[i], i + 1);
                prev = candidates[i];
                path.remove(path.size()-1);
            }
        }
    }

}

216. Combination Sum III

/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-30 上午11:40:39
 */

public class CombinationSumIII {

    /**
     * @author lishuai
     * @data 2016-11-30 上午11:40:39
Find all possible combinations of k numbers that add up to a number n,
given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.


Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        System.out.println(combinationSum(3,9));
    }

    /**
Used backtracking to solve this.
Build an array to apply to "subset" template.
Each time we add an element to the "list", for the next step, target= target - num[i].
Since we have already added one element, for the next step, we can only add k-1 elements.
Since no duplicated elements accept, for the next loop, the "start" should point to the next index of current index.
The list.remove(list.size() - 1) here means, we need to change the element here. I know it is hard to understand it,
let me give you an example.
When k=3, n=9, my answer works like this:
[1]->[1,2]->[1,2,3]. Since now sum is not 9, no more backtracking, so after list.remove(list.size() - 1),
it is [1,2]. Then next follows [1,2,4], sum is not 9, repeat process above untill [1,2,6].
When go to next backtracking, the list will be added to result, and for this list, no more backtracking.
Now we can go back to a previous backtracking, which is [1,3]->[1,3,4], fail. [1,4,]->[1,4,5], fail. And so one.
So the point of list.remove(list.size() - 1) is, after each "fail" or "success",
since we don't need to do further attempts given such a condition, we delete the last element,
and then end current backtracking. Next step is, add the next element to the deleted index, go on attempting.
     */
    //1 backtracking 回溯法+dfs深度优先算法
    public static List<List<Integer>> combinationSum31(int k, int n) {
        int[] num = {1,2,3,4,5,6,7,8,9};
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        helper(result, new ArrayList<Integer>(), num, k, n,0);
        return result;
    }
    public static void helper(List<List<Integer>> result, List<Integer> list, int[] num, int k, int target, int start){
        if (k == 0 && target == 0){
            result.add(new ArrayList<Integer>(list));
        } else {
            for (int i = start; i < num.length && target > 0 && k >0; i++){
                list.add(num[i]);
                helper(result, list, num, k-1,target-num[i],i+1);
                list.remove(list.size()-1);
            }
        }
    }


  //2 和1一样
    public static List<List<Integer>> combinationSum3(int k, int n) {

         List<List<Integer>> ans = new ArrayList<>();
         combination(ans, new ArrayList<Integer>(), k, 1, n);
         return ans;

    }


    private static void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {
        if (comb.size() == k && n == 0) {
            List<Integer> li = new ArrayList<Integer>(comb);
            ans.add(li);
            return;
        }
        for (int i = start; i <= 9; i++) {
            comb.add(i);
            combination(ans, comb, k, i+1, n-i);
            comb.remove(comb.size() - 1);
        }
    }


    //3自己参照写的 思路：回溯法+深度优先搜索   根据k和n的递减表示符合结果的元素在增加，当两者都为零的集合满足要求；
    //在不满足并且元素数已经达到最大的集合，去掉集合最后一个元素，继续搜索（类似于回溯剪枝）
    public static List<List<Integer>> combinationSum(int k, int n) {
         int[] nums={1,2,3,4,5,6,7,8,9};
            List<List<Integer>> res=new ArrayList<List<Integer>>();
            backTrack(res, new ArrayList<Integer>(),nums, k, n, 0);

            return res;

   }

    public static void backTrack( List<List<Integer>> res,List<Integer> comb,int[] nums,int k,int target,int start){
        if(target==0&&k==0){
            List<Integer> list=new ArrayList<Integer>(comb);
            res.add(list);
            return;
        }
        for(int i=start;i<nums.length&&k>0&&target>0;i++){
            comb.add(nums[i]);
            backTrack(res, comb, nums, k-1, target-nums[i], i+1);
            comb.remove(comb.size()-1);
        }
    }

}


41. First Missing Positive
优解：方法2
package array;

public class FirstMissingPositive {

    /**
Given an unsorted integer array,
find the first missing positive integer.

For example,
 Given [1,2,0] return 3,
 and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.

     */
    public static void main(String[] args) {
        int[] a = {-1,6,1,2};
        System.out.println(firstMissingPositive(a));


    }
    /**
The key here is to use swapping to keep constant space and
also make use of the length of the array,
which means there can be at most n positive integers.
So each time we encounter an valid integer,
find its correct position and swap. Otherwise we continue.
     */
    //2          第i个元素的值为i+1（这一点不太好理解）
     public static int firstMissingPositive2(int[] A) {
            int i = 0;
            while(i < A.length){
                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;
                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);
                else i++;
            }
            i = 0;
            while(i < A.length && A[i] == i+1) i++;
            return i+1;
        }

    private static void swap(int[] A, int i, int j){
            int temp = A[i];
            A[i] = A[j];
            A[j] = temp;
    }
 

45. Jump Game II（最小跳）
最优解：时间复杂度N
package array;

public class JumpGameII {

    /**
Given an array of non-negative integers,
you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:
 Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2.
(Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:
 You can assume that you can always reach the last index.

     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }
// version 1: Dynamic Programming
// 2、这个方法，复杂度是 O(n^2)，会超时，但是依然需要掌握。
    public int jump2(int[] A) {
        // state
        int[] steps = new int[A.length];

        // initialize
        steps[0] = 0;
        for (int i = 1; i < A.length; i++) {
            steps[i] = Integer.MAX_VALUE;
        }

        // function
        for (int i = 1; i < A.length; i++) {
            for (int j = 0; j < i; j++) {
                if (steps[j] != Integer.MAX_VALUE && j + A[j] >= i) {
                    steps[i] = Math.min(steps[i], steps[j] + 1);
                }
            }
        }

        // answer
        return steps[A.length - 1];
    }
    /**
二指针问题，最大覆盖区间。
从左往右扫描，维护一个覆盖区间，每扫过一个元素，就重新计算覆盖区间的边界。
比如，开始时区间[start, end], 遍历A数组的过程中，不断计算A[i]+i最大值（即从i坐标开始最大的覆盖坐标），
并设置这个最大覆盖坐标为新的end边界。而新的start边界则为原end+1。不断循环，直到end> n.
     */
    //1
     public int jump(int[] A) {
            if (A == null || A.length == 0) {
                return -1;
            }
            int start = 0, end = 0, jumps = 0;
            while (end < A.length - 1) {
                jumps++;
                int farthest = end;
                for (int i = start; i <= end; i++) {
                    if (A[i] + i > farthest) {
                        farthest = A[i] + i;
                    }
                }
                start = end + 1;
                end = farthest;
            }
            return jumps;
        }
    public int jump0(int[] nums) {

        return  0;
    }
}

55. Jump Game（看是否能跳到尾部）
最优解:贪心算法，时间复杂度为N
package array;

public class JumpGame {

    /**
Given an array of non-negative integers,
you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length
at that position.

Determine if you are able to reach the last index.

For example:
 A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.

     */
    public static void main(String[] args) {
        int[] a = {3,2,1,0,4};
        System.out.println(canJump31(a));
    }

    // 3. DFS.
    public static boolean canJump31(int[] A) {
        if (A == null || A.length == 0) {
            return false;
        }

        return canJump11(A, A.length - 1);
    }

    public static boolean canJump11(int[] A, int index) {
        if (index == 0) {
            return true;
        }

        for (int i = 0; i <= index - 1; i++) {
            if (A[i] >= index - i) {
                return canJump11(A, i);
            }
        }

        return false;
    }



    // version 1: Dynamic Programming
    // 这个方法，复杂度是 O(n^2) 可能会超时，但是依然需要掌握。
    public static boolean canJump3(int[] A) {
        boolean[] can = new boolean[A.length];
        can[0] = true;

        for (int i = 1; i < A.length; i++) {
            for (int j = 0; j < i; j++) {
                if (can[j] && j + A[j] >= i) {
                    can[i] = true;
                    break;
                }
            }
        }

        return can[A.length - 1];
    }

    //2 原理和1一样，只不过从后面遍历
    boolean canJump2(int A[], int n) {
        int last=n-1,i,j;
        for(i=n-2;i>=0;i--){
            if(i+A[i]>=last)last=i;
        }
        return last<=0;
    }
    // if previous maxLocation smaller than i,
    //meaning we cannot reach location i, thus return false.
    /**
    The basic idea is this: at each step,
    we keep track of the furthest reachable index.
    The nature of the problem
    (eg. maximal jumps where you can hit a range of targets
    instead of singular jumps where you can only hit one target)
     is that for an index to be reachable,
      each of the previous indices have to be reachable.

Hence, it suffices that we iterate over each index,
and If we ever encounter an index that is not reachable,
 we abort and return false. By the end,
 we will have iterated to the last index. If the loop finishes,
 then the last index is reachable.

     */
//1 贪心算法    核心思想是保证遍历数组中的每个元素可以到达，否者提前结束。
//（贪心的思维。在考虑本点是否可达的时候，我们是考虑与本点最远的一个点是否可达。实际上这也make sense。
//假设j点可以到达i点，那么后面的点可以不管）
//具体是通过维护前一i-1个可跳的最大步数，和当前下标比较比较，不满足提前结束，否者遍历完，说明数组元素都可到达
     public static boolean canJump1(int[] A) {
        int max = 0;
        for(int i=0;i<A.length;i++){
            if(i>max) {return false;}
            max = Math.max(A[i]+i,max);
        }
        return true;

     }

    //0 跳指定位置的步数（没有理解题意）
    public static boolean canJump0(int[] nums) {
        if (nums.length < 1) return true;
        if (nums.length == 1 && nums[0] != 0) return false;
        int index = 0;
        while (index < nums.length - 1 && nums[index] != 0 && index + nums[index] <= nums.length - 1) {
            index += nums[index];
        }
        if (index == nums.length - 1) return true;
        else return false;
    }
}


53. Maximum Subarray连续最大子串的和
优解：时间复杂度N

public class MaximumSubarray {

    /**
     * @author lishuai
     * @data 2016-12-5 下午3:23:33
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.


More practice:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach,
which is more subtle.
     */

    public static void main(String[] args) {
        int[] a = {-2,1,-3,4,-1,2,1,-5,4};
        System.out.println(maxSubArray(a));

    }
    /**

     */
    //2 动态规划 用一个移位数组保存到当前位置的最大值
    public static int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];
        dp[0] = nums[0];
        int max = dp[0];       
        for(int i = 1; i < n; i++){
            dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
            max = Math.max(max, dp[i]);
        }

        return max;
}

    /**
algorithm that operates on arrays: it starts at the left end (element A[1]) and
scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far.
The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1];
how can we extend that to A[1 .. i]? The maximum
sum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar),
 or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).
MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.
     */
    //1 思想：维护一个全局最大值，一个局部最大值 (第i个位置的最大值，取决于前i-1和第i个位置)
    public static int maxSubArray1(int[] nums) {
        int maxSoFar=nums[0], maxEndingHere=nums[0];
        for (int i=1;i<nums.length;++i){
            maxEndingHere= Math.max(maxEndingHere+nums[i],nums[i]);
            maxSoFar=Math.max(maxSoFar, maxEndingHere);   
        }
        return maxSoFar;
    }
}



54. Spiral Matrix对一个矩阵（二维数组）从外层开始，旋转着读取其中的值放在一个list中
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-5 下午4:23:54
 */

public class SpiralMatrix {

    /**
     * @author lishuai
     * @data 2016-12-5 下午4:23:54
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. spiral 

For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
You should return [1,2,3,6,9,8,7,4,5].
     */

    public static void main(String[] args) {
        int[][] a ={{ 1, 2, 3},{4, 5, 6},{7, 8, 9}};
        System.out.println(spiralOrder(a));
    }
    //2 九章答案 和1差不多，也是分四步一个大循环，减少2行2列，当只有一行或者一列的时候跳出本次循环开始下一次循环
     public static List<Integer> spiralOrder(int[][] matrix) {
            List<Integer> rst = new ArrayList<Integer>();
            if(matrix == null || matrix.length == 0)
                return rst;

            int rows = matrix.length;
            int cols = matrix[0].length;
            int count = 0;
            while(count * 2 < rows && count * 2 < cols){
                //right
                for(int i = count; i < cols-count; i++)
                    rst.add(matrix[count][i]);

                //down
                for(int i = count+1; i< rows-count; i++)
                    rst.add(matrix[i][cols-count-1]);

                if(rows - 2 * count == 1 || cols - 2 * count == 1)  // if only one row /col remains
                    break;
                //left   
                for(int i = cols-count-2; i>=count; i--)
                    rst.add(matrix[rows-count-1][i]);
                //up
                for(int i = rows-count-2; i>= count+1; i--)
                    rst.add(matrix[i][count]);

                count++;
            }
            return rst;
        }

    /**
This is a very simple and easy to understand solution. I traverse right and increment rowBegin,
 then traverse down and decrement colEnd, then I traverse left and decrement rowEnd,
 and finally I traverse up and increment colBegin.

The only tricky part is that when I traverse left or up I have to check
whether the row or col still exists to prevent duplicates.
If anyone can do the same thing without that check, please let me know!Any comments greatly appreciated.
     */
    //1 思想:逐渐缩小范围，走right，down，left，up为一个大循环
     public static List<Integer> spiralOrder1(int[][] matrix) {

            List<Integer> res = new ArrayList<Integer>();

            if (matrix.length == 0) {
                return res;
            }

            int rowBegin = 0;
            int rowEnd = matrix.length-1;
            int colBegin = 0;
            int colEnd = matrix[0].length - 1;

            while (rowBegin <= rowEnd && colBegin <= colEnd) {
                // Traverse Right
                for (int j = colBegin; j <= colEnd; j ++) {
                    res.add(matrix[rowBegin][j]);
                }
                rowBegin++;

                // Traverse Down
                for (int j = rowBegin; j <= rowEnd; j ++) {
                    res.add(matrix[j][colEnd]);
                }
                colEnd--;
                //只有一行会出现重复元素，故加判断
                if (rowBegin <= rowEnd) {
                    // Traverse Left
                    for (int j = colEnd; j >= colBegin; j --) {
                        res.add(matrix[rowEnd][j]);
                    }
                }
                rowEnd--;

                if (colBegin <= colEnd) {
                    // Traver Up
                    for (int j = rowEnd; j >= rowBegin; j --) {
                        res.add(matrix[j][colBegin]);
                    }
                }
                colBegin ++;
            }

            return res;
        }

    //0 参照写的
    public static List<Integer> spiralOrder0(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if (matrix.length == 0) return res;
        int rowstart = 0;
        int rowend = matrix.length - 1;
        int columstart = 0;
        int columend = matrix[0].length - 1;
        while (rowstart <= rowend && columstart <= columend) {
            //right
            for (int i = columstart;i <= columend;i++) {
                res.add(matrix[rowstart][i]);
            }
            rowstart++;
            //down
            for (int i = rowstart;i <= rowend;i++) {
                res.add(matrix[i][columend]);
            }
            columend--;
            //left
            if (rowstart <= rowend) {
                for (int i = columend;i >= columstart;i--) {
                    res.add(matrix[rowend][i]);
                }               
            }
            rowend--;
            //up
            if (columstart <= columend) {
                for (int i = rowend;i >= rowstart;i--) {
                    res.add(matrix[i][columstart]);
                }               
            }
            columstart++;
        }


        return res;
    }
}


59. Spiral Matrix II
优解：和Spiral Matrix的原理差不多，关键是按照螺旋形状，把所有元素的位置遍历一遍即可
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-5 下午5:40:53
 */

public class SpiralMatrixII {

    /**
     * @author lishuai
     * @data 2016-12-5 下午5:40:53
Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(generateMatrix(3));
    }
    //2 九章
    public static int[][] generateMatrix(int n) {
        if (n < 0) {
            return null;
        }

        int[][] result = new int[n][n];

        int xStart = 0;
        int yStart = 0;
        int num = 1;

        while (n > 0) {
            if (n == 1) {
                result[yStart][xStart] = num++;
                break;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart][xStart + i] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + i][xStart + n - 1] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + n - 1][xStart + n - 1 - i] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + n - 1 - i][xStart] = num++;
            }

            xStart++;
            yStart++;
            n = n - 2;
        }

        return result;
    }


    //1 思想借助于Spiral Matrix，在指定的位置写入值即可
    public static int[][] generateMatrix1(int n) {

        int[][] matrix = new int[n][n];
        if (n <= 0) return matrix;
        int k = 1;
        int rowBegin = 0;
        int rowEnd = n - 1;
        int colBegin = 0;
        int colEnd = n - 1;

        while (rowBegin <= rowEnd && colBegin <= colEnd) {
            // Traverse Right
            for (int j = colBegin; j <= colEnd; j ++) {
                matrix[rowBegin][j] = k;
                k++;
            }
            rowBegin++;

            // Traverse Down
            for (int j = rowBegin; j <= rowEnd; j ++) {
                matrix[j][colEnd] = k;
                k++;
            }
            colEnd--;
            //只有一行会出现重复元素，故加判断
            if (rowBegin <= rowEnd) {
                // Traverse Left
                for (int j = colEnd; j >= colBegin; j --) {
                    matrix[rowEnd][j] = k;
                    k++;
                }
            }
            rowEnd--;

            if (colBegin <= colEnd) {
                // Traver Up
                for (int j = rowEnd; j >= rowBegin; j --) {
                    matrix[j][colBegin] = k;
                    k++;
                }
            }
            colBegin ++;
        }
        return matrix;
    }
}



56. Merge Intervals
优解：解法2
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-5 上午9:01:04
 */

public class MergeIntervals {

    /**
     * @author lishuai
     * @data 2016-12-5 上午9:01:04
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].


[[1,4],[0,4]]

[[1,4],[2,3]]
[[1,4],[0,2],[3,5]]   [[0,5]]
     */

    public static void main(String[] args) {
        List<Interval> list = new ArrayList<Interval>();
//        list.add(new Interval(1,4));
//        list.add(new Interval(0,2));
//        list.add(new Interval(3,5));
        merge(list);

    }
    //2 效率：时间复杂度N，空间复杂度N
    //思路：首先对list集合排序（根据起始点值得大小）；维护一个起始点和终点，当当前元素和下一个元素有重叠时，更新终点值（取当前元素的终点和全局终点值比较，取较大的）；
    //否则，把当前范围写入返回list中，更新起始点和终点；最后再加入一个起始点和终点表示的范围；
    public static List<Interval> merge(List<Interval> intervals) {
        if (intervals.size() <= 1) return intervals;
        List<Interval> res =  new ArrayList<Interval>();
        Collections.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval i1,Interval i2) {
                return Integer.compare(i1.start,i2.start);   
            }                       
        });
        int start = intervals.get(0).start;
        int end = intervals.get(0).end;
        for (int i = 1;i < intervals.size();i++) {
            if (intervals.get(i).start <= end) {
                end = intervals.get(i).end > end ? intervals.get(i).end : end;
            } else {
                res.add(new Interval(start,end));
                start = intervals.get(i).start;
                end = intervals.get(i).end;
            }
        }
        res.add(new Interval(start,end));
        return res;
    }


    // 1ac解，觉得效率不是很高两层for循环
    public static List<Interval> merge1(List<Interval> intervals) {
        for (int i = 0;i < intervals.size() - 1;i++) {
            for (int j = i +1;j < intervals.size();j++) {
                Interval t1 = null;
                Interval t2 = null;
                // t1 放起点较低的 ，t2放起点较高的
                if (intervals.get(i).start <= intervals.get(j).start) {
                     t1 = intervals.get(i);
                     t2 = intervals.get(j);
                } else {
                     t1 = intervals.get(j);
                     t2 = intervals.get(i);
                }               
                if (t1.end >= t2.start) {
                    //有重合时 end放终点最大的数
                    int end = t1.end > t2.end ? t1.end : t2.end;
                    Interval t3 = new Interval(t1.start,end);
                    intervals.remove(t1);
                    intervals.remove(t2);
                    intervals.add(t3);
                    //每执行一次合并操作，回到起点重新遍历
                    i = -1;
                    break;
                }                 
            }
        }       
        return intervals;
    }
}



57. Insert Interval
优解：时间复杂度N
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-5 上午10:22:21
 */

public class InsertInterval {

    /**
     * @author lishuai
     * @data 2016-12-5 上午10:22:21
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].
This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
     */

    public static void main(String[] args) {
        List<Interval> list = new ArrayList<Interval>();
        list.add(new Interval(1,3));
        list.add(new Interval(6,9));
        Interval newInterval = new Interval(2,5);
        insert4(list, newInterval);
    }
    //4 九章答案  思想和2，3差不多，都是采用更新插入值newInterval得范围
    public static List<Interval> insert4(List<Interval> intervals, Interval newInterval) {
        if (newInterval == null || intervals == null) {
            return intervals;
        }

        List<Interval> results = new ArrayList<Interval>();
        int insertPos = 0;

        for (Interval interval : intervals) {
            if (interval.end < newInterval.start) {
                results.add(interval);
                insertPos++;
            } else if (interval.start > newInterval.end) {
                results.add(interval);
            } else {
                newInterval.start = Math.min(interval.start, newInterval.start);
                newInterval.end = Math.max(interval.end, newInterval.end);
            }
        }

        results.add(insertPos, newInterval);

        return results;
    }

    //3 和2的思想一致，但是不需要额外的存储空间
    public List<Interval> insert3(List<Interval> intervals, Interval newInterval) {
        int i=0;
        while(i<intervals.size() && intervals.get(i).end<newInterval.start) i++;
        while(i<intervals.size() && intervals.get(i).start<=newInterval.end){
            newInterval = new Interval(Math.min(intervals.get(i).start, newInterval.start), Math.max(intervals.get(i).end, newInterval.end));
            intervals.remove(i);
        }
        intervals.add(i,newInterval);
        return intervals;
}
    //2
    public static List<Interval> insert2(List<Interval> intervals, Interval newInterval) {       
        List<Interval> result = new ArrayList<Interval>();
        int i = 0;
        // add all the intervals ending before newInterval starts
        while (i < intervals.size() && intervals.get(i).end < newInterval.start)
            result.add(intervals.get(i++));
        //更新newInterval的值
        // merge all overlapping intervals to one considering newInterval
        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {
            newInterval = new Interval( // we could mutate newInterval here also
                    Math.min(newInterval.start, intervals.get(i).start),
                    Math.max(newInterval.end, intervals.get(i).end));
            i++;
        }
        result.add(newInterval); // add the union of intervals we got
        // add all the rest
        while (i < intervals.size()) result.add(intervals.get(i++));
        return result;
    }

    //1 有问题
    public static List<Interval> insert1(List<Interval> intervals, Interval newInterval) {       
        List<Interval> res =  new ArrayList<Interval>();
        if (intervals.size() < 1) {
            res.add(newInterval);
            return res;
        }
        int low = -1;
        int high = -1;
        for (int i = 0;i < intervals.size();i++) {
            if (intervals.get(i).start <= newInterval.start && intervals.get(i).end >= newInterval.start) low = i;
            if (intervals.get(i).start <= newInterval.end && intervals.get(i).end >= newInterval.end) high = i;           
        }
        if (low == -1 && high ==-1) {
            if (newInterval.end < intervals.get(0).start) {
                intervals.add(0,newInterval);
                return intervals;
            } else if (newInterval.start > intervals.get(intervals.size() - 1).end){
                intervals.add(newInterval);
                return intervals;
            } else {
                res.add(newInterval);
                return res;
            }
        } else if (low == -1) {
            res.add(new Interval(newInterval.start,intervals.get(high).end));
            for (int i = high + 1;i < intervals.size();i++) {
                res.add(intervals.get(i));
            } 
        } else if (high == -1) {
            for (int i = 0;i < low;i++) {
                res.add(intervals.get(i));
            }
            res.add(new Interval(intervals.get(low).start,newInterval.end));


        } else {
            for (int i = 0;i < low;i++) {
                res.add(intervals.get(i));
            }
            res.add(new Interval(intervals.get(low).start,intervals.get(high).end));
            for (int i = high + 1;i < intervals.size();i++) {
                res.add(intervals.get(i));
            }       
        }
        return res;
    }
}



66. Plus One使用数组保存一个数，然后加1（需要考虑进位的情况）
优解：法1，时间复杂度N
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-6 上午10:16:53
 */

public class PlusOne {

    /**
     * @author lishuai
     * @data 2016-12-6 上午10:16:53
Given a non-negative number represented as an array of digits, plus one to the number.

The digits are stored such that the most significant digit is at the head of the list. 高位在前，低位在后
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

    /**
     The complexity is O(1)
     f(n) = 9/10 + 1/10 * O(n-1)
      ==>  O(n) =  10 / 9 = 1.1111 = O(1)
     */   
    //2九章算法答案(觉得效率并不是很高)
    public static int[] plusOne(int[] digits) {
        int carries = 1;
        for(int i = digits.length-1; i>=0 && carries > 0; i--){  // fast break when carries equals zero
            int sum = digits[i] + carries;
            digits[i] = sum % 10;
            carries = sum / 10;
        }
        if(carries == 0)
            return digits;

        int[] rst = new int[digits.length+1];
        rst[0] = 1;
        for(int i=1; i< rst.length; i++){
            rst[i] = digits[i-1];
        }
        return rst;
    }
    //1 感觉和0的算法基本一致，但是简化代码
    public static int[] plusOne1(int[] digits) {
        int n = digits.length;
        for(int i = n-1; i >= 0; i--) {
            if(digits[i] < 9) {
                digits[i]++;
                return digits;
            }           
            digits[i] = 0;
        }       
        int[] newNumber = new int [n+1];
        newNumber[0] = 1;

        return newNumber;
    }
    //效率：N
    //0 思想：需要判断数组的最后一个和最高位那个是否为9，不为9的直接加1返回；是9的继续朝前找，知道找到第一个不是9的或者遍历完所有
    public static int[] plusOne0(int[] digits) {
        for(int i = digits.length-1;i >= 0;i--){
            if(i == 0){
                if(digits[0] == 9){
                    digits[0] = 0;
                    int[] b = new int[digits.length + 1];
                    System.arraycopy(digits, 0, b, 1, digits.length);
                    b[0] = 1;
                    return b;
                }
            }                       
            if(digits[i] != 9){
                digits[i] = digits[i] + 1;
                break;
            } else digits[i] = 0;           
        }
        return digits;
    }
}


74. Search a 2D Matrix在一个二维局部有序中搜索
优解：2；二分查找
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2017-1-3 上午10:55:04
 */

public class Searcha2DMatrix {

    /**
     * @author lishuai
     * @data 2017-1-3 上午10:55:04
Write an efficient algorithm that searches for a value in an m x n matrix.
This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

Consider the following matrix:

[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.
     */

    public static void main(String[] args) {


    }
    //4九章
     public boolean searchMatrix(int[][] matrix, int target) {
            if (matrix == null || matrix.length == 0) {
                return false;
            }
            if (matrix[0] == null || matrix[0].length == 0) {
                return false;
            }

            int row = matrix.length;
            int column = matrix[0].length;

            // find the row index, the last number <= target
            int start = 0, end = row - 1;
            while (start + 1 < end) {
                int mid = start + (end - start) / 2;
                if (matrix[mid][0] == target) {
                    return true;
                } else if (matrix[mid][0] < target) {
                    start = mid;
                } else {
                    end = mid;
                }
            }
            if (matrix[end][0] <= target) {
                row = end;
            } else if (matrix[start][0] <= target) {
                row = start;
            } else {
                return false;
            }

            // find the column index, the number equal to target
            start = 0;
            end = column - 1;
            while (start + 1 < end) {
                int mid = start + (end - start) / 2;
                if (matrix[row][mid] == target) {
                    return true;
                } else if (matrix[row][mid] < target) {
                    start = mid;
                } else {
                    end = mid;
                }
            }
            if (matrix[row][start] == target) {
                return true;
            } else if (matrix[row][end] == target) {
                return true;
            }
            return false;
        }

    //3九章
      public boolean searchMatrix3(int[][] matrix, int target) {
            if (matrix == null || matrix.length == 0) {
                return false;
            }
            if (matrix[0] == null || matrix[0].length == 0) {
                return false;
            }

            int row = matrix.length, column = matrix[0].length;
            int start = 0, end = row * column - 1;

            while (start + 1 < end) {
                int mid = start + (end - start) / 2;
                int number = matrix[mid / column][mid % column];
                if (number == target) {
                    return true;
                } else if (number < target) {
                    start = mid;
                } else {
                    end = mid;
                }
            }

            if (matrix[start / column][start % column] == target) {
                return true;
            } else if (matrix[end / column][end % column] == target) {
                return true;
            }

            return false;
        }

//    Use binary search.
//
//    n * m matrix convert to an array => matrix[x][y] => a[x * m + y]
//
//    an array convert to n * m matrix => a[x] =>matrix[x / m][x % m];
//
//    class Solution {
//    public:
//        bool searchMatrix(vector<vector<int> > &matrix, int target) {
//            int n = matrix.size();
//            int m = matrix[0].size();
//            int l = 0, r = m * n - 1;
//            while (l != r){
//                int mid = (l + r - 1) >> 1;
//                if (matrix[mid / m][mid % m] < target)
//                    l = mid + 1;
//                else
//                    r = mid;
//            }
//            return matrix[r / m][r % m] == target;
//        }
//    };
    //2 Don't treat it as a 2D matrix, just treat it as a sorted list;  Use  binary search.二分查找 0ms
     public static boolean searchMatrix2(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
                return false;
        }
        int rows = matrix.length;
        int colums = matrix[0].length;
        if (target < matrix[0][0] || target > matrix[rows - 1][colums -1]) {
            return false;
        }
        int left = 0;
        int right = rows * colums - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (matrix[mid / colums][mid % colums] == target) {
                return true;
            } else if (matrix[mid / colums][mid % colums] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }         
        return false;
     }

    //1 思路：首先确定它在哪一行，然后遍历该行即可        0ms
    public static boolean searchMatrix1(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        int rows = matrix.length;
        int colums = matrix[0].length;
        if (target < matrix[0][0] || target > matrix[rows - 1][colums -1]) {
            return false;
        }
        for (int i = 0; i < rows; i++) {           
            if (matrix[i][0] <= target && matrix[i][colums - 1] >= target) {
                for (int j = 0; j < colums; j++) {
                    if (matrix[i][j] == target) {
                        return true;
                    }
                }
            }
        }       
        return false;
    }
}



75. Sort Colors
优解：二指针，时间复杂度N，空间复杂度O（1）
/**
 *
 */
package array;

import java.util.HashMap;
import java.util.Map;

/**
 * @author lishuai
 * @data 2016-12-6 下午3:02:53
 */

public class SortColors {

    /**
     * @author lishuai
     * @data 2016-12-6 下午3:02:53
Given an array with n objects colored red, white or blue,
sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.
     */

    public static void main(String[] args) {
         int[] a = {0,1,0};
         sortColors(a);
         System.out.println();
    }
    //4 九章        二指针
    public static void sortColors(int[] a) {
        if (a == null || a.length <= 1) {
            return;
        }       
        int pl = 0;
        int pr = a.length - 1;
        int i = 0;
        while (i <= pr) {
            if (a[i] == 0) {
                swap(a, pl, i);
                pl++;
                i++;
            } else if(a[i] == 1) {
                i++;
            } else {
                swap(a, pr, i);
                pr--;
            }
        }
    }

    //3 二指针
     public static void sortColors3(int[] A) {
           if(A==null || A.length<2) return;
           int low = 0;
           int high = A.length-1;
           for(int i = low;i <= high;) {
               if(A[i] == 0) {
                  // swap A[i] and A[low] and i,low both ++
                  int temp = A[i];
                  A[i] = A[low];
                  A[low] = temp;
                  i++;
                  low++;
               }else if(A[i]==2) {
                   //swap A[i] and A[high] and high--;
                  int temp = A[i];
                  A[i] = A[high];
                  A[high] = temp;
                  high--;
               }else {
                   i++;
               }
           }
       }



    //2 思路：二指针一个维护0，一个维护2
    public static void sortColors2(int[] nums) {
        int n = nums.length;
        int second=n-1, zero=0;
        for (int i=0; i<=second; i++) {
            while (nums[i]==2 && i<second) swap(nums,i, second--);
            //循环的意义，保证交换的最后是与前面第一个非0的数字交换的
            while (nums[i]==0 && i>zero) swap(nums,i, zero++);
        }   
        System.out.println(nums);
    }
    public static void swap(int[] nums,int a,int b) {
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }


    //效率：时间复杂度N，空间复杂度O（3）
    //1 思路：使用map统计每个数字出现的次数，考虑有可能有些数字没有的情况
    public static void sortColors1(int[] nums) {
        if (nums == null || nums.length ==0) return;
        Map<Integer,Integer>  map = new HashMap<Integer,Integer>();
        for (int i = 0;i < nums.length;i++) {
            if (nums[i] == 0) map.put(0, map.get(0) != null ? map.get(0) + 1 : 1);
            if (nums[i] == 1) map.put(1, map.get(1) != null ? map.get(1) + 1 : 1);
            if (nums[i] == 2) map.put(2, map.get(2) != null ? map.get(2) + 1 : 1);
        }
        int k = 0;
        while (map.get(0) != null && k < map.get(0)) nums[k++] = 0;
        if (map.get(0) != null) {
             while (map.get(1) != null && k < map.get(1) + map.get(0)) nums[k++] = 1;
        } else {
             while (map.get(1) != null && k < map.get(1)) nums[k++] = 1;
        }       
        while (k < nums.length) nums[k++] = 2;
        System.out.println();
    }

}




78. Subsets
优解：2
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-6 下午2:24:32
 */

public class Subsets {

    /**
     * @author lishuai
     * @data 2016-12-6 下午2:24:32
Given a set of distinct integers, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
     */

    public static void main(String[] args) {
        int[] a = {1,2,3};
        System.out.println(subsets1(a));

    }
    //3      No messy indexing. Avoid the ConcurrentModificationException by using a temp list.  4ms
     public static List<List<Integer>> subsets(int[] S) {
            List<List<Integer>> res = new ArrayList<>();
            res.add(new ArrayList<Integer>());           
            Arrays.sort(S);
            for(int i : S) {
                List<List<Integer>> tmp = new ArrayList<>();
                for(List<Integer> sub : res) {
                    List<Integer> a = new ArrayList<>(sub);
                    a.add(i);
                    tmp.add(a);
                }
                res.addAll(tmp);
            }
            return res;
        }

     //2 九章  Non Recursion 1ms
     public static ArrayList<ArrayList<Integer>> subsets2(int[] nums) {
            ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
            int n = nums.length;
            Arrays.sort(nums);

            // 1 << n is 2^n
            // each subset equals to an binary integer between 0 .. 2^n - 1
            // 0 -> 000 -> []
            // 1 -> 001 -> [1]
            // 2 -> 010 -> [2]
            // ..
            // 7 -> 111 -> [1,2,3]
            for (int i = 0; i < (1 << n); i++) {
                ArrayList<Integer> subset = new ArrayList<Integer>();
                for (int j = 0; j < n; j++) {
                    // check whether the jth digit in i's binary representation is 1
                    if ((i & (1 << j)) != 0) {
                        subset.add(nums[j]);
                    }
                }
                result.add(subset);
            }

            return result;
        }

    //1  回溯法  2ms
    public static List<List<Integer>> subsets1(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (nums == null || nums.length == 0) return res;
        Arrays.sort(nums);       
        backtrack(res, new ArrayList<Integer>(), nums, 0);       
        return res;
    }

    private static void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){
        list.add(new ArrayList<Integer>(tempList));
        for(int i = start; i < nums.length; i++) {
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, i + 1);
            tempList.remove(tempList.size() - 1);
        }
    }

}

90. Subsets II
Given a collection of integers that might contain duplicates, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]



public class Solution {
    public List<List<Integer>> subsetsWithDup(int[] num) {
  Arrays.sort(num);
  List<List<Integer>> ret = new ArrayList<>();
  ret.add(new ArrayList<Integer>());

  int size = 0, startIndex;
  for(int i = 0; i < num.length; i++) {
    startIndex = (i >= 1 && num[i] == num[i - 1]) ? size : 0;
    size = ret.size();
    for(int j = startIndex; j < size; j++) {
      List<Integer> temp = new ArrayList<>(ret.get(j));
      temp.add(num[i]);
      ret.add(temp);
    }
  }
  return ret;
}
}
26. Remove Duplicates from Sorted Array删除有序数组的重复元素
最优解：解法2
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-2 下午3:31:32
 */

public class RemoveDuplicatesfromSortedArray {

    /**
     * @author lishuai
     * @data 2016-12-2 下午3:31:32
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the new length.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a = {1,1,2,3,4,5,6,6,6,7};
        System.out.println(removeDuplicates2(a));
    }
    //1 思路：定义两个变量，一个代表上一个元素的值，一个表示无重复元素数组中已经存在多少元素的下标，通过当前值是否和上一个值相等来判断是否放入数组，时间复杂度N
    public static int removeDuplicates1(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int cur = nums[0];
        int k = 1;
        for (int i = 1;i < nums.length;i++) {
           if (cur != nums[i]) {
               nums[k] = nums[i];
               cur = nums[i];
               k++;
           }
        }
        return k;
    }

    //2 和1的思路一样，但是减少一个变量，优化代码。时间复杂度N
    public static int removeDuplicates2(int[] nums) {
        if (nums == null || nums.length == 0) return 0;       
        int k = 1;
        for (int i = 1;i < nums.length;i++) {
           if (nums[i - 1] != nums[i]) {
               nums[k++] = nums[i];
           }
        }
        return k;
    }



}



80. Remove Duplicates from Sorted Array II删除有序数组中的重复元素（重复元素的个数最多为2）
优解：时间复杂度N（法2，3）
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author lishuai
 * @data 2016-12-6 下午4:18:00
 */

public class RemoveDuplicatesfromSortedArrayII {

    /**
     * @author lishuai
     * @data 2016-12-6 下午4:18:00
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?

For example,
Given sorted array nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3.
It doesn't matter what you leave beyond the new length.
     */

    public static void main(String[] args) {
        int[] a = {1,1,1,1,2,2,3};
         System.out.println(removeDuplicates(a));

    }
    //3九章（思路容易想到，具体写代码时需要处理细节问题）
     public static int removeDuplicates(int[] nums) {
            // write your code here
            if(nums == null)
                return 0;
            int cur = 0;
            int i ,j;
            for(i = 0; i < nums.length;){
                int now = nums[i];
                for( j = i; j < nums.length; j++){
                    if(nums[j] != now)
                        break;
                    if(j-i < 2)
                        nums[cur++] = now;
                }
                //跳过重复的
                i = j;
            }
            return cur;
        }

    //2 根据题意的特点 ，后面的和前面至少下标差2，要是后面的大，则说明前面有重复
    public static int removeDuplicates2(int[] nums) {
        int i = 0;
        for (int n : nums)
            if (i < 2 || n > nums[i-2])
                nums[i++] = n;
        return i;
    }
    //效率：时间复杂度和空间复杂度都为N
    //1 思路:步骤有点多，用一个map统计各个数字出现的次数和一个list统计都有哪些数字
    public static int removeDuplicates1(int[] nums) {
        int sum = 0;
        Map<Integer,Integer>  map = new HashMap<Integer,Integer>();
        List<Integer> list = new ArrayList<Integer>();
        for (int i = 0;i < nums.length;i++) {
            if (!list.contains(nums[i])) list.add(nums[i]);
            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);
            else map.put(nums[i], 1);
        }
        int index = 0;
        for (int i = 0;i < list.size();i++) {
            if (map.get(list.get(i)) <= 2) sum += map.get(list.get(i));
            else sum += 2;   
            int k = 0;
            int size = map.get(list.get(i)) > 2 ? 2 : map.get(list.get(i));
            while (k < size) {
                nums[index++] = list.get(i);
                k++;
            }             
        }             
        return sum;
    }

}



85. Maximal Rectangle一个二维矩阵中的最大长方形
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0


Return 6.

public class Solution {
    public int maximalRectangle(char[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return 0;
        }
        int m = matrix.length;
        int n = matrix[0].length;
        int[] left = new int[n];
        int[] right = new int[n];
        int[] height = new int[n];
        int res = 0;
        Arrays.fill(right, n);
        Arrays.fill(height, 0);
        for (int i = 0; i < m; i++) {
            int cur_left = 0, cur_right = n;
            for (int j = 0; j < n; j++) { // compute height (can do this from either side)
                if (matrix[i][j] == '1') {
                    height[j]++;
                } else {
                    height[j] = 0;
                }
            }
            for (int j = 0; j < n; j++) {// compute left (from left to right)
                if (matrix[i][j] == '1') {
                    left[j] = Math.max(left[j], cur_left);
                } else {
                    cur_left = j + 1;
                    left[j] = 0;
                }
            }
            for (int j = n - 1; j >= 0; j--) {// compute right (from right to left)
                if (matrix[i][j] == '1') {
                    right[j] = Math.min(right[j], cur_right);
                } else {
                    cur_right = j;
                    right[j] = n;
                }
            }
            for (int j = 0; j < n; j++) {// compute the area of rectangle (can do this from either side)
                res = Math.max(res, (right[j] - left[j])*height[j]);
            }
        }
        return res;
    }
}

88. Merge Sorted Array合并两个有序数组（注意倒着合并即可）
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int i=m-1;
                int j=n-1;
                int k = m+n-1;
                while(i >=0 && j>=0)
                {
                        if(A[i] > B[j])
                                A[k--] = A[i--];
                        else
                                A[k--] = B[j--];
                }
                while(j>=0)
                        A[k--] = B[j--];
    }
};

public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        System.arraycopy(B, 0, A, m, n);
        Arrays.sort(A);
    }
}


118. Pascal's Triangle
巴斯卡三角形

Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return

[
    [1],
    [1,1],
  [1,2,1],
  [1,3,3,1],
[1,4,6,4,1]
]


public List<List<Integer>> generate(int numRows)
{
        List<List<Integer>> allrows = new ArrayList<List<Integer>>();
        ArrayList<Integer> row = new ArrayList<Integer>();
        for(int i=0;i<numRows;i++)
        {
                row.add(0, 1);
                for(int j=1;j<row.size()-1;j++)
                        row.set(j, row.get(j)+row.get(j+1));
                allrows.add(new ArrayList<Integer>(row));
        }
        return allrows;
       
}


public class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list=new ArrayList<List<Integer>>();
        if(numRows==0){
            return list;
        }else if(numRows==1){
            List<Integer> list1=new ArrayList<Integer>();
            list1.add(0,1);
            list.add(0, list1);
            return list;
        }else{
            List<Integer> list1=new ArrayList<Integer>();
            list1.add(0,1);
            List<Integer> list2=new ArrayList<Integer>();
            list2.add(0, 1);
            list2.add(1, 1);
            list.add(0, list1);
            list.add(1, list2);
            for(int i=2;i<numRows;i++){
                list.add(i,new ArrayList<Integer>());
                List<Integer> front =list.get(i-1);
                List<Integer> temp =list.get(i);
                temp.add(0, 1);           
                for(int j=1;j<front.size();j++){
                    int var=front.get(j-1)+front.get(j);
                    temp.add(j,var);
                }
                temp.add(i, 1);

            }
            System.out.println(list.size());
            return list;


119. Pascal's Triangle II返回某一行


Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?

public List<Integer> getRow(int rowIndex) {
            if(rowIndex==0){
            List<Integer>  list=new ArrayList<Integer>();
            list.add(0, 1);
            return list;
        }else if(rowIndex==1){
            List<Integer>  list=new ArrayList<Integer>();
            list.add(0, 1);
            list.add(1, 1);
            return list;
        }else{
            List<List<Integer>> list=new ArrayList<List<Integer>>();
            List<Integer> list1=new ArrayList<Integer>();
            list1.add(0,1);
            List<Integer> list2=new ArrayList<Integer>();
            list2.add(0, 1);
            list2.add(1, 1);
            list.add(0, list1);
            list.add(1, list2);
            for(int i=2;i<rowIndex+1;i++){
                list.add(i,new ArrayList<Integer>());
                List<Integer> front =list.get(i-1);
                List<Integer> temp =list.get(i);
                temp.add(0, 1);           
                for(int j=1;j<front.size();j++){
                    int var=front.get(j-1)+front.get(j);
                    temp.add(j,var);
                }
                temp.add(i, 1);

            }
            System.out.println(list.size());
            return list.get(rowIndex);
        }


public static List<Integer> getRow2(int rowIndex) {
        List<Integer> ret = new ArrayList<Integer>();
        ret.add(1);
        for (int i = 1; i <= rowIndex; i++) {
                for (int j = i - 1; j >= 1; j--) {
                        int tmp = ret.get(j - 1) + ret.get(j);
                        ret.set(j, tmp);
                }
                ret.add(1);
        }
        return ret;
}




120. Triangle数字三角形中从顶到底的路径和最小（dp）
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
    [2],
    [3,4],
  [6,5,7],
  [4,1,8,3]
]


The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

public int minimumTotal(int[][] a) {
        // write your code here
        if (a == null || a.length == 0 || a[0].length == 0) {
            return 0;
        }
        int minPath = 0;
        int m = a.length;
        int n = a[m - 1].length;
        int[][] res = new int[m][n];
        res[0][0] = a[0][0];
        for (int i = 1; i < m; i++) {
            res[i][0] = res[i - 1][0] + a[i][0];
            res[i][i] = res[i - 1][i - 1] + a[i][i];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < i; j++) {
                int up = res[i - 1][j];
                int upLeft = res[i - 1][j - 1];               
                res[i][j] = (up > upLeft ? upLeft : up) + a[i][j];               
            }
        }
        minPath = res[m - 1][0];
        for (int i = 1; i < n; i++) {
            if (res[m - 1][i] < minPath) {
                minPath = res[m - 1][i];
            }
        }
        return minPath;
    }

128. Longest Consecutive Sequence最长的连续序列
优解：使用hashset和hashmap均可
/**
 *
 */
package array;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * @author lishuai
 * @data 2016-12-1 下午4:53:36
 */

public class LongestConsecutiveSequence {

    /**
     * @author lishuai
     * @data 2016-12-1 下午4:53:36
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={100, 4, 200, 1, 3, 2};
        System.out.println(longestConsecutive2(a));
    }
    /**
We will use HashMap.
The key thing is to keep track of the sequence length and store that in the boundary points of the sequence.
For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5.

Whenever a new element n is inserted into the map, do two things:

See if n - 1 and n + 1 exist in the map, and if so, it means there is an existing sequence next to n.
Variables left and right will be the length of those two sequences,
 while 0 means there is no sequence and n will be the boundary point later.
 Store (left + right + 1) as the associated value to key n into the map.
Use left and right to locate the other end of the sequences to the left and right of n respectively,
and replace the value with the new length.
Everything inside the for loop is O(1) so the total time is O(n).
     */
    // 1HashMap
    public static int longestConsecutive(int[] nums) {
        int res = 0;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int n : nums) {
            if (!map.containsKey(n)) {
                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;
                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;
                // sum: length of the sequence n is in
                int sum = left + right + 1;
                map.put(n, sum);

                // keep track of the max length
                res = Math.max(res, sum);

                // extend the length to the boundary(s)
                // of the sequence
                // will do nothing if n has no neighbors
                map.put(n - left, sum);
                map.put(n + right, sum);
            }else {
                // duplicates
                continue;
            }
        }
        return res;
    }

    /**
 First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.

Then go through the numbers. If the number n is the start of a streak (i.e., n-1 is not in the set),
then test m = n+1, n+2, n+3, ... and stop at the first number m not in the set.
The length of the streak is then simply m-n and we update our global best with that.
Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ,
  one of the fastest Python submissions.
     */
    //2 HashSet
    public static int longestConsecutive1(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int n : nums) {
            set.add(n);
        }
        int best = 0;
        for(int n : set) {
            if(!set.contains(n - 1)) {  // only check for one direction
                int m = n + 1;
                while(set.contains(m)) {
                    m++;
                }
                best = Math.max(best, m - n);
            }
        }
        return best;
    }



    public static int longestConsecutive2(int[] nums) {
        int best=0;
        Set<Integer> set=new HashSet<Integer>();
        for(int i:nums){
            set.add(i);
        }
        for(int n:set){
            if(!set.contains(n-1)){
                int m=n+1;
                while(set.contains(m)){
                    m++;
                }
                best=Math.max(best, m-n);
            }
        }   
        return best;
    }


}

189. Rotate Array
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-30 下午4:57:58
 */

public class RotateArray {

    /**
     * @author lishuai
     * @data 2016-11-30 下午4:57:58
Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].

Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={1,2,3,4,5,6,7};
        rotate(a,3);
        System.out.println();
    }
    //1 思路 根据list的特点，首先把数组的元素都装入list，然后根据k，把list尾部的数字，头插到list的最前面并且删除尾部的数据
    public static void rotate(int[] nums, int k) {
        if(nums==null||nums.length<1){
            return;
        }
        k=k%nums.length;
        if(k==0) return;
        List<Integer> list=new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            list.add(nums[i]);
        }
        for(int i=0;i<k;i++){
            int t=list.get(list.size()-1);
            list.remove(list.size()-1);
            list.add(0, t);
        }
        for(int i=0;i<list.size();i++){
            nums[i]=list.get(i);
        }

    }

    //2 思路 用list做一个临时数据的保存单元，分段读取数组中的数据，读完所有的数据时，list中的数据即为结果，然后回写数组
     public static void rotate1(int[] nums, int k) {
           if(k%nums.length==0) return;
            if(nums.length==0||nums.length==1) return;

            //循环移位 
            if(k>nums.length) k=k%nums.length;
            List<Integer> list=new ArrayList<Integer>();
            for(int i=nums.length-k;i<nums.length;i++){
                list.add(nums[i]);
            }
            for(int j=0;j<nums.length-k;j++){
                list.add(nums[j]);
            }
            for(int i=0;i<nums.length;i++){
                nums[i]=list.get(i);
            }

        }

     /**
let a= [1,2,3,4,5,6,7]
k = 3.

we have to first reverse the whole array by swapping first element with the last one and so on..
you will get[7,6,5,4,3,2,1]

reverse the elements from 0 to k-1
reverse the elements 7,6,5
you will get [5,6,7,4,3,2,1]

reverse the elements from k to n-1
reverse the elements 4,3,2,1
you will get[5,6,7,1,2,3,4]
      */
     //3 思路：通过翻转实现（优解）
     public static void rotate2(int[] nums, int k) {
            k %= nums.length;
            reverse(nums, 0, nums.length - 1);
            reverse(nums, 0, k - 1);
            reverse(nums, k, nums.length - 1);
        }

    public static void reverse(int[] nums, int start, int end) {
            while (start < end) {
                int temp = nums[start];
                nums[start] = nums[end];
                nums[end] = temp;
                start++;
                end--;
            }
        }
}

153. Find Minimum in Rotated Sorted Array
此题的优解为：二分查找
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-1 上午10:54:42
 */

public class FindMinimuminRotatedSortedArray {

     /**
      * @author lishuai
      * @data 2016-12-1 上午10:54:42
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.
      */

     public static void main(String[] args) {
          // TODO Auto-generated method stub
          int[] a={7,8,9,1,2,3,4,5,6};
          System.out.println(findMin2(a));
     }
     //1 从左边找第一个变小的数即可，否则说明数组递增，返回最后一个元素的下标即可（考虑只有一个元素的特殊情况） 时间复杂度N
    public static int findMin(int[] nums) {
     for(int i=1;i<nums.length;i++){
            if(nums[i]<nums[i-1]){
                return nums[i];
            }
        }
        return nums[0];
    }
    //2 二分查找实现 (优解) 把起始和结尾元素加入判断的条件来实现是往前早还是向后找   logN
    public static int findMin2(int[] nums) {
        if (nums == null || nums.length == 0) {
             return 0;
         }
         if (nums.length == 1) {
             return nums[0];
         }
         int start = 0, end = nums.length - 1;
         while (start < end) {
             int mid = start+(end-start) / 2;
             if (mid > 0 && nums[mid] < nums[mid - 1]) {
                 return nums[mid];
             }
             if (nums[start] <= nums[mid] && nums[mid] > nums[end]) {
                 start = mid + 1;
             } else {
                 end = mid - 1;
             }
         }
         return nums[start];
     }

}


154. Find Minimum in Rotated Sorted Array 2
此题的优解为：二分查找
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-1 下午1:48:35
 */

public class FindMinimuminRotatedSortedArrayII {

    /**
     * @author lishuai
     * @data 2016-12-1 下午1:48:35
Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

The array may contain duplicates.
     */

    public static void main(String[] args) {
        int[] a={1,2,3};
        System.out.println(findMin1(a));

    }

    //1 从左边找第一个变小的数即可，否则说明数组递增，返回最后一个元素的下标即可（考虑只有一个元素的特殊情况） 时间复杂度N
    public static int findMin(int[] nums) {
        for(int i=1;i<nums.length;i++){
            if(nums[i]<nums[i-1]){
                return nums[i];
            }
        }       
        return nums[0];
    }
    //2 二分法 根据中间节点值和最后节点值定位  When num[mid] == num[hi], we couldn't sure the position of minimum in mid's left or right, so just let upper bound reduce one.
    public static int findMin1(int[] nums) {       
         int start = 0, end = nums.length - 1;
         while (start < end) {
             int mid = start+(end-start) / 2;
             if(nums[mid]>nums[end]){
                 start=mid+1;
             }else if(nums[mid]<nums[end]){
                 end=mid;
             }else{
                 end--;
             }
         }
         return nums[start];
     }
}


162. Find Peak Element

此题的优解为：二分查找（分别可用迭代和递归实现）
/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-12-1 上午10:17:42
 */

public class FindPeakElement {

    /**
     * @author lishuai
     * @data 2016-12-1 上午10:17:42
A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
int[] a={2,1};
System.out.println(findPeakElement(a));
    }
    //1 思路 由于num[-1] = num[n] = -∞，从左边找第一个变小的数即可，否则说明数组递增，返回最后一个元素的下标即可（考虑只有一个元素的特殊情况） 时间复杂度N
    public static int findPeakElement(int[] nums) {
        if(nums.length==1) return nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i]<nums[i-1]){
                return i-1;
            }
        }       
        return nums.length-1;
    }
    /**
This problem is similar to Local Minimum. And according to the given condition, num[i] != num[i+1],
there must exist a O(logN) solution. So we use binary search for this problem.

If num[i-1] < num[i] > num[i+1], then num[i] is peak
If num[i-1] < num[i] < num[i+1], then num[i+1...n-1] must contains a peak
If num[i-1] > num[i] > num[i+1], then num[0...i-1] must contains a peak
If num[i-1] > num[i] < num[i+1], then both sides have peak
(n is num.length)
     */
    //2 二分查找 时间复杂度 logN 迭代实现
    public static int findPeakElement1(int[] nums) {
        int lo = 0, hi = nums.length-1;
        while(lo < hi){
            if(lo +1== hi)
                return nums[lo] > nums[hi]? lo : hi;
            int mid = lo + (hi - lo)/2;
            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1])
                return mid;
            else if(nums[mid] > nums[mid-1] && nums[mid] < nums[mid+1])
                lo = mid+1;
            else
                hi = mid-1;
        }
        return lo;
    }

    //3 二分查找 时间复杂度 logN 递归实现
    public static int findPeakElement2(int[] nums) {
         return helper(nums,0,nums.length-1);
    }

    public static int helper(int[] num,int start,int end){
        if(start == end){
            return start;
        }else if(start+1 == end){
            if(num[start] > num[end]) return start;
            return end;
        }else{

            int m = (start+end)/2;

            if(num[m] > num[m-1] && num[m] > num[m+1]){

                return m;

            }else if(num[m-1] > num[m] && num[m] > num[m+1]){

                return helper(num,start,m-1);

            }else{

                return helper(num,m+1,end);

            }

        }
    }
    /**
    Consider that each local maximum is one valid peak.
My solution is to find one local maximum with binary search.
Binary search satisfies the O(logn) computational complexity.
     */
    //4 思路与2一样
    public static int findPeakElement3(int[] nums) {
        int low = 0;
        int high = nums.length-1;

        while(low < high)
        {
            int mid1 = (low+high)/2;
            int mid2 = mid1+1;
            if(nums[mid1] < nums[mid2])
                low = mid2;
            else
                high = mid1;
        }
        return low;
    }
}



167. Two Sum II - Input array is sorted

/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-1 上午8:31:37
 */

public class TwoSumIIInputarrayissorted {

    /**
     * @author lishuai
     * @data 2016-12-1 上午8:31:37
Given an array of integers that is already sorted in ascending order,
find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target,
where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={ 2,3,4};

        System.out.println(twoSum3(a,6));
    }
    //1 滑动窗口 连个指针   时间复杂度n
     public static int[] twoSum(int[] numbers, int target) {         
        int[] indice = new int[2];
        if (numbers == null || numbers.length < 2) return indice;
        int left = 0, right = numbers.length - 1;
        while (left < right) {
            int v = numbers[left] + numbers[right];
            if (v == target) {
                indice[0] = left + 1;
                indice[1] = right + 1;
                break;
            } else if (v > target) {
                right --;
            } else {
                left ++;
            }
        }
        return indice;

     }
     //2 二叉搜索  binary search   时间复杂度n*logN
     public static int[] twoSum3(int[] numbers, int target) {
         int[] res=new int[2];
            for(int i=0; i<numbers.length-1; i++) {
                int start=i+1, end=numbers.length-1, gap=target-numbers[i];
                while(start <= end) {
                    int m = start+(end-start)/2;
                    if(numbers[m] == gap) {                       
                        res[0]=i+1;
                        res[1]=m+1;   
                        return res;
                    }else if(numbers[m] > gap) end=m-1;
                    else start=m+1;
                }
            }
            return res;

     }

    //3 Time Limit Exceeded
     public static int[] twoSum2(int[] numbers, int target) {
        int[] res=new int[2];
        //找到第一个大于目标值得位置
        int index=numbers.length;
        for(int i=0;i<numbers.length;i++){
            if(numbers[i]>target){
                index=i;
            }           
        }

        for(int i=0;i<index-1;i++){
            for(int j=i+1;j<index;j++){
                if(numbers[i]+numbers[j]==target){
                    res[0]=i+1;
                    res[1]=j+1;
                }

            }
        }
        return res;
     }

    //4 回溯法 Time Limit Exceeded
    public static int[] twoSum1(int[] numbers, int target) {
        int index=numbers.length;
        for(int i=0;i<numbers.length;i++){
            if(numbers[i]>target){
                index=i;
            }           
        }

        int[] res=new int[2];
        if(target==0) {
            res[0]=1;
            res[1]=2;
            return res;
        }
        backtracking(res,new ArrayList<Integer>(), numbers, target, 0,2,index);       
        return res;
    }

    public static void backtracking(int[] res,List<Integer> list,int[] numbers,int target ,int start,int k,int index){
        if(k==0&&target==0){
            res[0]=list.get(0);
            res[1]=list.get(1);
            return ;
        }
        for(int i=start;i<index&&target>0&&k>0;i++){
            list.add(i+1);
            backtracking(res,list, numbers, target-numbers[i], i+1, k-1,index);
            list.remove(list.size()-1);
        }
    }
}



169. Majority Element
优解：摩尔投票法
位操作提供一种新的思路
public static int majority(int[] a){
    int majority = -1;
    int times = 0;
    for (int i = 0;i<a.length;i++) {
        if (times == 0) {
            majority = a[i];
        } else {
            if (majority == a[i]) {
                times++;
            }else{
                times--;
            }
        }
    }

    return majority;
}


/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * @author lishuai
 * @data 2016-11-30 下午5:41:40
 */

public class MajorityElement {

    /**
     * @author lishuai
     * @data 2016-11-30 下午5:41:40
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.
     */

    public static void main(String[] args) {
        int[] a = {1,1,1,1,2,3};
        majorityElement3(a);

    }
    //1 思路：先对数组排序，返回排序好的数字中间位置对应的值即可
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }

    //九章
    public int majorityNumber11(ArrayList<Integer> nums) {
        int count = 0, candidate = -1;
        for (int i = 0; i < nums.size(); i++) {
            if (count == 0) {
                candidate = nums.get(i);
                count = 1;
            } else if (candidate == nums.get(i)) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
    //2思路 摩尔投票法算法    选取大多数
    public int majorityElement1(int[] nums) {
        int count=0;
        int majority=nums[0];       
        for(int i=1;i<nums.length;i++){
            if(nums[i]==majority){
                count++;
            }else if(count==0){
                majority=nums[i];
            }else{
                count--;
            }
        }       
        return majority;
    }   
    //3 使用map统计出现的次数
    public int majorityElement2(int[] nums) {
           if(nums.length==1){
               return nums[0];
        }else{
             int back=0;
             Map<Integer, Integer> m1=new HashMap<Integer, Integer>();
             for(int i=0;i<nums.length;i++){
                 if(m1.containsKey(nums[i])){
                     Integer v=m1.get(nums[i]);
                     m1.put(nums[i], v+1);

                 }else{
                     m1.put(nums[i], 1);
                 }   

                 if(m1.get(nums[i])>nums.length/2){
                     back=nums[i];
                     break;
                 }

             }

            return back;
        }
    }

    //4 Bit manipulation （原理？？？）把数组所有元素的二进制表示统计累计32位的每一位；然后遍历位数组，要是对应的为1的各个大于数组的一半这说明是要求数字的一部分，然后拼接
    public static int majorityElement3(int[] nums) {
        int[] bit = new int[32];
        for (int num: nums)
            for (int i=0; i<32; i++)
                if ((num>>(31-i) & 1) == 1)
                    bit[i]++;
        int ret=0;
        for (int i=0; i<32; i++) {
            bit[i]=bit[i]>nums.length/2?1:0;
            ret += bit[i]*(1<<(31-i));
        }
        return ret;
    }
    //5 统计32中的每一位，在数组中是1对应的个数大还是0对应的个数大，然后拼接
    public static int majorityElement5(int[] num) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            int ones = 0, zeros = 0;
            for (int j = 0; j < num.length; j++) {
                if ((num[j] & (1 << i)) != 0) {
                    ++ones;
                } else {
                     ++zeros;
                }                   
            }
            if (ones > zeros)
                ret |= (1 << i);
        }

        return ret;
    }
}

229. Majority Element II
未完

/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author lishuai
 * @data 2016-11-29 下午5:04:47
 */

public class MajorityElementII {

    /**
     * @author lishuai
     * @data 2016-11-29 下午5:04:47
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
The algorithm should run in linear time and in O(1) space
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={1,2,3,3,2,2,3};
        System.out.println(majorityElement(a).toString());
    }
    //1 list中最多有两个元素，有可能没有   摩尔投票算法:先选出数组中出现次数较多的元素，然后再统计具体的出现次数
    public static List<Integer> majorityElement(int[] nums) {
        if (nums == null || nums.length == 0)
            return new ArrayList<Integer>();
        List<Integer> result = new ArrayList<Integer>();
        int number1 = nums[0], number2 = nums[0], count1 = 0, count2 = 0, len = nums.length;
        for (int i = 0; i < len; i++) {
            if (nums[i] == number1)
                count1++;
            else if (nums[i] == number2)
                count2++;
            else if (count1 == 0) {
                number1 = nums[i];
                count1 = 1;
            } else if (count2 == 0) {
                number2 = nums[i];
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }
        count1 = 0;
        count2 = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == number1)
                count1++;
            else if (nums[i] == number2)
                count2++;
        }
        if (count1 > len / 3)
            result.add(number1);
        if (count2 > len / 3)
            result.add(number2);
        return result;
    }

    /**
     *
    It is taking O(k) space actually for n/k case.
    Since k would be a constant number in a given problem like when k = 2 or k = 3,
    it is safe to say the solution is O(1) space.
     */
    //2 原理一样还是 摩尔投票算法
    public static List<Integer> majorityElement1(int[] nums) {
          return helper(nums, 3);
    }


    public static List<Integer> helper(int[] nums, int k) {
        List<Integer> ret = new ArrayList<>();
        Map<Integer, Integer> map = new HashMap<>();
        if (nums.length == 0) return ret;
        for (int n : nums) {
            if (map.containsKey(n)) map.put(n, map.get(n) + 1);
            else if (map.keySet().size() < k - 1) map.put(n, 1);
            else {
                    boolean flag = false;
                    for (Integer i : map.keySet()) {
                        if (map.get(i) == 0) {
                            map.remove(i);
                            map.put(n, 1);
                            flag = true;
                            break;
                        }
                    }
                    if (flag == false) {
                        for (Integer i : map.keySet()) {
                            map.put(i, map.get(i) - 1);
                        }
                    }
                 }
        }
        for (Integer i : map.keySet()) {
            map.put(i, 0);
        }
        for (int n : nums) {
           if (map.containsKey(n)) map.put(n, map.get(n) + 1);
        }
        for (Integer i : map.keySet()) {
            if (map.get(i) > nums.length / k) ret.add(i);
        }
        return ret;
    }
//3 其实还有两种方案：1先排序，然后计算（缺点时间复杂度不满足题设）；2使用map统计（空间复杂度不满足题设），因此只能用摩尔投票算法
   
    public static List<Integer> majorityElement2(int[] nums) {
        List<Integer> list=new ArrayList<Integer>();



        return list;
    }

}

209. Minimum Size Subarray Sum

/**
 *
 */
package array;

import java.util.Arrays;

/**
 * @author lishuai
 * @data 2016-11-30 下午3:29:31
 */

public class MinimumSizeSubarraySum {

    /**
     * @author lishuai
     * @data 2016-11-30 下午3:29:31
Given an array of n positive integers and a positive integer s,
find the minimal length of a subarray of which the sum ≥ s.
If there isn't one, return 0 instead.

For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={2,3,1,2,4,3};
        System.out.println(minSubArrayLen2(7,a));
    }

    //1、Java O(n) solution (two pointers) 类似于滑动窗口
    public static int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;

          int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;

          while (j < nums.length) {
            sum += nums[j++];

            while (sum >= s) {
              min = Math.min(min, j - i);
              sum -= nums[i++];
            }
          }

          return min == Integer.MAX_VALUE ? 0 : min;
    }
/**
 We will maintain a window that grows until sum reach the given sum.
 Once the window grows to sum at least s then
 we can start shirking the window from left with the hope to find a smaller window.
  We shrink until sum falls below s. Then we can grow the window on right again and so on.
  We keep this procedure of growing-shrinking until the window start reaches the end of the array.
  Below is the implementation of the above idea which runs in O(n) time and O(1) space.
 */
    //2 和1的原理一样(觉得这个比较好理解) 滑动窗口
    public static int minSubArrayLen1(int sum, int[] nums) {
        int minlen = Integer.MAX_VALUE;
        int curSum = 0;
        int start = 0;
        int end = 0;

        while(start < nums.length){
            //if current window doesn't add up to the given sum then
            //strech the window to right
            if(curSum < sum && end < nums.length){
                curSum += nums[end];
                end++;
            }
            //if current window adds up to at least given sum then
            //we can shrink the window
            else if(curSum >= sum){
                minlen = Math.min(minlen, end-start);
                curSum -= nums[start];
                start++;
            }
            //cur sum less than required sum but we reach the end
            else{
                break;
            }
        }

        return (minlen == Integer.MAX_VALUE) ? 0 : minlen;
    }
    //3 暂时没明白
    public static int minSubArrayLen2(int s, int[] nums) {
        int i = 1, j = nums.length, min = 0;
        while (i <= j) {
            int mid = (i + j) / 2;
            if (windowExist(mid, nums, s)) {
                j = mid - 1;
                min = mid;
            } else i = mid + 1;
        }
        return min;
    }


    private static boolean windowExist(int size, int[] nums, int s) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i >= size)
                sum -= nums[i - size];
            sum += nums[i];
            if (sum >= s) return true;
        }
        return false;
    }

    //4 暂时没明白
    public static int minSubArrayLen3(int s, int[] nums) {
        int sum = 0, min = Integer.MAX_VALUE;

        int[] sums = new int[nums.length];
        for (int i = 0; i < nums.length; i++)
            sums[i] = nums[i] + (i == 0 ? 0 : sums[i - 1]);

        for (int i = 0; i < nums.length; i++) {
            int j = findWindowEnd(i, sums, s);
            if (j == nums.length) break;
            min = Math.min(j - i + 1, min);
        }

        return min == Integer.MAX_VALUE ? 0 : min;
    }

    private static int findWindowEnd(int start, int[] sums, int s) {
        int i = start, j = sums.length - 1, offset = start == 0 ? 0 : sums[start - 1];
        while (i <= j) {
            int m = (i + j) / 2;
            int sum = sums[m] - offset;
        if (sum >= s) j = m - 1;
        else i = m + 1;
    }
    return i;
}

}



238. Product of Array Except Self

/**
 *
 */
package array;

/**
 * @author lishuai
 * @data 2016-11-29 下午3:52:21
 */

public class ProductofArrayExceptSelf {

    /**
     * @author lishuai
     * @data 2016-11-29 下午3:52:21
238. Product of Array Except Self


Given an array of n integers where n > 1, nums,
return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

Follow up:
Could you solve it with constant space complexity?
(Note: The output array does not count as extra space for the purpose of space complexity analysis.)



     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        int[] a={1,2,3,4};
        productExceptSelf(a);
    }
    /**

Given numbers [2, 3, 4, 5], regarding the third number 4,
the product of array except 4 is 2*3*5 which consists of two parts:
left 2*3 and right 5. The product is left*right. We can get lefts and rights:

Numbers:     2    3    4     5
Lefts:            2  2*3 2*3*4
Rights:  3*4*5  4*5    5     
Let’s fill the empty with 1:

Numbers:     2    3    4     5
Lefts:       1    2  2*3 2*3*4
Rights:  3*4*5  4*5    5     1
We can calculate lefts and rights in 2 loops. The time complexity is O(n).

We store lefts in result array.
If we allocate a new array for rights. The space complexity is O(n).
To make it O(1), we just need to store it in a variable which is right 
     */


//0 思路是把乘机分成左右两个部分   
    public static int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] res=new int[n];
        int left=1;
        for(int i=0;i<n;i++){
            if(i>0) left*=nums[i-1];
            res[i]=left;
        }
        int right=1;
        for(int j=n-1;j>=0;n--){
            if(j<n-1) right*=nums[j+1];
            res[j]*=right;
        }

        return res;

    }
    //1 首先考虑有几个0的问题，然后在数组没有0的情况下，先求所有元素的乘集，然后遍历时除掉本身即可
    public static int[] productExceptSelf1(int[] nums) {
        //考虑有几个零的问题
        int[] back=new int[nums.length];
        int indexZero=0;
        int zeroCount=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0){
                indexZero=i;
                zeroCount++;
            }
        }
        if(zeroCount>1){
            //所有都为零
            for(int i=0;i<nums.length;i++){
                back[i]=0;
            }
        }else if(zeroCount==1){
            //只有一个不为零
            int sum=1;
            for(int i=0;i<nums.length;i++){
                if(i!=indexZero){
                    sum*=nums[i];
                }
            }
            for(int i=0;i<nums.length;i++){
                if(i!=indexZero){
                    back[i]=0;
                }else{
                    back[i]=sum;
                }
            }
        }else{
            //没有零元素
            int sum=1;
            for(int i=0;i<nums.length;i++){               
                    sum*=nums[i];
            }
            for(int i=0;i<nums.length;i++){ 
                back[i]=sum/nums[i];
            }
        }

        return back;
    }
    //2 超时不满足时间复杂度
    public static int[] productExceptSelf2(int[] nums) {
        int[] back=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            int temp=1;
            for(int j=0;j<nums.length;j++){
                if(i!=j){
                    temp*=nums[j];
                }
            }
            back[i]=temp;
        }   
        return back;
    }
    //3 和0的思路一样，不一样的写法
    public static int[] productExceptSelf3(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] *= right;
            right *= nums[i];
        }
        return res;

    }

}


268. Missing Number
优解：使用异或操作
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author lishuai
 * @data 2016-11-29 下午1:57:55
 */

public class MissingNumber {

    /**
     * @author lishuai
     * @data 2016-11-29 下午1:57:55
268. Missing Number
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,
find the one that is missing from the array.

For example,
Given nums = [0, 1, 3] return 2.

Note:
Your algorithm should run in linear runtime complexity.
 Could you implement it using only constant extra space complexity?
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a={3, 1, 0};
        System.out.println(missingNumber(a));

        System.out.println();


    }


    //1 思路，用一个map保存出现过的元素 用map保存元素
    public static int missingNumber(int[] nums) {
       Map<Integer, Integer> map=new HashMap<Integer, Integer>();
       for(int i=0;i<nums.length;i++){
           if(!map.containsKey(nums[i])){
               map.put(nums[i], 1);
           }
       }
        for(int j=0;j<nums.length;j++){
            if(!map.containsKey(j)){
                return j;
            }
        }   
        return nums.length;
    }
    //2 思路和1一样 用list保存元素
    public static int missingNumber1(int[] nums) {
        List<Integer> list=new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            if(!list.contains(nums[i])){
                list.add(nums[i]);
            }
        }
         for(int j=0;j<nums.length;j++){
             if(!list.contains(j)){
                 return j;
             }
         }   
         return nums.length;
     }

    //3 异或运算 （按位操作）   a^a^b=b       0^x=x 零异或任何数为那个数本身  1ms
    public static int missingNumber2(int[] nums) {
        int xor = 0, i = 0;
        for (i = 0; i < nums.length; i++) {
            xor = xor ^ i ^ nums[i];
        }

        return xor ^ i;
    }
    //4  since the n numbers are from [0, n], we can just add all the numbers from [0, n] together and minus the sum of the n-1 numbers in array.
    //数组较大时有可能溢出   1ms
    public static int missingNumber3(int[] nums) {       
        int sum=nums.length;
        for(int i=0;i<nums.length;i++ ){
            sum=sum+i-nums[i];
        }
        return sum;
    }
    //5 BitSet的使用      4ms
    /**
    BitSet 类创建一个特殊类型的数组保存位值。该BitSet中数组的大小可以根据需要增加。这使得它类似于比特的向量。
    BitSet(int size) 所有位初始化为零。
    void set(int index)设置由index指定的位。
    int nextClearBit(int startIndex)返回下个清零位的索引，（即，下一个零位），从由startIndex指定的索引开始
     */
    public static int missingNumber4(int[] nums) {
         BitSet bitSet = new BitSet(nums.length);
         for (int i = 0; i < nums.length; i++) {
            bitSet.set(nums[i]);
         }

         return bitSet.nextClearBit(0);
    }
}


283. Move Zeroes

/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-29 下午1:39:14
 */

public class MoveZeroes {

    /**
     * @author lishuai
     * @data 2016-11-29 下午1:39:14
     * @param args
题：283
Given an array nums, write a function to move all 0's to the end of it
while maintaining the relative order of the non-zero elements.

For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[]  nums = {0, 1, 0, 3, 12};
        moveZeroes(nums);
    }
    //1 思路 把不为零的元素保存在一个list中，然后回写原数组
    public static void moveZeroes(int[] nums) {
       List<Integer> list=new ArrayList<Integer>();
       for(int i=0;i<nums.length;i++){
           if(nums[i]!=0){
               list.add(nums[i]);
           }
       }
       for(int j=0;j<nums.length;j++){
           if(j<list.size()){
               nums[j]=list.get(j);
           }else{
               nums[j]=0;
           }
       }

    }

    //2 思路 把不为零的元素前移并且统计有多少个不为零的元素，其余的赋值为0
    public static void moveZeroes1(int[] nums) {
          int j=0;
          for(int i=0;i<nums.length;i++){
              if(nums[i]!=0){
                  nums[j]=nums[i];
                  j++;
              }
          }
          for(int k=j;k<nums.length;k++){
              nums[k]=0;
          }

    }
}


414 ThirdMaximumNumber


/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-28 下午3:20:35
Given a non-empty array of integers, return the third maximum number in this array.
If it does not exist, return the maximum number. The time complexity must be in O(n).

Example 1:
Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.
Example 2:
Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
Example 3:
Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
 */

public class ThirdMaximumNumber {

    /**
     * @author lishuai
     * @data 2016-11-28 下午3:20:35
     * @param args
     */

    public static void main(String[] args) {
        int[] a={1,-2147483648,2};
        Integer x=null;
        System.out.println(x>1);
        //thirdMax(a);
    }

    //1自己   思路：去除重复项，先排序前三个，之后遍历和前三个比较，其实就是查询前三个大数（有个问题是，要是求第n大，没法处理了？）
    public static int thirdMax(int[] nums) {
        if(nums.length==1) return nums[0];
        if(nums.length==2) return nums[0]>nums[1]?nums[0]:nums[1];
        //去除重复
        List<Integer> list=new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            if(!list.contains(nums[i])){
                list.add(nums[i]);
            }
        }
        if(list.size()==1) return list.get(0);
        if(list.size()==2) return list.get(0)>list.get(1)?list.get(0):list.get(1);

        //走到这里则有第三大数   先处理前三个数 排序
        int first=0;
        int second=0;

        if(list.get(0)>list.get(1)){
            first=list.get(0);
            second=list.get(1);
        }else{
            first=list.get(1);
            second=list.get(0);
        }


        int third=list.get(2);
        if(third>first){
            int t=first;
            first=third;
            third=t;

            int t1=second;
            second=third;
            third=t1;
        }else if(third>second){
            int t1=second;
            second=third;
            third=t1;
        }
        if(list.size()>3){
            for(int i=3;i<list.size();i++){
                if(list.get(i)>first){                   
                    third=second;
                    second=first;
                    first=list.get(i);

                }else if(list.get(i)>second){
                    int t=second;
                    second=list.get(i);
                    third=t;
                }else if(list.get(i)>third){
                    third=list.get(i);
                }
            }
        }


        System.out.println(third);
        return third;
    }

    //2 思路类似，这样简化代码
    public static int thirdMax1(int[] nums) {

         Integer max1 = null;
         Integer max2 = null;
         Integer max3 = null;
         for (Integer n : nums) {
             if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue;
             if (max1 == null || n > max1) {
                 max3 = max2;
                 max2 = max1;
                 max1 = n;
             } else if (max2 == null || n > max2) {
                 max3 = max2;
                 max2 = n;
             } else if (max3 == null || n > max3) {
                 max3 = n;
             }
         }
         return max3 == null ? max1 : max3;
    }


}
448 FindAllNumbersDisappearedinanArray
两个for循环O（2n）
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-28 上午9:32:47
 */

public class FindAllNumbersDisappearedinanArray {

    /**
     * @author lishuai
     * @data 2016-11-28 上午9:32:47
     * @param args
     * Input:
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array),
some elements appear twice and others appear once.

Find all the elements of [1, n] inclusive that do not appear in this array.

Could you do it without extra space and in O(n) runtime?
You may assume the returned list does not count as extra space.

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a={4,3,2,7,8,2,3,1};
        findDisappearedNumbers(a);
    }
    //1 （标记）思路：由于数组中是1~n的数字，可以将数组中的数字转化为数组的下标， 标记出现过的为负数 ，遍历数组为正数的下标即为结果
    public static List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ret = new ArrayList<Integer>();

        for(int i = 0; i < nums.length; i++) {
            int val = Math.abs(nums[i]) - 1;
            if(nums[val] > 0) {
                nums[val] = -nums[val];
            }
        }

        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > 0) {
                ret.add(i+1);
            }else{
                //这一句也可不要，恢复原数组的数据
                nums[i]=-nums[i];
            }
        }
        return ret;

    }

    //2（标记）与1类似，只不过通过加一个数N来实现
    public static List<Integer> findDisappearedNumbers2(int[] nums) {

        List<Integer> res = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < nums.length; i ++)
                nums[(nums[i]-1) % n] += n;
        for (int i = 0; i < nums.length; i ++)
                if (nums[i] <= n) res.add(i+1);
        return res;

   }





    //3、自己的
    public static List<Integer> findDisappearedNumbers1(int[] nums) {

        List<Integer> list =new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            if(!list.contains(nums[i])){
                list.add(nums[i]);
            }
        }
        for(int j=0;j<list.size();j++){
            nums[list.get(j)-1]=list.get(j);
        }

        int m=0;
        for(int k=0;k<nums.length;k++){
            if(nums[k]!=k+1){
                list.add(m, k+1);
                m++;
            }
        }
        return list.subList(0, m);

    }

}





数组的元素在1-n之间包含n+1个整数


二分法

复杂度

时间 O(NlogN) 空间 O(1)

思路

实际上，我们可以根据抽屉原理简化刚才的暴力法。我们不一定要依次选择数，然后看是否有这个数的重复数，我们可以用二分法先选取n/2，按照抽屉原理，整个数组中如果小于等于n/2的数的数量大于n/2，说明1到n/2这个区间是肯定有重复数字的。比如6个抽屉，如果有7个袜子要放到抽屉里，那肯定有一个抽屉至少两个袜子。这里抽屉就是1到n/2的每一个数，而袜子就是整个数组中小于等于n/2的那些数。这样我们就能知道下次选择的数的范围，如果1到n/2区间内肯定有重复数字，则下次在1到n/2范围内找，否则在n/2到n范围内找。下次找的时候，还是找一半。

注意

- 我们比较的mid而不是nums[mid]
- 因为mid是下标，所以判断式应为cnt > mid，最后返回min

代码

public class Solution {
    public int findDuplicate(int[] nums) {
        int min = 0, max = nums.length - 1;
        while(min <= max){
            // 找到中间那个数
            int mid = min + (max - min) / 2;
            int cnt = 0;
            // 计算总数组中有多少个数小于等于中间数
            for(int i = 0; i < nums.length; i++){
                if(nums[i] <= mid){
                    cnt++;
                }
            }
            // 如果小于等于中间数的数量大于中间数，说明前半部分必有重复
            if(cnt > mid){
                max = mid - 1;
            // 否则后半部分必有重复
            } else {
                min = mid + 1;
            }
        }
        return min;
    }
}

映射找环法

复杂度

时间 O(N) 空间 O(1)

思路

假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。比如数组是213,则映射关系为0->2, 1->1, 2->3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。比如在这个例子中有两个下标的序列，0->2->3。

但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0->2, {1，3}->1, 2->3。这样，我们推演的序列就一定会有环路了，这里下标的序列是0->2->3->1->1->1->1->...，而环的起点就是重复的数。

所以该题实际上就是找环路起点的题，和Linked List Cycle II一样。我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。这时候保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。对这个找环起点算法不懂的，请参考Floyd's Algorithm。

注意

第一次找快慢指针相遇用do-while循环

代码

public class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        // 找到快慢指针相遇的地方
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);
        int find = 0;
        // 用一个新指针从头开始，直到和慢指针相遇
        while(find != slow){
            slow = nums[slow];
            find = nums[find];
        }
        return find;
    }
}


连续子数组求和

给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大。输出答案时，请分别返回第一个数字和最后一个数字的下标。（如果两个相同的答案，请返回其中任意一个）

原理：借助动态规划

样例
给定 [-3, 1, 3, -3, 4], 返回[1,4].

public List<Integer> continuousSubarraySum(int[] A) {
        // write your code here
        List<Integer> res = new ArrayList<Integer>();
        if (A == null || A.length == 0) {
            res.add(-1);
            res.add(-1);
            return res;
        }
        if (A.length == 1) {
            res.add(0);
            res.add(0);
            return res;
        }
        int[] dp = new int[A.length];
        dp[0] = A[0];
        int max = A[0];
        int index = 0;
        for (int i = 1;i < A.length;i++) {
            dp[i] = Math.max(dp[i-1]+A[i],A[i]);
            if (max < dp[i]) {
                max = dp[i];
                index = i;
            }
        }
        int j=index;
        while (j >= 0 ) {
            if (max == 0) {
                break;
            }
            max-=A[j];
            j--;
        }
        res.add(j+1);
        res.add(index);
        return res;
    }




你给出一个整数数组(size为n)，其具有以下特点：
- 相邻位置的数字是不同的
- A[0] < A[1] 并且 A[n - 2] > A[n - 1]
假定P是峰值的位置则满足A[P] > A[P-1]且A[P] > A[P+1]，返回数组中任意一个峰值的位置。

 注意事项
- It's guaranteed the array has at least one peak.
- The array may contain multiple peeks, find any of them.
- The array has at least 3 numbers in it.

您在真实的面试中是否遇到过这个题？

Yes

样例
给出数组[1, 2, 1, 3, 4, 5, 7, 6]返回1, 即数值 2 所在位置, 或者6, 即数值 7 所在位置.

原理：维持原理数组的关系，二分处理

public int findPeak(int[] A) {
        // write your code here
        int left = 0;
        int right = A.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (A[mid-1] < A[mid] && A[mid] > A[mid+1]) {
                return mid;
            }
            if (A[mid-1] > A[mid] ) {
                right = mid;
            } else if (A[mid+1] > A[mid])  {
                left = mid;
            }
        }
        return -1;
    }



最小差

给定两个整数数组（第一个是数组 A，第二个是数组 B），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。

您在真实的面试中是否遇到过这个题？

Yes

样例
给定数组 A = [3,4,6,7]， B = [2,3,8,9]，返回 0。


public int smallestDifference(int[] A, int[] B) {
        // write your code here
        Arrays.sort(A);
        Arrays.sort(B);
        int res = Integer.MAX_VALUE;
        int i = 0;
        int j = 0;
        if (A[A.length-1] < B[0]) {
            return B[0] - A[A.length-1];
        } else if (B[B.length-1] < A[0]) {
            return A[0] - B[B.length-1];
        }
        while (i < A.length&& j < B.length) {
            if (A[i] < B[j]) {
                res = Math.min(B[j] - A[i],res);
                i++;
            } else if (A[i] > B[j]) {
                res =Math.min( A[i] - B[j],res);
                j++;
            } else {
                return 0;
            }
        }

        return res;
    }

搜索区间


给定一个包含 n 个整数的排序数组，找出给定目标值 target 的起始和结束位置。
如果目标值不在数组中，则返回[-1, -1]

您在真实的面试中是否遇到过这个题？

Yes

样例
给出[5, 7, 7, 8, 8, 10]和目标值target=8,
返回[3, 4]

public int[] searchRange(int[] A, int target) {
        // write your code here
        int[] res = new int[2];
        res[0] = -1;
        res[1] = -1;
        if (A == null || A.length == 0) {
            return res;
        }
        int left = 0;
        int right = A.length - 1;
        int mid;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (A[mid] == target) {
                int start = mid - 1;
                int end = mid + 1;
                while (start >= 0 && A[start] == target) {
                    start--;
                }
                while (end < A.length && A[end] == target) {
                    end++;
                }
                res[0] = start + 1;
                res[1] = end - 1;
                return res;
            } else if (A[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return res;
    }

```
# 数组中的数字出现次数不同问题

```java


分两种题型：
1、结果只有一个数字的
2、结果有两个数字




通过这种思路，我们可以求出任何这种类型的题目。

- 如果一个数组中，每个数字都出现偶数次，只有一个数字出现一次，利用异或即可

- 如果一个数组中，每个数字都出现奇数(大于1)次，只有一个数字出现一次，那么就用一个32位的数组，记录所有位中为1的个数，最后数组中每一个数字对这个奇数取余，不为0的，把它取出，按它的位数，转化成十进制的数字。





	* 1 ⊕ 0 = 1
	* 0 ⊕ 1 = 1
	* 1 ⊕ 1 = 0
	* 0 ⊕ 0 = 0

1、思路：直接亦或操作整个数组结果就是要找的数字
一个整形数组中，每个数字都出现两次，只有一个数字出现一次，找出这个数字。

- public int singleNumber(int[] A) { //待求数组A
- int temp = 0;
- for(int i = 0 ; i < A.length; i++){
- temp ^= A[i]; //异或运算
- }
- return temp;
- }
2、
一个数组只有一个数字是单独出现，其他出现了三次


这个问题显然不能再用异或求解了，因为三个数字异或之后不能消除。 或许可以采用暴力解法，即建一个Map，key是出现的数字，value是这个数字出现的次数。最后能得到出现一次的数字，但显然这种解法空间复杂度很高，如果数组很大，那么显然在HashMap中put get 的时候，时间复杂度也会很大。应该不考虑这种暴力式算法。

考虑到整形数字在电脑中存储的时候是四个byte，即32位bit，每一个数字都可以表示成一个32位的0 1 串，那么如果用一个32位的数组，记录数组中所有数字，每一位1出现的次数。然后每一位对3取余，数组中不为0的地方就是那一个只出现一次的数字的二进制中1的位置。

例如4出现3次。 4的二进制是 0000 0000 0000 0000 0000 0000 0000 0100 4出现三次的话，

统计的数组就把 数组中的第三位记为3，

即 数组为 0000 0000 0000 0000 0000 0000 0000 0300

所有位对3取余，结果一定全为0。


- public static int singleNumber(int[] A) {
- int bits[] = new int[32]; //定义一个32位数组
- for (int i = 0; i < bits.length; i++) {
- bits[i]=0; //初始化 数组中所有值为0
- }
- for (int i = 0; i < A.length; i++) { //对数组中每一个数字
- for (int j = 0; j < bits.length; j++) { //这个数字的每一位
- bits[j] += ((A[i] >> j) & 1); //记录这个位上是否为1，为1的话 bits数组就加1
- }
- }
- int result = 0 ;
- for (int j = 0; j < 32; j++)
- if (bits[j] % 3 != 0) //对3取余，是3的倍数的取余后都为0，剩下的就是我们要的
- result += (1 << j); //把记录的二进制他转化成整形数字
- return result;
- }
3、

题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次，请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。

举例说明

例如输入数组｛2, 4, 3, 6, 3, 2, 5 }，因为只有 4 、6 这两个数字只出现一次，其他数字都出现了两次，所以输出 4 和 6 。


解题思路（把数组分成两段，每一段包含一个只出现一次的数字） 

这两个题目都在强调一个（或两个）数字只出现一次，其他的出现两次。这有什么意义呢？我们想到异或运算的一个性质：任何一个数字异或它自己都等于 0。也就是说， 如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了。

想明白怎么解决这个简单问题之后，我们再回到原始的问题，看看能不能运用相同的思路。我们试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果能够这样拆分成两个数组， 我们就可以按照前面的办法分别找出两个只出现一次的数字了。

我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为 0，也就是说在这个结果数字的二进制表示中至少就有一位为 1 。我们在结果数字中找到第一个为 1 的位的位置，记为第 n 位。现在我们以第 n 位是不是 １ 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 n 位都是 1，而第二个子数组中每个数字的第 n 位都是 0。由于我们分组的标准是数字中的某一位是 1 还是 0 ， 那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次数字， 因此到此为止所有的问题都已经解决了。



public class Test40 {
    public static int[] findNumbersAppearanceOnce(int[] data) {
        int[] result = {0, 0};//存放结果
        if (data == null || data.length < 2) {
            return result;
        }
        int xor = 0;
        for (int i : data) {
            xor ^= i;
        }
        int indexOf1 = findFirstBit1(xor);
        for (int i : data) {
            if (isBit1(i, indexOf1)) {
                result[0] ^= i;
            } else {
                result[1] ^= i;
            }
        }
        return result;
    }
    private static int findFirstBit1(int num) {//找最低位是1的位置
        int index = 0;
        while ((num & 1) == 0 && index < 32) {
            num >>>= 1;
            index++;
        }
        return index;
    }
    private static boolean isBit1(int num, int indexBit) {//判断一个数的某一位是不是1
        num >>>= indexBit;
        return (num & 1) == 1;
    }
    public static void main(String[] args) {
        int[] data1 = {2, 4, 3, 6, 3, 2, 5, 5};
        int[] result1 = findNumbersAppearanceOnce(data1);
        System.out.println(result1[0] + " " + result1[1]);
        int[] data2 = {4, 6};
        int[] result2 = findNumbersAppearanceOnce(data2);
        System.out.println(result2[0] + " " + result2[1]);
        int[] data3 = {4, 6, 1, 1, 1, 1};
        int[] result3 = findNumbersAppearanceOnce(data3);
        System.out.println(result3[0] + " " + result3[1]);
    }
}


4、给定一个整数数组，里面有两个数相同，其他数都是不同的，如何尽快找到这两个数（还有没有其他的方法）
public static int find(int[] a) {
        Set<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < a.length;i++) {
            if (!set.add(a[i])) {
                return a[i];
            }
        }
        return -1;
    }

```


# 数组中找重复数字
```java



217. Contains Duplicate
总结：要是不允许使用额外的空间的话先排序NlogN
可以使用额外的空间的话，使用set或者map

/**
 *
 */
package array;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * @author lishuai
 * @data 2016-11-30 上午10:34:26
 */

public class ContainsDuplicate {

     /**
      * @author lishuai
      * @data 2016-11-30 上午10:34:26
Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array,
and it should return false if every element is distinct.
      */

     public static void main(String[] args) {
          // TODO Auto-generated method stub
          System.out.println(2>>1);

     }
     //1思路   用map统计，没有重复时，加入map已经存在则退出，返回结果（用list也行） 时间复杂度为n,空间复杂度n
    public static  boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> m1=new HashMap<Integer, Integer>();
           for(int i=0;i<nums.length;i++){
               if( m1.containsKey(nums[i])){
                    return true;
               }else{
                    m1.put(nums[i], 1);
               }
           }
     return false;

     }

    //3  思路 ：先排序后比较相邻的元素   时间复杂度n(logn)
    public static  boolean containsDuplicate2(int[] nums) {
     if(nums.length==0 || nums.length==1){
            return false;
        }
        Arrays.sort(nums);

        for(int i=0;i<nums.length-1;i++){
            if(nums[i]==nums[i+1]){
                return true;
            }
        }
        return false;
    }
    //4 使用set 不可重复特性:如果元素已经存在，再添加时返回false Time complexity: O(N), memory: O(N)
    public static  boolean containsDuplicate3(int[] nums) {
     if(nums.length==0) return false;
     Set<Integer> set1 = new HashSet <>();
     for(int i = 0; i< nums.length;i++)
     if(!set1.add(nums[i])) return true;
     return false;

    }

    //5 Time complexity: O(N^2), memory: O(1)
    public static  boolean containsDuplicate4(int[] nums) {
      for(int i = 0; i < nums.length; i++) {
             for(int j = i + 1; j < nums.length; j++) {
                 if(nums[i] == nums[j]) {
                     return true;
                 }
             }
         }
         return false;
    }
}
219. Contains Duplicate II
/**
 *
 */
package array;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * @author lishuai
 * @data 2016-11-30 上午10:33:49
 */

public class ContainsDuplicateII {

    /**
     * @author lishuai
     * @data 2016-11-30 上午10:33:49
Given an array of integers and an integer k,
find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j]
and the difference between i and j is at most k.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] a={0,1,2,3,1};
        containsNearbyDuplicate1(a,3);

    }

//1 思路：通过map来保存数组中的元素，要是已经存在即有重复，判断是否满足两者元素下标之差小于等于k,要是满足返回true，否则false
   public static boolean containsNearbyDuplicate(int[] nums, int k) {
        if(nums.length<2){
            return false;
        }
        Map<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])&&(i-map.get(nums[i])<=k)){
                return true;
            }
            map.put(nums[i], i);
        }
        return false;

    }
   //2 思路：通过hashset实现，由于查询两个元素下标不超高k，因此当i大于k时还没结束，可以移除前面的元素，这样节省空间
   public static boolean containsNearbyDuplicate1(int[] nums, int k) {

       Set<Integer> set = new HashSet<Integer>();
       for(int i = 0; i < nums.length; i++){
           if(i > k) set.remove(nums[i-k-1]);
           if(!set.add(nums[i])) return true;
       }
       return false;


   }
}

287. Find the Duplicate Number
http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/
/**
 *
 */
package array;

import java.util.Arrays;

/**
 * @author lishuai
 * @data 2016-11-29 上午8:44:54
 */

public class FindtheDuplicateNumber {

     /**
      * @author lishuai
      * @data 2016-11-29 上午8:44:54
      * @param args
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive),
 prove that at least one duplicate number must exist. Assume that there is only one duplicate number,
 find the duplicate one.

Note:
You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.
      */

     public static void main(String[] args) {
          // TODO Auto-generated method stub
          int[] a={4,3,2,7,1,6,5,8,8};

          //findDuplicate(a);
          System.out.println(findDuplicate1(a));
     }
     //1、自己第一想法 使用快排排序好数组，然后遍历一遍，判断相邻的两个数是否相等即可
    public static int findDuplicate(int[] nums) {
     int back=0;
        Arrays.sort(nums);
        for(int i=0;i<nums.length-1;i++){
          if(nums[i]==nums[i+1]){
              back= nums[i];
              break;
          }
        }
        return back;

    }
    /*
      * The main idea is the same with problem Linked List Cycle II,
      * https://leetcode.com/problems/linked-list-cycle-ii/.
      * Use two pointers the fast and the slow.
      * The fast one goes forward two steps each time, while the slow one goes only step each time.
      * They must meet the same item when slow==fast. In fact, they meet in a circle,
      * the duplicate number must be the entry point of the circle when visiting the array from nums[0].
      * Next we just need to find the entry point.
      * We use a point(we can use the fast one before) to visit form begining with one step each time,
      * do the same job to slow. When fast==slow, they meet at the entry point of the circle.
      * The easy understood code is as follows.
      *
      *  this is guarentted if you understand the problem #142 very well.
      *  Please note the constraint in the problem " array nums containing n + 1 integers
      *  where each integer is between 1 and n (inclusive)" makes the array an abstracted linked list:
      *  n[x] -> y. Now since integer cannot be 0, item 0 is guarenteed to be a "node" outside
      *  any cycle because n[x] must be larger than 0.
      *
      *  Then the 1st fast-slow traverse is guranteed to have the meet point at equally distance
      *  from the common starting point (0) to the cycle entry point
      *
      *
      *  There could be multiple cycles in our 'graph'.
      *  But the beauty of this problem is that nums[0] is always the entrance to the cycle
      *  which has duplicate numbers, because no one can jump back to nums[0].
      *  See the example below. index = [0 1 2 3 4 5 6 7]; nums=[5 2 1 3 5 7 6 4].
      *  nums[1] and nums[2] forms an isolated cycle. nums[3]=3 forms an isolated cycle.
      *  nums[6]=6 forms an isolated cycle. nums[5] nums[7] nums[4] forms a cycle
      *  and nums[0]=5 is an entrance to the cycle.
      *
      *
 1) Because of duplicated number, you will for sure go into a cycle when entering from index 0.

(2) If the dumplicated number is 'x', x will appear once
in the path from index 0 to the first element of the cycle and appear once in the cycle.
(Even though 'x' might appear more times in other places of the array.)
      */
    /*2 思路：由于题设中的n+1个数每个数在1~n之间，使得这个数组特殊化为一个抽象的链表，即n[x]->y；
     同时由于数组中的数都是大于零的，使得数组的第一个元素肯定在环的外面，因此从n[0]开始一定可以进入环（如果存在的话）
     [1,2,3,4,5,3]
     1 2
     2 4
     3 3

     4 1
     5 2
     3 3
     */
    public static int findDuplicate1(int[] nums) {

     if (nums.length > 1)
     {
          int slow = nums[0];
          int fast = nums[nums[0]];
          while (slow != fast)
          {
              slow = nums[slow];
              fast = nums[nums[fast]];
          }

          fast = 0;
          while (fast != slow)
          {
              fast = nums[fast];
              slow = nums[slow];
          }
          return slow;
     }
     return -1;

    }
    //3 和2思路类似
    public static int findDuplicate2(int[] nums) {
     int slow = 0;
        int fast = 0;
        // 找到快慢指针相遇的地方
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);
        int find = 0;
        // 用一个新指针从头开始，直到和慢指针相遇
        while(find != slow){
            slow = nums[slow];
            find = nums[find];
        }
        return find;
    }

    //4 二分查找+鸽笼原理    鸽笼原理 （抽屉原理） “如果有五个鸽子笼，养鸽人养了6只鸽子，那么当鸽子飞回笼中后，至少有一个笼子中装有2只或2只以上鸽子。
    public static int findDuplicate3(int[] nums) {
      int min = 0, max = nums.length - 1;
         while(min <= max){
             // 找到中间那个数
             int mid = min + (max - min) / 2;
             int cnt = 0;
             // 计算总数组中有多少个数小于等于中间数
             for(int i = 0; i < nums.length; i++){
                 if(nums[i] <= mid){
                     cnt++;
                 }
             }
             // 如果小于等于中间数的数量大于中间数，说明前半部分必有重复
             if(cnt > mid){
                 max = mid - 1;
             // 否则后半部分必有重复
             } else {
                 min = mid + 1;
             }
         }
         return min;
    }

}

442 FindAllDuplicatesinanArray
一个for循环O（n）
/**
 *
 */
package array;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-11-28 上午10:39:13
 */

public class FindAllDuplicatesinanArray {

    /**
     * @author lishuai
     * @data 2016-11-28 上午10:39:13
     * @param args
 Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array),
 some elements appear twice and others appear once.

Find all the elements that appear twice in this array.

Could you do it without extra space and in O(n) runtime?
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
     */

    public static void main(String[] args) {
        int[] a={4,3,2,7,8,2,3,1};

        findDuplicates2(a);
    }
    //1 思路：由于数组中是1~n的数字，可以将数组中的数字转化为数组的下标，遍历数组时第一次下标出现，将对应下标数组中的元素设置为相反数，否则，则是此下标再次出现，则将元素存入list中，最后将原数组恢复
    public static List<Integer> findDuplicates(int[] nums) {
        List<Integer> list=new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            int location=Math.abs(nums[i])-1;
            if(nums[location]<0){
                list.add(Math.abs(nums[i]));
            }else{
                nums[location]=-nums[location];
            }
        }
        //下面的代码可要可不要，回复数组中的元素
        for(int j=0;j<nums.length;j++){
            nums[j]=Math.abs(nums[j]);
        }

        return list;
    }
  //2 自己的第一思路       Time Limit Exceeded
    public static List<Integer> findDuplicates1(int[] nums) {

        List<Integer> list =new ArrayList<Integer>();
        for(int i=0;i<nums.length;i++){
            if(!list.contains(nums[i])){
                list.add(nums[i]);
            }
        }
        for(int j=0;j<nums.length;j++){
            if(list.contains(nums[j])){
                list.remove(Integer.valueOf(nums[j]));               
            }else{
                list.add(nums[j]);
            }
        }

        return list;
    }
    //3 这样也行，可1类似，只是没有恢复原数组
    public static List<Integer> findDuplicates2(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < nums.length; ++i) {
            int index = Math.abs(nums[i])-1;
            if (nums[index] < 0)
                res.add(Math.abs(index+1));
            nums[index] = -nums[index];
        }
        return res;
   }

}

```

# 数组中找缺失的数的问题（缺失一个或者2个数）

```java



1、给一个有N个元素数组，元素0.。。N之间找到缺失的那一个
Given an array contains N numbers of 0 .. N, find which number doesn't exist in the array.

Have you met this question in a real interview?

Yes

Example

Given N = 3 and the array [0, 1, 3], return 2.




 // write your code here
思路1：通过计算1到N的和然后减去出现的元素，结果就是缺失的元素
        // int res = nums.length;
        // for (int i = 0; i < nums.length;i++) {
        //     res = res+i-nums[i];
        // }
        // return res;
思路2:把出现的元素作为数组的下标，通过标记出现过元素为负数，然后再遍历一次找大于零的元素下标就是缺失的，返回下标（需要对0，N做特殊处理）
        // int zeroPos = -1;
        // for (int i = 0;i < nums.length;i++) {
        //     if (nums[i] == 0) {
        //         zeroPos = i;
        //     }
        //     if (Math.abs(nums[i]) != nums.length) {
        //         nums[Math.abs(nums[i])] = -nums[Math.abs(nums[i])];
        //     }
        // }
        // if (zeroPos == -1) {
        //     return 0;
        // }
        // for (int i = 0;i < nums.length;i++) {
        //     if (nums[i] > 0) {
        //         return i;
        //     }
        // }
        // return nums.length;
思路3：借助于桶排序的思想，把每个元素放到它该在的位置
        int missing = nums.length;
        int N = nums.length;
        for (int i = 0;i < N;i++) {//外循环保证每个元素在该在的位置
            while (nums[i] != i) {
                if (nums[i] == N) {
                    missing = i;
                    break;
                }
                int temp = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = temp;
            }
        }
        return missing;
    }

时间复杂度N


2、
1~n这n个数现在去掉两个，如何找到去掉的两个数。 假设去掉的两个数是a和b


一个数组找出去掉的两个数
思路：通过第一次遍历把1到N的和sum，以及乘积mul求出，即是sum=a+b，mul = a*b，然后解方程
- void FindTwoLostNum(int A[],int n,int &num1,int &num2)
- {
-     int sum = 0;
-     int mul = 1;
-     for(int i=1;i<=n;++i)
-     {
-         sum += i;
-         mul *= i;
-         //sum2 += i*i;
-     }
-     for(int j=0;j<n-2;++j)
-     {
-         sum -= A[j];
-         mul /= A[j];
-         //sum2 -= A[j]*A[j];
-     }
-     //此时得到2根之和为sum,2根之积为mul，根据求根公式可以解
-     num1 = (sum-(int)(sqrt(double(sum*sum-4*mul))))/2;
-     num2 = (sum+(int)(sqrt(double(sum*sum-4*mul))))/2;
- }

```

# 排序数组的中位数问题
```java

归并计数法 Merge and Count

复杂度

时间O(n) 空间O(1)

思路

如果对时间复杂度没有要求，这个方法是实现起来最简单的，我们只需要从下往上依次数(n+m)/2个元素即可。由于两个数组都已经排序，我们可以使用两个指针指向数组“底部”，通过比较两个数组“底部”的元素大小来决定计哪一个元素，同时将其所在数组的指针“向上”移一位。为了方便处理总元素为偶数的情况，这里将找中位数变成找第k小的元素。

注意

- 计数的循环是用来找到第k-1个元素的，最后return的时候再判断第k个元素是哪一个
- 在每次计数的循环中要先判断两个数组指针是否超界，在最后return之前也要判断一次


public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int total = len1 + len2;
        if(total % 2==0){
            return (findKth(nums1,nums2,total/2)+findKth(nums1,nums2,total/2+1))/2.0;
        } else {
            return findKth(nums1,nums2,total/2+1);
        }
    }
    private int findKth(int[] nums1, int[] nums2, int k){
        int p = 0, q = 0;
        for(int i = 0; i < k - 1; i++){
            if(p>=nums1.length && q<nums2.length){
                q++;
            } else if(q>=nums2.length && p<nums1.length){
                p++;
            } else if(nums1[p]>nums2[q]){
                q++;
            } else {
                p++;
            }
        }
        if(p>=nums1.length) {
            return nums2[q];
        } else if(q>=nums2.length) {
            return nums1[p];
        } else {
            return Math.min(nums1[p],nums2[q]);
        }
    }
}




分治法 Divide and Conquer

复杂度

时间O(log(m+n)) 空间O(1)

思路

题目要求O(log(m+n))的时间复杂度，一般来说都是分治法或者二分搜索。首先我们先分析下题目，假设两个有序序列共有n个元素（根据中位数的定义我们要分两种情况考虑），当n为奇数时，搜寻第(n/2+1)个元素，当n为偶数时，搜寻第(n/2+1)和第(n/2)个元素，然后取他们的均值。进一步的，我们可以把这题抽象为“搜索两个有序序列的第k个元素”。如果我们解决了这个k元素问题，那中位数不过是k的取值不同罢了。

那如何搜索两个有序序列中第k个元素呢，这里又有个技巧。假设序列都是从小到大排列，对于第一个序列中前p个元素和第二个序列中前q个元素，我们想要的最终结果是：p+q等于k-1,且一序列第p个元素和二序列第q个元素都小于总序列第k个元素。因为总序列中，必然有k-1个元素小于等于第k个元素。这样第p+1个元素或者第q+1个元素就是我们要找的第k个元素。

所以，我们可以通过二分法将问题规模缩小，假设p=k/2-1，则q=k-p-1，且p+q=k-1。如果第一个序列第p个元素小于第二个序列第q个元素，我们不确定二序列第q个元素是大了还是小了，但一序列的前p个元素肯定都小于目标，所以我们将第一个序列前p个元素全部抛弃，形成一个较短的新序列。然后，用新序列替代原先的第一个序列，再找其中的第k-p个元素（因为我们已经排除了p个元素，k需要更新为k-p），依次递归。同理，如果第一个序列第p个元素大于第二个序列第q个元素，我们则抛弃第二个序列的前q个元素。递归的终止条件有如下几种：

- 较短序列所有元素都被抛弃，则返回较长序列的第k个元素（在数组中下标是k-1）
- 一序列第p个元素等于二序列第q个元素，此时总序列第p+q=k-1个元素的后一个元素，也就是总序列的第k个元素

注意

- 每次递归不仅要更新数组起始位置（起始位置之前的元素被抛弃），也要更新k的大小（扣除被抛弃的元素）


public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int k = (m + n) / 2;
        if((m+n)%2==0){
            return (findKth(nums1,nums2,0,0,m,n,k)+findKth(nums1,nums2,0,0,m,n,k+1))/2;
        }  else {
            return findKth(nums1,nums2,0,0,m,n,k+1);
        }
       
    }
   
    private double findKth(int[] arr1, int[] arr2, int start1, int start2, int len1, int len2, int k){
        // 保证arr1是较短的数组
        if(len1>len2){
            return findKth(arr2,arr1,start2,start1,len2,len1,k);
        }
        if(len1==0){
            return arr2[start2 + k - 1];
        }
        if(k==1){
            return Math.min(arr1[start1],arr2[start2]);
        }
        int p1 = Math.min(k/2,len1) ;
        int p2 = k - p1;
        if(arr1[start1 + p1-1]<arr2[start2 + p2-1]){
            return findKth(arr1,arr2,start1 + p1,start2,len1-p1,len2,k-p1);
        } else if(arr1[start1 + p1-1]>arr2[start2 + p2-1]){
            return findKth(arr1,arr2,start1,start2 + p2,len1,len2-p2,k-p2);
        } else {
            return arr1[start1 + p1-1];
        }
    }
}
```




二维矩阵排序
矩阵的特点是每一行每一列都是有序的m * n

思路1：直接排序这m*n个数时间复杂度(m*n)*log(m*n)快排的复杂度，
思路2：借助于堆排序的思路，优先对列，（m*n）*log(m)

public static void main(String[] args) {
        // TODO Auto-generated method stub
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        List<Integer> l1 = new ArrayList<Integer>(Arrays.asList(1,2,3,4));
        List<Integer> l2 = new ArrayList<Integer>(Arrays.asList(5,6,7,8));
        List<Integer> l3 = new ArrayList<Integer>(Arrays.asList(9,10,11,12));
        list.add(l1);
        list.add(l2);
        list.add(l3);
        System.out.println(sort(list));

    }
    public static List<Integer> sort(List<List<Integer>> list) {
        List<Integer> res = new ArrayList<Integer>();
        if (list == null || list.size() == 0 || list.get(0).size() == 0) {
            return res;
        }
        PriorityQueue<List<Integer>> queue = new PriorityQueue<List<Integer>>(list.size(),new Comparator<List<Integer>>() {
            @Override
            public int compare(List<Integer> o1, List<Integer> o2) {
                return o1.get(0) - o2.get(0);
            }

        });
        for (int i = 0; i < list.size();i++) {
            if (list.get(i) != null && list.get(i).size() > 0) {
                queue.offer(list.get(i));
            }
        }
        while (!queue.isEmpty()) {
            List<Integer> temp = queue.poll();
            res.add(temp.get(0));
            temp.remove(0);
            if (temp.size() > 0) {
                queue.offer(temp);
            }
        }
        return res;
    }




数组总结：
1、二维数组的旋转

/*
* clockwise rotate顺时针
* first reverse up to down, then swap the symmetry
* 1 2 3    7 8 9    7 4 1
* 4 5 6  => 4 5 6  => 8 5 2
* 7 8 9    1 2 3    9 6 3
*/void rotate(vector<vector<int> > &matrix) {
    reverse(matrix.begin(), matrix.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}

/*
* anticlockwise rotate逆时针
* first reverse left to right, then swap the symmetry
* 1 2 3    3 2 1    3 6 9
* 4 5 6  => 6 5 4  => 2 5 8
* 7 8 9    9 8 7    1 4 7
*/void anti_rotate(vector<vector<int> > &matrix) {
    for (auto vi : matrix) reverse(vi.begin(), vi.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}
