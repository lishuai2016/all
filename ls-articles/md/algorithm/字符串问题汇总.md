
字符串问题总结
[字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)



字符串匹配的KMP算法（ 字符串查找算法）



最原始的暴力匹配算法

public static int check(String s1,String s2) {
        int i = 0;
        int j = 0;
        int len1 = s1.length();
        int len2 = s2.length();
        while (i < len1 && j < len2) {
            if (s1.charAt(i) == s2.charAt(j)) {
                i++;
                j++;
            } else {//相当于匹配串后羿
                i = i -(j - 1);
                j = 0;
            }
        }
        if(j == len2) {
            return i - j;
        }
        return -1;
    }


public static int KMP(String ts, String ps) {
        char[] t = ts.toCharArray();
        char[] p = ps.toCharArray();
        int i = 0; // 主串的位置
        int j = 0; // 模式串的位置
        int[] next = getNext(ps);
        while (i < t.length && j < p.length) {
           if (j == -1 || t[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0
               i++;
               j++;
           } else {
               // i不需要回溯了
               // i = i - j + 1;
               j = next[j]; // j回到指定位置
           }
        }
        if (j == p.length) {
           return i - j;
        } else {
           return -1;
        }
    }
    public static int[] getNext(String ps) {
        char[] p = ps.toCharArray();
        int[] next = new int[p.length];
        next[0] = -1;
        int j = 0;
        int k = -1;
        while (j < p.length - 1) {
           if (k == -1 || p[j] == p[k]) {
               next[++j] = ++k;
           } else {
               k = next[k];
           }
        }
        return next;
    }
    //优化处理
    public static int[] getNext1(String ps) {
        char[] p = ps.toCharArray();
        int[] next = new int[p.length];
        next[0] = -1;
        int j = 0;
        int k = -1;
        while (j < p.length - 1) {
           if (k == -1 || p[j] == p[k]) {
               if (p[++j] == p[++k]) { // 当两个字符相等时要跳过
                  next[j] = next[k];
               } else {
                  next[j] = k;
               }
           } else {
               k = next[k];
           }
        }
        return next;
    }




字符串操作总结(String)

String和StringBuffer,StringBuilder区别和联系，String为啥不可变，在内存中的具体形态。


总结：
1、统计一堆书数是否有相同的元素都可以采用标记的方法


- 十进制转成十六进制：
-
- Integer.toHexString(int i)
-
- 十进制转成八进制
-
- Integer.toOctalString(int i)
-
- 十进制转成二进制
-
- Integer.toBinaryString(int i)
-
- 十六进制转成十进制
-
- Integer.valueOf("FFFF",16).toString()
-
- 八进制转成十进制
-
- Integer.valueOf("876",8).toString()
-
- 二进制转十进制
-
- Integer.valueOf("0101",2).toString()


给定两个二进制字符串，返回他们的和（用二进制表示）。

您在真实的面试中是否遇到过这个题？

Yes

样例
a = 11
b = 1
返回 100










1、确定一个字符串中的所有字符都不相同。不使用额外的数据结构
思路：使用一个数组标记出现过的元素（布尔类型即可，减少空间消耗）
要是只有只有a-z26个字母，可以做优化，使用一个int数的bit位来标记即可

首先搞清楚是ascii编码还是unicode编码，ascii编码可表示做多256个字符，单字节；
unicode是2或者4字节
     */
    //1  当为ascii编码时     借助一个布尔数组。时间复杂度O（N），空间复杂度为O（1）
    public static boolean isUniqueChar1(String s) {
        if (s.length() > 256) return false;
        boolean[] flag = new boolean[256];
        for (int i = 0;i < s.length();i++) {
            if (flag[s.charAt(i)]) return false;
            flag[s.charAt(i)] = true;
        }
        return true;
    }

    //2 位向量法    当只有a-z26个字母时
    public static boolean isUniqueChar(String s) {
        if (s.length() > 256) return false;
        int check = 0;
        for (int i = 0;i < s.length();i++) {
            int val = s.charAt(i) - 'a';
            if ((check & (1 << val)) > 0) return false;
            check = check | (1 << val);
        }
        return true;
    }
2、翻转一个字符串
思路：首尾交换即可 

public static void reverseString(String s) {
        if (s == null || s.length() < 2) return;
        char[] charArray = s.toCharArray();
        int end = s.length() - 1;
        int start = 0;
        while (start < end) {
            char temp = charArray[start];
            charArray[start++] = charArray[end];
            charArray[end--] = temp;
        }
        s = new String(charArray);
        System.out.println(s);
    }
3、给定两个字符串，确定一个字符串的字符重排后为另外一个（变位词）
思路1：使用arrays.sort()对字符数据排序，然后比较两个字符串是否equal
思路2：ASCII码位256，构造一个数组统计各个字符出现的次数，然后遍历第二个字符，出现一个字符对应的个数减掉一个

//1对字符串排序，然后比较
    public static boolean permutation1 (String s1,String s2) {
        if (s1 != null && s2 != null) {
            if (s1.length() != s2.length()) {
                return false;
            }
            String s = sort(s1);
            return s.equals(sort(s2));
        } else {
            return false;
        }
    }
    public static String sort (String s) {
        char[] charArray = s.toCharArray();
        Arrays.sort(charArray);
        return new String(charArray);
    }
    //2统计字符出现的次数
    public static boolean permutation (String s1,String s2) {
        if (s1 != null && s2 != null) {
            if (s1.length() != s2.length()) {
                return false;
            }
            int[] dp = new int[256];
            for (int i = 0;i < s1.length();i++) {
                dp[s1.charAt(i)]++;
            }
            for (int i = 0;i < s2.length();i++) {
                if (--dp[s2.charAt(i)] < 0) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }

4、将一个字符串中的空格替换成“%20”（一个变3个）。假定该字符串的尾部有足够的空间存放新增字符，并且知道字符串的真正长度（用java实现的话，使用字符数组操作）
思路：首先统计字符串中空格的个数，然后从尾部遍历原数组，这样能够保证移动的次数最小

public static void repalceSpace(char[] s,int length) {
        if (s == null || s.length == 0) {
            return;
        }
        int spaceCount = 0;
        for (int i = 0;i < length;i++) {
            if (s[i] == ' ') {
                spaceCount ++;
            }
        }
        int newlength = length + spaceCount * 2;
        for (int i = length - 1;i >= 0;i--) {
            if (s[i] == ' ') {
                s[newlength--] = '0';
                s[newlength--] = '2';
                s[newlength--] = '%';
            } else {
                s[newlength--] =s[i];
            }
        }
        System.out.println(new String(s));
    }
5、利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变成a2b1c5a3.若“压缩”后的字符串没有变短，则返回原先的字符串。
public static String compressBad(String s) {
        if (s == null || s.length() < 2) {
            return s;
        }
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i < s.length() - 1) {
            int k = i + 1;
            char c = s.charAt(i);
            while (k < s.length() && s.charAt(k) == c) {
                k++;
            }
            sb.append(c + String.valueOf(k - i));
            i = k;
        }
        //假如最后一个是单个字符需要单独处理一下
        if (i == s.length() - 1) {
            sb.append(s.charAt(s.length() - 1) + String.valueOf(1));
        }
        System.out.println(sb.toString());
        return sb.length() < s.length() ? sb.toString() : s;
    }
6、假定有一个方法isSubstring，可检查一个单词是否为其他字符串的字串。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次issubtring。（比如，waterbottle是erbottlewat旋转后的字符串。）
思路：
s1 = xy=waterbottle
x= wat
y =erbottle
s2 = yx = erbotllewat

yx  肯定是xyxy的子串，及s2是s1s1的子串




public static boolean isRotation(String s1,String s2) {
        int len = s1.length();
        if (len == s2.length() && len >0) {
            String s1s1 = s1+s1;
            return s1s1.indexOf(s2) != -1 ? true:false;
        }
        return false;

    }




































最长的子串没有重复的字符
3. Longest Substring Without Repeating Characters
有些解法还有待研究
个人觉得比较直观的为解法1（字符串和数组常用的方案，二指针，滑动窗口）
package string;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

public class LongestSubstringWithoutRepeatingCharacters {

    /**
Given a string, find the length of the longest substring
without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke",
with the length of 3. Note that the answer must be a substring,
"pwke" is a subsequence and not a substring.

     */
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring3("abba"));

    }
    /**
We use HashSet to store the characters in current window [i,j)[i,j)
(j=ij=i initially). Then we slide the index jj to the right.
If it is not in the HashSet, we slide jj further.
Doing so until s[j] is already in the HashSet.
At this point, we found the maximum size of substrings
without duplicate characters start with index ii.
If we do this for all ii, we get our answer
     */
    //4 思路：有重复的元素时，移除最初添加的（有点不太好理解）
    public static int lengthOfLongestSubstring(String s) {
        int n = s.length();
        Set<Character> set = new HashSet<>();
        int ans = 0, i = 0, j = 0;
        while (i < n && j < n) {
            // try to extend the range [i, j]
            if (!set.contains(s.charAt(j))){
                set.add(s.charAt(j++));
                ans = Math.max(ans, j - i);
            }
            else {
                set.remove(s.charAt(i++));
            }
        }
        return ans;
    }
/**
 Commonly used tables are:
 •int[26] for Letters 'a' - 'z' or 'A' - 'Z'
 •int[128] for ASCII
 •int[256] for Extended ASCII

 */
    //3 原理不明白
    public static int lengthOfLongestSubstring3(String s) {
        int n = s.length(), ans = 0;
        int[] index = new int[128]; // current index of character
        // try to extend the range [i, j]
        for (int j = 0, i = 0; j < n; j++) {
            i = Math.max(index[s.charAt(j)], i);
            ans = Math.max(ans, j - i + 1);
            index[s.charAt(j)] = j + 1;
        }
        return ans;
    }


    //2 九章算法
    public static int lengthOfLongestSubstring2(String s) {
        int[] map = new int[256]; // map from character's ASCII to its last occured index

        int j = 0;
        int i = 0;
        int ans = 0;
        for (i = 0; i < s.length(); i++) {
            while (j < s.length() && map[s.charAt(j)]==0) {
                map[s.charAt(j)] = 1;
                ans = Math.max(ans, j-i + 1);
                j ++;
            }
            map[s.charAt(i)] = 0;
        }

        return ans;
    }

    /**
the basic idea is,
keep a hashmap which stores the characters in string as keys
and their positions as values, and keep two pointers
which define the max substring.
 move the right pointer to scan through the string ,
  and meanwhile update the hashmap.
  If the character is already in the hashmap,
  then move the left pointer to the right of the same character last found.
  Note that the two pointers can only move forward.
     */
    //1
    public static int lengthOfLongestSubstring1(String s) {
        if (s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int max=0;
        for (int i=0, j=0; i<s.length(); ++i){
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-j+1);
        }
        return max;
    }


}
 
最长的回文子串
5. Longest Palindromic Substring
个人觉得第三种好理解一些
public class LongestPalindromicSubstring {

    /**
     * @author lishuai
     * @data 2016-12-14 上午8:45:07
Given a string s, find the longest palindromic substring in s.
You may assume that the maximum length of s is 1000.

Example:

Input: "babad"

Output: "bab"

Note: "aba" is also a valid answer.
Example:

Input: "cbbd"

Output: "bb"
     */
    private static int lo, maxLen;
    public static void main(String[] args) {
        System.out.println(longestPalindrome("babad"));

    }
    /**
    Key idea, every time we move to right,
    we only need to consider whether using this new character as tail could produce new palindrome string of length
    (current length +1) or (current length +2)
     */
    //4 以当前字符作为回文字符的最后一个（有点抽象不太好理解）
     public static String longestPalindrome(String s) {
            String res = "";
            int currLength = 0;
            for(int i=0;i<s.length();i++){
                if(isPalindrome(s,i-currLength-1,i)){
                    res = s.substring(i-currLength-1,i+1);
                    currLength = currLength+2;
                }
                else if(isPalindrome(s,i-currLength,i)){
                    res = s.substring(i-currLength,i+1);
                    currLength = currLength+1;
                }
            }
            return res;
        }

        public static boolean isPalindrome(String s, int begin, int end){
            if(begin<0) return false;
            while(begin<end){
                if(s.charAt(begin++)!=s.charAt(end--)) return false;
            }
            return true;
        }

    //3 思路：以每个字符为中心分别往外扩展，最后的结果分为奇数和偶数的两种情况
    public static String longestPalindrome3(String s) {
        int len = s.length();
        if (len < 2)
            return s;

        for (int i = 0; i < len-1; i++) {
             extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible
             extendPalindrome(s, i, i+1); //assume even length.
        }
        return s.substring(lo, lo + maxLen);
    }

    private static void extendPalindrome(String s, int j, int k) {
        while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {
            j--;
            k++;
        }
        if (maxLen < k - j - 1) {
            lo = j + 1;
            maxLen = k - j - 1;
        }
    }

    //2 九章答案 （没理解）
    public static String longestPalindrome2(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        int length = s.length();   
        int max = 0;
        String result = "";
        for(int i = 1; i <= 2 * length - 1; i++){
            int count = 1;
            while(i - count >= 0 && i + count <= 2 * length  && get(s, i - count) == get(s, i + count)){
                count++;
            }
            count--; // there will be one extra count for the outbound #
            if(count > max) {
                result = s.substring((i - count) / 2, (i + count) / 2);
                max = count;
            }
        }

        return result;
    }

    private static char get(String s, int i) {
        if(i % 2 == 0)
            return '#';
        else
            return s.charAt(i / 2);
    }


    // 1 Time Limit Exceeded
    public static String longestPalindrome1(String s) {
        if (s == null || s.length() == 0) return s;
        int start = 0;
        int end = 1;
        int maxlength = 1;
        for (int i = 0;i < s.length() - 1;i++) {
            for (int j = i + 1;j < s.length();j++) {
                String temp = s.substring(i,j + 1);
                if (checkPalindrome(temp) && temp.length() > maxlength) {
                    maxlength = temp.length();
                    start = i;
                    end = j + 1;
                }
            }
        }       
        return s.substring(start,end);
    }
    public static boolean checkPalindrome(String s) {       
        int start = 0;
        int end = s.length() - 1;
        while (start < end) if (s.charAt(start++) != s.charAt(end--)) return false;         
        return true;
    }
}


6. ZigZag Conversion
/**
 *
 */
package string;

/**
 * @author lishuai
 * @data 2016-12-14 上午9:46:42
 */

public class ZigZagConversion {

    /**
     * @author lishuai
     * @data 2016-12-14 上午9:46:42
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this:
 (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".

a    g
b f h
c e i k
d    j

"abcdefghijk"
4                         "agbfhceikdj"

     */

    public static void main(String[] args) {
        System.out.println(convert("PAYPALISHIRING", 3));
    }

    //3 九章 内循环一次处理两列，感觉和法1思路差不多，只不过处理列的思路有点差异
    public static String convert(String s, int nRows) {
        int length = s.length();
        if (length <= nRows || nRows == 1) return s;
        char[] chars = new char[length];
        int step = 2 * (nRows - 1);
        int count = 0;
        for (int i = 0; i < nRows; i++){
            int interval = step - 2 * i;
            for (int j = i; j < length; j += step){
                   chars[count] = s.charAt(j);
                count++;
                if (interval < step && interval > 0
    && j + interval < length && count <  length){
                    chars[count] = s.charAt(j + interval);
                    count++;
                }
            }
        }
        return new String(chars);
    }

    /**
Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer.
Just take care of your index to keep them in bound.
     */
    //2 思路：没外循环一次，处理两列（两个内循环分别处理一列）分别拼接每一行，然后合并即可
    public static String convert2(String s, int nRows) {
        char[] c = s.toCharArray();
        int len = c.length;
        StringBuffer[] sb = new StringBuffer[nRows];
        for (int i = 0; i < sb.length; i++) sb[i] = new StringBuffer();

        int i = 0;
        while (i < len) {
            for (int idx = 0; idx < nRows && i < len; idx++) // vertically down
                sb[idx].append(c[i++]);
            for (int idx = nRows-2; idx >= 1 && i < len; idx--) // obliquely up
                sb[idx].append(c[i++]);
        }
        for (int idx = 1; idx < sb.length; idx++)
            sb[0].append(sb[idx]);
        return sb[0].toString();
    }


    //1 思路判断字符位置的相对位置
    public static String convert1(String s, int numRows) {
        if (s == null || s.length() < 2 || numRows < 2) return s;
        StringBuilder sb = new StringBuilder();       
        for (int i = 0;i < numRows;i++) {
            boolean flag = true;
            for (int j = i;j < s.length();) {
                sb.append(s.charAt(j));
                //起始和结尾行的处理
                if (i == numRows - 1 || i == 0) {
                    j = j + (numRows - 1) * 2;
                } else {
                    //朝下移
                    if (flag) {
                        j = j + (numRows - i - 1) * 2;
                        flag = false;
                    } else {
                        //朝上移
                        j = j + i * 2;
                        flag = true;
                    }                   
                }
            }
        }
        return sb.toString();
    }
}



1.1 旋转字符串

题目描述

给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。

分析与解法

解法一：暴力移位法

初看此题，可能最先想到的方法是按照题目所要求的，把需要移动的字符一个一个地移动到字符串的尾部，如此我们可以实现一个函数LeftShiftOne(char* s, int n) ，以完成移动一个字符到字符串尾部的功能，代码如下所示：

void LeftShiftOne(char* s, int n){
    char t = s[0];  //保存第一个字符
    for (int i = 1; i < n; i++)
    {
        s[i - 1] = s[i];
    }
    s[n - 1] = t;
}


因此，若要把字符串开头的m个字符移动到字符串的尾部，则可以如下操作：

void LeftRotateString(char* s, int n, int m){
    while (m--)
    {
        LeftShiftOne(s, n);
    }
}


下面，我们来分析一下这种方法的时间复杂度和空间复杂度。

针对长度为n的字符串来说，假设需要移动m个字符到字符串的尾部，那么总共需要 mn 次操作，同时设立一个变量保存第一个字符，如此，时间复杂度为O(m n)，空间复杂度为O(1)，空间复杂度符合题目要求，但时间复杂度不符合，所以，我们得需要寻找其他更好的办法来降低时间复杂度。

解法二：三步反转法

对于这个问题，换一个角度思考一下。

将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X="abc"，那么X^T="cba"），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。

例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可：

- 首先将原字符串分为两个部分，即X:abc，Y:def；
- 将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
- 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

如下图所示：

代码则可以这么写：

void ReverseString(char* s,int from,int to){
    while (from < to)
    {
        char t = s[from];
        s[from++] = s[to];
        s[to--] = t;
    }
}

void LeftRotateString(char* s,int n,int m){
    m %= n;              //若要左移动大于n位，那么和%n 是等价的
    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba
    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y->Y^T，即 def->fed
    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。
}


这就是把字符串分为两个部分，先各自反转再整体反转的方法，时间复杂度为O(n)，空间复杂度为O(1)，达到了题目的要求。

举一反三

1、链表翻转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，k=2，则翻转后2→1→6→5→4→3，若k=3，翻转后3→2→1→6→5→4，若k=4，翻转后4→3→2→1→6→5，用程序实现。

2、编写程序，在原字符串中把字符串尾部的m个字符移动到字符串的头部，要求：长度为n的字符串操作时间复杂度为O(n)，空间复杂度为O(1)。 例如，原字符串为”Ilovebaofeng”，m=7，输出结果为：”baofengIlove”。

3、单词翻转。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如，输入“I am a student.”，则输出“student. a am I”。







字符串包含

题目描述

给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？

为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)

比如，如果是下面两个字符串：

String 1：ABCD

String 2：BAD

答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。

如果是下面两个字符串：

String 1：ABCD

String 2：BCE

答案是false，因为字符串String2里的E字母不在字符串String1里。

同时，如果string1：ABCD，string 2：AA，同样返回true。

分析与解法

题目描述虽长，但题意很明了，就是给定一长一短的两个字符串A，B，假设A长B短，要求判断B是否包含在字符串A中。

初看似乎简单，但实现起来并不轻松，且如果面试官步步紧逼，一个一个否决你能想到的方法，要你给出更好、最好的方案时，恐怕就要伤不少脑筋了。

解法一

判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。

代码可如下编写：

bool StringContain(string &a,string &b){
    for (int i = 0; i < b.length(); ++i) {
        int j;
        for (j = 0; (j < a.length()) && (a[j] != b[i]); ++j)
            ;
        if (j >= a.length())
        {
            return false;
        }
    }
    return true;
}


假设n是字符串String1的长度，m是字符串String2的长度，那么此算法，需要O(n*m)次操作。显然，时间开销太大，应该找到一种更好的办法。

解法二

如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。

关于排序方法，可采用最常用的快速排序，参考代码如下：

//注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制bool StringContain(string &a,string &b){
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    for (int pa = 0, pb = 0; pb < b.length();)
    {
        while ((pa < a.length()) && (a[pa] < b[pb]))
        {
            ++pa;
        }
        if ((pa >= a.length()) || (a[pa] > b[pb]))
        {
            return false;
        }
        //a[pa] == b[pb]
        ++pb;
    }
    return true;
}




解法四

如果面试官继续追问，还有没有更好的办法呢？计数排序？除了计数排序呢？

事实上，可以先把长字符串a中的所有字符都放入一个Hashtable里，然后轮询短字符串b，看短字符串b的每个字符是否都在Hashtable里，如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。

再进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。

// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)bool StringContain(string &a,string &b){
    int hash = 0;
    for (int i = 0; i < a.length(); ++i)
    {
        hash |= (1 << (a[i] - 'A'));
    }
    for (int i = 0; i < b.length(); ++i)
    {
        if ((hash & (1 << (b[i] - 'A'))) == 0)
        {
            return false;
        }
    }
    return true;
}


这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。

举一反三

1、变位词

- 如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，比如bad和adb即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。



8. String to Integer (atoi)字符串转化为整数


本题考查的实际上就是字符串转换成整数的问题，或者说是要你自行实现atoi函数。那如何实现把表示整数的字符串正确地转换成整数呢？以"123"作为例子：

- 当我们扫描到字符串的第一个字符'1'时，由于我们知道这是第一位，所以得到数字1。
- 当扫描到第二个数字'2'时，而之前我们知道前面有一个1，所以便在后面加上一个数字2，那前面的1相当于10，因此得到数字：1*10+2=12。
- 继续扫描到字符'3'，'3'的前面已经有了12，由于前面的12相当于120，加上后面扫描到的3，最终得到的数是：12*10+3=123。

因此，此题的基本思路便是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。



- 空指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。
- 正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。
- 非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。
- 整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。
public class StringtoInteger {

  
    public static void main(String[] args) {
        System.out.println(myAtoi("   118100977011111111111111111111111111111"));

    }
    //九章   3 和1、2差不多，它采用long型变量保存中间变量
    public static int myAtoi(String str) {
        // Start typing your Java solution below
        // DO NOT write main() function
        if(str == null) {
            return 0;
        }
        str = str.trim();
        if (str.length() == 0) {
            return 0;
        }

        int sign = 1;
        int index = 0;

        if (str.charAt(index) == '+') {
            index++;
        } else if (str.charAt(index) == '-') {
            sign = -1;
            index++;
        }
        long num = 0;
        for (; index < str.length(); index++) {
            if (str.charAt(index) < '0' || str.charAt(index) > '9')
                break;
            num = num * 10 + (str.charAt(index) - '0');
            if (num > Integer.MAX_VALUE ) {
                break;
            }
        }
        if (num * sign >= Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        if (num * sign <= Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }
        return (int)num * sign;
    }
    //2 原理和1差不多，但是简化代码（从前拼）
    public static int myAtoi2(String str) {
        int index = 0, sign = 1, total = 0;
        //1. Empty string
        if(str.length() == 0) return 0;
        //2. Remove Spaces
        while(str.charAt(index) == ' ' && index < str.length())
            index ++;
        //3. Handle signs
        if(str.charAt(index) == '+' || str.charAt(index) == '-'){
            sign = str.charAt(index) == '+' ? 1 : -1;
            index ++;
        }
        //4. Convert number and avoid overflow
        while(index < str.length()){
            int digit = str.charAt(index) - '0';
            if(digit < 0 || digit > 9) break;
            //check if total will be overflow after 10 times and add digit
            if(Integer.MAX_VALUE/10 < total || Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE %10 < digit)
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            total = 10 * total + digit;
            index ++;
        }
        return total * sign;
    }

    //1 思路：截取前面连续的数字组合，遇到非数字结束；然后判断数的大小是否超出（从截取的字符串后面拼数字）
   

}



回文判断（个人觉得从两头开始，两个指针这个方案即可）

题目描述

回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。

那么，我们的第一个问题就是：判断一个字串是否是回文？

分析与解法

回文判断是一类典型的问题，尤其是与字符串结合后呈现出多姿多彩，在实际中使用也比较广泛，而且也是面试题中的常客，所以本节就结合几个典型的例子来体味下回文之趣。

解法一

同时从字符串头尾开始向中间扫描字串，如果所有字符都一样，那么这个字串就是一个回文。采用这种方法的话，我们只需要维护头部和尾部两个扫描指针即可。

代码如下：：

bool IsPalindrome(const char *s, int n){
    // 非法输入
    if (s == NULL || n < 1)
    {
        return false;
    }
    const char* front,*back;

    // 初始化头指针和尾指针
    front = s;
    back = s+ n - 1;

    while (front < back)
    {
        if (*front != *back)
        {
            return false;
        }
        ++front;
        --back;
    }
    return true;
}


这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。

解法二

上述解法一从两头向中间扫描，那么是否还有其它办法呢？我们可以先从中间开始、然后向两边扩展查看字符是否相等。参考代码如下：

bool IsPalindrome2(const char *s, int n){
    if (s == NULL || n < 1)
    {
        return false;
    }
    const char* first, *second;

    // m定位到字符串的中间位置     
    int m = ((n >> 1) - 1) >= 0 ? (n >> 1) - 1 : 0;
    first = s + m;
    second = s + n - 1 - m;

    while (first >= s)
    {
        if (*first!= *second)
        {
            return false;
        }
        --first;
        ++second;
    }
    return true;
}


时间复杂度：O(n)，空间复杂度：O(1)。

虽然本解法二的时空复杂度和解法一是一样的，但很快我们会看到，在某些回文问题里面，这个方法有着自己的独到之处，可以方便的解决一类问题。

举一反三

1、判断一条单向链表是不是“回文”

分析：对于单链表结构，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要向两个方向遍历的话，可以采取经典的快慢指针的方法，即先位到链表的中间位置，再将链表的后半逆置，最后用两个指针同时从链表头部和中间开始同时遍历并比较即可。

+

2、判断一个栈是不是“回文”

分析：对于栈的话，只需要将字符串全部压入栈，然后依次将各字符出栈，这样得到的就是原字符串的逆置串，分别和原字符串各个字符比较，就可以判断了。


最长回文子串

题目描述

给定一个字符串，求它的最长回文子串的长度。

分析与解法

最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。

解法一

那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：

int LongestPalindrome(const char *s, int n){
    int i, j, max,c;
    if (s == 0 || n < 1)
        return 0;
    max = 0;

    for (i = 0; i < n; ++i) { // i is the middle point of the palindrome 
        for (j = 0; (i - j >= 0) && (i + j < n); ++j){ // if the length of the palindrome is odd 
            if (s[i - j] != s[i + j])
                break;
            c = j * 2 + 1;
        }
        if (c > max)
            max = c;
        for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j){ // for the even case 
            if (s[i - j] != s[i + j + 1])
                break;
            c = j * 2 + 2;
        }
        if (c > max)
            max = c;
    }
    return max;
}


代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。

解法二、O(N)解法

在上文的解法一：枚举中心位置中，我们需要特别考虑字符串的长度是奇数还是偶数，所以导致我们在编写代码实现的时候要把奇数和偶数的情况分开编写，是否有一种方法，可以不用管长度是奇数还是偶数，而统一处理呢？比如是否能把所有的情况全部转换为奇数处理？

答案还是肯定的。这就是下面我们将要看到的Manacher算法，且这个算法求最长回文子串的时间复杂度是线性O(N)的。

首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。

此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。

以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = "$#1#2#2#1#2#3#2#1#"，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。

比如S和P的对应关系：

- S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #
- P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1

可以看出，P[i]-1正好是原字符串中最长回文串的总长度，为5。

接下来怎么计算P[i]呢？Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论：

- 如果mx > i，那么P[i] >= Min(P[2 * id - i], mx - i)

C代码如下：

//mx > i，那么P[i] >= MIN(P[2 * id - i], mx - i)//故谁小取谁if (mx - i > P[2*id - i])
    P[i] = P[2*id - i];
else  //mx-i <= P[2*id - i]
    P[i] = mx - i;


下面，令j = 2*id - i，也就是说j是i关于id的对称点。

当 mx - i > P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]；

当 P[j] >= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] >= mx - i。至于mx之后的部分是否对称，再具体匹配。

此外，对于 mx <= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配。

综上，关键代码如下：

//输入，并处理得到字符串sint p[1000], mx = 0, id = 0;
memset(p, 0, sizeof(p));
for (i = 1; s[i] != '\0'; i++)
{
    p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
    while (s[i + p[i]] == s[i - p[i]])
        p[i]++;
    if (i + p[i] > mx)
    {
        mx = i + p[i];
        id = i;
    }
}
//找出p[i]中最大的

此Manacher算法使用id、mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。


字符串的全排列

题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串

abc、acb、bac、bca、cab 和 cba。

分析与解法

解法一、递归实现

从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。以对字符串abc进行全排列为例，我们可以这么做：以abc为例

- 固定a，求后面bc的排列：abc，acb，求好后，a和b交换，得到bac
- 固定b，求后面ac的排列：bac，bca，求好后，c放到第一位置，得到cba
- 固定c，求后面ba的排列：cba，cab。

代码可如下编写所示：

void CalcAllPermutation(char* perm, int from, int to){
    if (to <= 1)
    {
        return;
    }

    if (from == to)
    {
        for (int i = 0; i <= to; i++)
            cout << perm[i];
        cout << endl;
    }
    else
    {
        for (int j = from; j <= to; j++)
        {
            swap(perm[j], perm[from]);
            CalcAllPermutation(perm, from + 1, to);
            swap(perm[j], perm[from]);
        }
    }
}


解法二、字典序排列

首先，咱们得清楚什么是字典序。根据维基百科的定义：给定两个偏序集A和B,(a,b)和(a′,b′)属于笛卡尔集 A × B，则字典序定义为

(a,b) ≤ (a′,b′) 当且仅当 a < a′ 或 (a = a′ 且 b ≤ b′)。

所以给定两个字符串，逐个字符比较，那么先出现较小字符的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。例如：abc < abcd < abde < afab。

那有没有这样的算法，使得

- 起点： 字典序最小的排列, 1-n , 例如12345
- 终点： 字典序最大的排列，n-1, 例如54321
- 过程： 从当前排列生成字典序刚好比它大的下一个排列

答案是肯定的：有，即是STL中的next_permutation算法。

在了解next_permutation算法是怎么一个过程之前，咱们得先来分析下“下一个排列”的性质。

- 假定现有字符串(A)x(B)，它的下一个排列是：(A)y(B’)，其中A、B和B’是“字符串”(可能为空），x和y是“字符”，前缀相同，都是A，且一定有y > x。
- 那么，为使下一个排列字典顺序尽可能小，必有：
    - A尽可能长
    - y尽可能小
    - B’里的字符按由小到大递增排列

现在的问题是：找到x和y。怎么找到呢？咱们来看一个例子。

比如说，现在我们要找21543的下一个排列，我们可以从左至右逐个扫描每个数，看哪个能增大（至于如何判定能增大，是根据如果一个数右面有比它大的数存在，那么这个数就能增大），我们可以看到最后一个能增大的数是：x = 1。

而1应该增大到多少？1能增大到它右面比它大的那一系列数中最小的那个数，即：y = 3，故此时21543的下一个排列应该变为23xxx，显然 xxx(对应之前的B’）应由小到大排，于是我们最终找到比“21543”大，但字典顺序尽量小的23145，找到的23145刚好比21543大。

由这个例子可以得出next_permutation算法流程为：

next_permutation算法

- 定义

    - 升序：相邻两个位置ai < ai+1，ai 称作该升序的首位
- 步骤（二找、一交换、一翻转）

    - 找到排列中最后（最右）一个升序的首位位置i，x = ai
    - 找到排列中第i位右边最后一个比ai 大的位置j，y = aj
    - 交换x，y
    - 把第(i+ 1)位到最后的部分翻转

还是拿上面的21543举例，那么，应用next_permutation算法的过程如下：

- x = 1；
- y = 3
- 1和3交换
    - 得23541
- 翻转541
    - 得23145

23145即为所求的21543的下一个排列。参考实现代码如下：

bool CalcAllPermutation(char* perm, int num){
    int i;

    //①找到排列中最后（最右）一个升序的首位位置i，x = ai
    for (i = num - 2; (i >= 0) && (perm[i] >= perm[i + 1]); --i){
        ;
    }
    // 已经找到所有排列
    if (i < 0){
        return false;
    }

    int k;
    //②找到排列中第i位右边最后一个比ai 大的位置j，y = aj
    for (k = num - 1; (k > i) && (perm[k] <= perm[i]); --k){
        ;
    }

    //③交换x，y
    swap(perm[i], perm[k]);
    //④把第(i+ 1)位到最后的部分翻转
    reverse(perm + i + 1, perm + num);
    return true;
}


然后在主函数里循环判断和调用calcAllPermutation函数输出全排列即可。

解法总结

由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这两种方法的时间复杂度都为O(n!)。

类似问题

1、已知字符串里的字符是互不相同的，现在任意组合，比如ab，则输出aa，ab，ba，bb，编程按照字典序输出所有的组合。

分析：非简单的全排列问题（跟全排列的形式不同,abc全排列的话，只有6个不同的输出）。 本题可用递归的思想，设置一个变量表示已输出的个数，然后当个数达到字符串长度时，就输出。

//copyright@ 一直很安静 && World Gao//假设str已经有序void perm(char* result, char *str, int size, int resPos){
  if(resPos == size)
    printf("%s\n", result);
  else
    {
      for(int i = 0; i < size; ++i)
        {
          result[resPos] = str[i];
          perm(result, str, size, resPos + 1);
        }
    }
}


2、如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？当输入的字符串中含有相同的字符串时，相同的字符交换位置是不同的排列，但是同一个组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。

+

3、写一个程序，打印出以下的序列。

(a),(b),(c),(d),(e)........(z)

(a,b),(a,c),(a,d),(a,e)......(a,z),(b,c),(b,d).....(b,z),(c,d).....(y,z)

(a,b,c),(a,b,d)....(a,b,z),(a,c,d)....(x,y,z)

....

(a,b,c,d,.....x,y,z)


































1、第一个只出现一次的字符

在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。

2、对称子字符串的最大长度

输入一个字符串，输出该字符串中对称的子字符串的最大长度。比如输入字符串“google”，由于该字符串里最长的对称子字符串是“goog”，因此输出4。

提示：可能很多人都写过判断一个字符串是不是对称的函数，这个题目可以看成是该函数的加强版。

3、编程判断俩个链表是否相交

给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。为了简化问题，我们假设俩个链表均不带环。

问题扩展：

- 如果链表可能有环列?
- 如果需要求出俩个链表相交的第一个节点列?

4、逆序输出链表

输入一个链表的头结点，从尾到头反过来输出每个结点的值。

5、在O(1)时间内删除单链表结点

给定单链表的一个结点的指针，同时该结点不是尾结点，此外没有指向其它任何结点的指针，请在O(1)时间内删除该结点。

6、找出链表的第一个公共结点

两个单向链表，找出它们的第一个公共结点。

7、在字符串中删除特定的字符

输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。

例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”。

8、字符串的匹配

在一篇英文文章中查找指定的人名，人名使用二十六个英文字母（可以是大写或小写）、空格以及两个通配符组成（、?），通配符“”表示零个或多个任意字母，通配符“?”表示一个任意字母。如：“J* Smi??” 可以匹配“John Smith” .

9、字符个数的统计

char *str = "AbcABca"; 写出一个函数，查找出每个字符的个数，区分大小写，要求时间复杂度是n（提示用ASCII码）

10、最小子串

给一篇文章，里面是由一个个单词组成，单词中间空格隔开，再给一个字符串指针数组，比如 char *str[]={"hello","world","good"};

求文章中包含这个字符串指针数组的最小子串。注意，只要包含即可，没有顺序要求。

提示：文章也可以理解为一个大的字符串数组，单词之前只有空格，没有标点符号。

11、字符串的集合

给定一个字符串的集合，格式如：{aaa bbb ccc}， {bbb ddd}，{eee fff}，{ggg}，{ddd hhh}要求将其中交集不为空的集合合并，要求合并完成后的集合之间无交集，例如上例应输出{aaa bbb ccc ddd hhh}，{eee fff}， {ggg}。

提示：并查集。

12、五笔编码

五笔的编码范围是a ~ y的25个字母，从1位到4位的编码，如果我们把五笔的编码按字典序排序，形成一个数组如下： a, aa, aaa, aaaa, aaab, aaac, … …, b, ba, baa, baaa, baab, baac … …, yyyw, yyyx, yyyy 其中a的Index为0，aa的Index为1，aaa的Index为2，以此类推。

- 编写一个函数，输入是任意一个编码，比如baca，输出这个编码对应的Index；
- 编写一个函数，输入是任意一个Index，比如12345，输出这个Index对应的编码。

13、最长重复子串

一个长度为10000的字符串，写一个算法，找出最长的重复子串，如abczzacbca,结果是bc。

提示：此题是后缀树/数组的典型应用，即是求后缀数组的height[]的最大值。

14、字符串的压缩

一个字符串，压缩其中的连续空格为1个后，对其中的每个字串逆序打印出来。比如"abc efg hij"打印为"cba gfe jih"。

15、最大重复出现子串

输入一个字符串，如何求最大重复出现的字符串呢？比如输入ttabcftrgabcd,输出结果为abc, canffcancd,输出结果为can。

给定一个字符串，求出其最长的重复子串。

分析：使用后缀数组，对一个字符串生成相应的后缀数组后，然后再排序，排完序依次检测相邻的两个字符串的开头公共部分。 这样的时间复杂度为：

- 生成后缀数组 O(N)
- 排序 O(NlogN*N) 最后面的 N 是因为字符串比较也是 O(N)
- 依次检测相邻的两个字符串 O(N * N)

故最终总的时间复杂度是 O(N^2*logN)

16、字符串的删除

删除模式串中出现的字符，如“welcome to asted”,模式串为“aeiou”那么得到的字符串为“wlcm t std"，要求性能最优。

17、字符串的移动

字符串为号和26个字母的任意组合，把 号都移动到最左侧，把字母移到最右侧并保持相对顺序不变，要求时间和空间复杂度最小。

18、字符串的包含

输入：

L:“hello”“july”

S:“hellomehellojuly”

输出：S中包含的L一个单词，要求这个单词只出现一次，如果有多个出现一次的，输出第一个这样的单词。

19、倒数第n个元素

链表倒数第n个元素。

提示：设置一前一后两个指针，一个指针步长为1，另一个指针步长为n，当一个指针走到链表尾端时，另一指针指向的元素即为链表倒数第n个元素。

20、回文字符串

将一个很长的字符串，分割成一段一段的子字符串，子字符串都是回文字符串。有回文字符串就输出最长的，没有回文就输出一个一个的字符。

例如：

habbafgh

输出h,abba,f,g,h。

提示：一般的人会想到用后缀数组来解决这个问题。

21、最长连续字符

用递归算法写一个函数，求字符串最长连续字符的长度，比如aaaabbcc的长度为4，aabb的长度为2，ab的长度为1。

22、字符串反转

实现字符串反转函数。

22、字符串压缩

通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串压缩程序，将字符串中连续出席的重复字母进行压缩，并输出压缩后的字符串。 压缩规则：

- 仅压缩连续重复出现的字符。比如字符串"abcbc"由于无连续重复字符，压缩后的字符串还是"abcbc"。
- 压缩字段的格式为"字符重复的次数+字符"。例如：字符串"xxxyyyyyyz"压缩后就成为"3x6yz"。

要求实现函数： void stringZip(const char pInputStr, long lInputLen, char pOutputStr);

- 输入pInputStr： 输入字符串lInputLen： 输入字符串长度
- 输出 pOutputStr： 输出字符串，空间已经开辟好，与输入字符串等长；

注意：只需要完成该函数功能算法，中间不需要有任何IO的输入输出

示例

- 输入：“cccddecc” 输出：“3c2de2c”
- 输入：“adef” 输出：“adef”
- 输入：“pppppppp” 输出：“8p”

23、集合的差集

已知集合A和B的元素分别用不含头结点的单链表存储，请求集合A与B的差集，并将结果保存在集合A的单链表中。例如，若集合A={5,10,20,15,25,30}，集合B={5,15,35,25}，完成计算后A={10,20,30}。

24、最长公共子串

给定字符串A和B，输出A和B中的第一个最长公共子串，比如A=“wepiabc B=“pabcni”，则输出“abc”。

25、均分01

给定一个字符串，长度不超过100，其中只包含字符0和1,并且字符0和1出现得次数都是偶数。你可以把字符串任意切分，把切分后得字符串任意分给两个人，让两个人得到的0的总个数相等，得到的1的总个数也相等。

例如，输入串是010111,我们可以把串切位01, 011,和1，把第1段和第3段放在一起分给一个人，第二段分给另外一个人，这样每个人都得到了1个0和两个1。我们要做的是让切分的次数尽可能少。

考虑到最差情况，则是把字符串切分(n - 1)次形成n个长度为1的串。

26、合法字符串

用n个不同的字符（编号1 - n），组成一个字符串，有如下2点要求：

- 1、对于编号为i 的字符，如果2 * i > n，则该字符可以作为最后一个字符，但如果该字符不是作为最后一个字符的话，则该字符后面可以接任意字符；
- 2、对于编号为i的字符，如果2 i <= n，则该字符不可以作为最后一个字符，且该字符后面所紧接着的下一个字符的编号一定要 >= 2 i。

问有多少长度为M且符合条件的字符串。

例如：N = 2，M = 3。则abb, bab, bbb是符合条件的字符串，剩下的均为不符合条件的字符串。

假定n和m皆满足：2<=n,m<=1000000000)。

27、最短摘要生成

你我在百度或谷歌搜索框中敲入本博客名称的前4个字“结构之法”，便能在第一个选项看到本博客的链接，如下图2所示：

在上面所示的图2中，搜索结果“结构之法算法之道-博客频道-CSDN.NET”下有一段说明性的文字：“程序员面试、算法研究、编程艺术、红黑树4大经典原创系列集锦与总结 作者：July--结构之法算法...”，我们把这段文字称为那个搜索结果的摘要，亦即最短摘要。我们的问题是，请问，这个最短摘要是怎么生成的呢?

28、实现memcpy函数

已知memcpy的函数为： void* memcpy(void* dest , const void* src , size_t count)其中dest是目的指针，src是源指针。不调用c++/c的memcpy库函数，请编写memcpy。

分析：参考代码如下：

void* memcpy(void *dst, const void *src, size_t count)     
{     
    //安全检查 
    assert( (dst != NULL) && (src != NULL) );     

    unsigned char *pdst = (unsigned char *)dst;     
    const unsigned char *psrc = (const unsigned char *)src;     

    //防止内存重复 
    assert(!(psrc<=pdst && pdst<psrc+count));     
    assert(!(pdst<=psrc && psrc<pdst+count));     

    while(count--)     
    {     
        *pdst = *psrc;     
        pdst++;     
        psrc++;     
    }     
    return dst;     
}


29、实现memmove函数

分析：memmove函数是的标准函数，其作用是把从source开始的num个字符拷贝到destination。最简单的方法是直接复制，但是由于它们可能存在内存的重叠区，因此可能覆盖了原有数据。

比如当source+count>=dest&&source<dest时，dest可能覆盖了原有source的数据。解决办法是从后往前拷贝，对于其它情况，则从前往后拷贝。

参考代码如下：

//void * memmove ( void * destination, const void * source, size_t num );) 
void* memmove(void* dest, void* source, size_t count) 
  { 

      void* ret = dest; 

      if (dest <= source || dest >= (source + count)) 
      { 
          //正向拷贝 
        //copy from lower addresses to higher addresses 
        while (count --) 
            *dest++ = *source++; 
    } 
    else 
    { 
        //反向拷贝 
        //copy from higher addresses to lower addresses 
        dest += count - 1; 
        source += count - 1; 

        while (count--) 
            *dest-- = *source--; 
    } 
    return ret; 
}




























最小子串覆盖


给定一个字符串source和一个目标字符串target，在字符串source中找到包括所有目标字符串字母的子串。

 注意事项

如果在source中没有这样的子串，返回""，如果有多个这样的子串，返回起始位置最小的子串。

您在真实的面试中是否遇到过这个题？

Yes

说明
在答案的子串中的字母在目标字符串中是否需要具有相同的顺序？
——不需要。

样例

给出source = "ADOBECODEBANC"，target = "ABC" 满足要求的解  "BANC"

public class Solution {   
//方法一:
    int initTargetHash(int []targethash, String Target) {
        int targetnum =0 ;
        for (char ch : Target.toCharArray()) {
            targetnum++;
            targethash[ch]++;
        }
        return targetnum;
    }
    boolean valid(int []sourcehash, int []targethash) {

        for(int i = 0; i < 256; i++) {
            if(targethash[i] > sourcehash[i])   
                return false;
        }
        return true;
    }
    public String minWindow(String Source, String Target) {
        // queueing the position that matches the char in T
        int ans = Integer.MAX_VALUE;
        String minStr = "";

        int[] sourcehash = new int[256];
        int[] targethash = new int[256];

        initTargetHash(targethash, Target);
        int j = 0, i = 0;
        for(i = 0; i < Source.length(); i++) {
            while( !valid(sourcehash, targethash) && j < Source.length()  ) {
                sourcehash[Source.charAt(j)]++;
                if(j < Source.length() )
                    j++;
                else
                    break;
            }
            if(valid(sourcehash, targethash) ){
                if(ans > j - i ) {
                    ans = Math.min(ans, j - i );
                    minStr = Source.substring(i, j );
                }
            }
            sourcehash[Source.charAt(i)]--;
        }
        return minStr;
    }

//方法二:
    public class Solution {
    int initTargetHash(int []targethash, String Target) {
        int targetnum =0 ;
        for (char ch : Target.toCharArray()) {
            targetnum++;
            targethash[ch]++;
        }
        return targetnum;
    }
    public String minWindow(String Source, String Target) {
        // queueing the position that matches the char in T
        int ans = Integer.MAX_VALUE;
        String minStr = "";

        int[] targethash = new int[256];

        int targetnum = initTargetHash(targethash, Target);
        int sourcenum = 0;
        int j = 0, i = 0;
        for(i = 0; i < Source.length(); i++) {
            if(targethash[Source.charAt(i)] > 0)
                sourcenum++;

            targethash[Source.charAt(i)]--;
            while(sourcenum>=targetnum) {
                if(ans > i - j + 1) {
                    ans = Math.min(ans, i - j + 1);
                    minStr = Source.substring(j, i + 1);
                }
                targethash[Source.charAt(j)]++;
                if(targethash[Source.charAt(j)] > 0)
                    sourcenum--;
                j++;
            }
        }
        return minStr;
    }

}
