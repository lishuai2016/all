```




链表的插入、归并、快速排序

/**
 *
 */
package sort;

import java.util.ArrayList;
import java.util.List;

/**
 * @author lishuai
 * @data 2016-12-16 上午11:08:18
 */

public class SortList {

    /**
     * @author lishuai
     * @data 2016-12-16 上午11:08:18
Sort a linked list in O(n log n) time using constant space complexity.
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }


    /**
     * Definition for singly-linked list.
     * class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) {
     *         val = x;
     *         next = null;
     *     }
     * }
     */

    /*
    The Solution 2:
    Quick Sort.
    使用快排也可以解决。但是注意，要加一个优化才可以过大数据，就是判断一下是不是整个链条是相同的节点，比如2 2 2 2 2 2 2 ，这样的就直接扫一次不用执行

快排，否则它会是N平方的复杂度。
    */
    //5 快速排序（暂时没理解）
    public ListNode sortList(ListNode head) {
        if (head == null) {
            return null;
        }

        // Sort the list from 0 to len - 1
        return quickSort(head);
    }

    // The quick sort algorithm

    // All the elements are the same!
    public boolean isDuplicate(ListNode head) {
        while (head != null) {
            if (head.next != null && head.next.val != head.val) {
                return false;
            }           

            head = head.next;
        }

        return true;
    }

    public ListNode quickSort(ListNode head) {
        if (head == null) {
            return null;
        }

        // 如果整个链是重复的，直接跳过。
        if (isDuplicate(head)) {
            return head;
        }

        // Use the head node to be the pivot.
        ListNode headNew = partition(head, head.val);

        // Find the pre position of the pivoit.
        ListNode cur = headNew;

        ListNode dummy = new ListNode(0);
        dummy.next = headNew;

        ListNode pre = dummy;

        // Find the pre node and the position of the piviot.
        while (cur != null) {
            if (cur.val == head.val) {
                break;
            }

            // move forward.
            cur = cur.next;
            pre = pre.next;
        }

        // Cut the link to be three parts.
        pre.next = null;

        // Get the left link;
        ListNode left = dummy.next;

        // Get the right link.
        ListNode right = cur.next;
        cur.next = null;

        // Recurtion to call quick sort to sort left and right link.
        left = quickSort(left);
        right = quickSort(right);

        // Link the three part together.

        // Link the first part and the 2nd part.
        if (left != null) {
            dummy.next = left;

            // Find the tail of the left link.
            while (left.next != null) {
                left = left.next;
            }
            left.next = cur;
        } else {
            dummy.next = cur;
        }

        cur.next = right;

        // The new head;
        return dummy.next;
    }

    // Return the new head;
    public ListNode partition(ListNode head, int x) {
        if (head == null) {
            return null;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode cur = head;

        // Record the big list.
        ListNode bigDummy = new ListNode(0);
        ListNode bigTail = bigDummy;

        while (cur != null) {
            if (cur.val >= x) {
                // Unlink the cur;
                pre.next = cur.next;

                // Add the cur to the tail of the new link.
                bigTail.next = cur;
                cur.next = null;

                // Refresh the bigTail.
                bigTail = cur;

                // 移除了一个元素的时候，pre不需要修改，因为cur已经移动到下一个位置了。
            } else {
                pre = pre.next;
            }

            cur = pre.next;
        }

        // Link the Big linklist to the smaller one.
        pre.next = bigDummy.next;

        return dummy.next;
    }


//4    和3原理一样，但是比3可读性强          使用Merge Sort, 空间复杂度是 O(logN) 因为使用了栈空间
        public static ListNode sortList4(ListNode head) {
            // Nodes should be more than 2.
            if (head == null || head.next == null) {
                return head;
            }

            // get the mid node.
            ListNode midPre = getMidPre(head);

            // Cut the two list.
            ListNode right = midPre.next;
            midPre.next = null;

            // Sort the left side and the right side.
            ListNode left = sortList4(head);
            right = sortList4(right);

            // Merge the two sides together.
            return merge(left, right);
        }

        // get the pre node before mid.
        public static ListNode getMidPre1(ListNode head) {
            ListNode slow = head;
            ListNode fast = head;

            while (fast != null && fast.next != null && fast.next.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            return slow;
        }

        // get the pre node before mid.
        public  static ListNode getMidPre(ListNode head) {
            ListNode slow = head;

            // fast提前一点儿。这样就可以得到前一个节点喽。
            ListNode fast = head.next;

            while (fast != null && fast.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            return slow;
        }

        public static ListNode merge(ListNode head1, ListNode head2) {
            ListNode dummy = new ListNode(0);
            ListNode cur = dummy;

            while (head1 != null && head2 != null) {
                if (head1.val < head2.val) {
                    cur.next = head1;
                    head1 = head1.next;
                } else {
                    cur.next = head2;
                    head2 = head2.next;
                }

                cur = cur.next;
            }

            if (head1 != null) {
                cur.next = head1;
            } else {
                cur.next = head2;
            }

            return dummy.next;
        }


    //3 使用归并排序     使用Merge Sort, 空间复杂度是 O(logN) 因为使用了栈空间
    public ListNode sortList3(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode f = head.next.next;
        ListNode p = head;
        while (f != null && f.next != null) {
            p = p.next;
            f =  f.next.next;
        }
        ListNode h2 = sortList3(p.next);
        p.next = null;
        return merge1(sortList3(head), h2);
    }
    public ListNode merge1(ListNode h1, ListNode h2) {
        ListNode hn = new ListNode(Integer.MIN_VALUE);
        ListNode c = hn;
        while (h1 != null && h2 != null) {
            if (h1.val < h2.val) {
                c.next = h1;
                h1 = h1.next;
            }
            else {
                c.next = h2;
                h2 = h2.next;
            }
            c = c.next;
        }
        if (h1 != null)
            c.next = h1;
        if (h2 != null)
            c.next = h2;
        return hn.next;
    }
    //2思路：把链表转换为数组然后快速排序，最后生成新的链表
    public static ListNode sortList2(ListNode head) {
        if (head == null) return head;
        ListNode helper = new ListNode(0);
        ListNode end = helper;
        List<Integer> list = new ArrayList<Integer>();
        while (head != null) {
            list.add(head.val);
            head = head.next;
        }
        int[] a = new int[list.size()];
        for (int i = 0;i < list.size();i++) {
            a[i] = list.get(i);
        }
        quick_sort(a,0,a.length);
        for (int i = 0;i < a.length;i++) {
            ListNode node = new ListNode(a[i]);
            end.next = node;
            end = node;
        }
        return helper.next;
    }
    //快速排序
    public static void quick_sort(int[] a,int l,int r) {
        if (l < r) {
            int x = a[l];
            int i = l;
            int j = r;
            while (i < j) {
                while (i < j && a[j] >= x) j--;
                if (i < j) a[i++] = a[j];
                while (i < j && a[i] <= x) i++;
                if (i < j) a[j--] = a[i];
            }   
            a[i] = x;
            quick_sort(a,l,i - 1);
            quick_sort(a,i + 1,r);
        }
    }


    //1 插入排序N*N
    public static ListNode sortList1(ListNode head) {
        if (head == null) return head;
        ListNode helper = new ListNode(0);
        while (head != null) {
            ListNode temp = head.next;
            ListNode node = helper;
            while (node.next != null && node.next.val < head.val) node = node.next;
            head.next = node.next;
            node.next = head;
            head = temp;           
        }   
        return helper.next;
    }
}



```java
链表常见操作总结（27）

1、移除未排序链表中的重复节点
    //1使用缓冲区N   时间复杂度N
    public static void deleteDups(ListNode head) {
        Hashtable<Integer,Boolean> table  = new Hashtable<Integer,Boolean>();
        //当前指针的前一个指针
        ListNode pre = null;
        while (head != null) {
            if (table.contains(head.val)) {
                pre.next = head.next;
            } else {
                table.put(head.val, true);
                pre = head;
            }
            head = head.next;
        }
    }
    //2不使用缓冲区   时间复杂度N*N（直接遍历）
    public static void deleteDups2(ListNode head) {
        if(head == null || head.next == null) {
            return;
        }
        ListNode current = head;
        while(current != null) {
            ListNode p = current;
            while (p.next != null) {
                if (p.next.val == current.val) {
                    p.next = p.next.next;
                } else {
                    p = p.next;
                }
            }
            current = current.next;
        }
    }

//3、对链表插入排序（N*logN）
2、找出单链表中倒数第k个节点

思路：
1、迭代，二指针，快的先走n步，然后一起走，当fast走到最后，slow就是结果
2、递归，到达链表末尾返回一个0计数器，当计数器等于k时就是第k个

ListNode nthToLast(ListNode head, int n) {
        // write your code here
        ListNode fast = head;
        ListNode slow = head;
        while (n > 0) {
            fast=fast.next;
            n--;
        }
        while (fast != null) {//不是if
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

递归
public static int nthtolast(ListNode head,int k) {
        if (head == null) {
            return 0;
        }
        int i = nthtolast(head.next,k) + 1;
        if (i == k) {
            System.out.println(head.val);
        }
        return i;
    }
直接返回节点的值
public static ListNode nthtolast(ListNode head,int k,IntWrapper i) {
        if (head == null) {
            return null;
        }
        ListNode node= nthtolast(head.next,k,i);
        i.value = i.value+1;
        if (i.value == k) {
            return head;
        }
        return node;
    }

class IntWrapper{
    public int value = 0;
}

3、在O(1)时间复杂度删除链表节点
思路：把后继结点的值复制到该节点，然后让该节点的next指向其后集结点的next即可
public void deleteNode(ListNode node) {
        // write your code here
        node.val = node.next.val;
        node.next = node.next.next;
    }
4、
给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。
你应该保留两部分内链表节点原有的相对顺序。
思路：一拆为二然后合并

public ListNode partition(ListNode head, int x) {
        // write your code here
        ListNode dummy1 = new ListNode(-1);
        ListNode dummy2 = new ListNode(-1);
        ListNode p1 = dummy1;
        ListNode p2 = dummy2;
        ListNode p = head;
        while (p != null) {
            if (p.val < x) {
                p1.next = p;
                p1 = p1.next;
            } else {
                p2.next = p;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (dummy1.next == null) {
            return head;
        } else {
            p1.next = dummy2.next;
            p2.next = null;//需要断开
            return dummy1.next;
        }
    }
5、链表求和
你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。
给出两个链表 3->1->5->null 和 5->9->2->null，返回 8->0->8->null
public ListNode addLists(ListNode l1, ListNode l2) {
        // write your code here
        ListNode dummy = new ListNode(-1);
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode p = dummy;
        int flag = 0;
        while (p1 != null || p2 != null) {
            int temp = flag;
            if (p1 != null) {
                temp += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                temp += p2.val;
                p2 = p2.next;
            }
            if (temp > 9) {
                temp -= 10;
                flag = 1;
            } else {
                flag = 0;
            }
            p.next = new ListNode(temp);
            p = p.next;
        }
        if (flag == 1) {
            p.next = new ListNode(1);
        }
        return dummy.next;
    }
假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。
给出 6->1->7 + 2->9->5。即，617 + 295。
返回 9->1->2。即，912 。

思路：翻转之后转化成上面的问题，然后计算结果，然后在翻转一次就行了

 public ListNode addLists2(ListNode l1, ListNode l2) {
        // write your code here
        ListNode l11 = reverse(l1);
        ListNode l22 = reverse(l2);
        ListNode p1 = l11;
        ListNode p2 = l22;
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        int flag = 0;
        while (p1 != null || p2 != null) {
            int temp = flag;
            if (p1 != null) {
                temp += p1.val;
                p1 = p1.next;
            }
            if (p2 != null){
                temp += p2.val;
                p2 = p2.next;
            }
            if (temp > 9) {
                temp -= 10;
                flag = 1;
            } else {
                flag = 0;
            }
            ListNode node = new ListNode(temp);
            p.next = node;
            p = p.next;
        }
        if (flag == 1) {
            ListNode node = new ListNode(1);
            p.next = node;
        }
        return reverse(dummy.next);
    } 

    public ListNode reverse (ListNode head) {
        ListNode newhead = null;
        while (head != null) {
            ListNode temp = head.next;
            head.next = newhead;
            newhead = head;
            head = temp;
        }
        return newhead;
    }



6、判断一个链表是否为回文链表

思路：找到中间节点然后把后面的翻转，（需要断开链表）然后比较和头节点开始的前段，最后要是后半段的游标可以走到最后说明是回文否则不是

别的思路：
1、整体翻转比较
2、借助一个栈存放前半段的元素，然后和后半段的比较
public boolean isPalindrome(ListNode head) {
        // Write your code here
        if (head == null || head.next == null) {
            return true;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != null && fast.next != null ) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode second = slow.next;
        slow.next = null;

        ListNode secondhead = null;
        ListNode p = second;
        while (p != null) {
            ListNode temp = p.next;
            p.next = secondhead;
            secondhead = p;
            p = temp;
        }

        ListNode p1 = head;
        ListNode p2 = secondhead;
        while (p2 != null && p2.val == p1.val) {
            p1 = p1.next;
            p2 = p2.next;
        }
        if (p2 == null) {
            return true;
        } else {
            return false;
        }
    }


递归实现
递归的终止条件：
当长度为0或者1的时候表明链表处于中间位置
class Result{
    public ListNode node;
    public boolean result;
    public Result(ListNode node,boolean res) {
        this.node = node;
        this.result=res;
    }
}

public Result ispalindromeResourse(ListNode head,int length) {
        if (head == null || length == 0) {
            return new Result(null,true);
        } else if (length == 1 ){
            return new Result(head.next,true);
        } else if (length == 2) {
            return new Result(head.next.next,head.val == head.next.val);
        }
        Result res = ispalindromeResourse(head.next,length-2);
        if (!res.result || res.node==null) {
            return res;
        } else {
            res.result = head.val == res.node.val;
            res.node = res.node.next;
            return res;
        }
    }
}
结果就是返回值的result

7、使用链表实现栈和队列
在Java中，链表的实现非常简单，每个节点Node都有一个值val和指向下个节点的链接next。

class Node {
    int val;
    Node next;

    Node(int x) {
        val = x;
        next = null;
    }
}


链表两个著名的应用是栈Stack和队列Queue。

栈：

class Stack{
    Node top;

    public Node peek(){
        if(top != null){
            return top;
        }

        return null;
    }

    public Node pop(){
        if(top == null){
            return null;
        }else{
            Node temp = new Node(top.val);
            top = top.next;
            return temp;   
        }
    }

    public void push(Node n){
        if(n != null){
            n.next = top;
            top = n;
        }
    }
}


队列：

class Queue{
    Node first, last;

    public void enqueue(Node n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }

    public Node dequeue(){
        if(first == null){
            return null;
        }else{
            Node temp = new Node(first.val);
            first = first.next;
            return temp;
        } 
    }
}


8、链表的插入、归并、快速排序

思路：外循环保证元素的逐个插入，不用考虑是否断裂，内循环根据找个要插入元素的前一个节点，然后把待插入的节点放进去，修改两个指针即可。
insertionSortList
//1 插入排序N*N
    public static ListNode sortList1(ListNode head) {
        if (head == null) return head;
        ListNode helper = new ListNode(0);
        while (head != null) {
            ListNode temp = head.next;
            ListNode node = helper;
            while (node.next != null && node.next.val < head.val) node = node.next;
            head.next = node.next;
            node.next = head;
            head = temp;
        }
        return helper.next;
    }

思路：找到链表的中间节点，把链表断开成两段，然后两段递归，返回两段的合并

使用归并排序     使用Merge Sort, 空间复杂度是 O(logN) 因为使用了栈空间
public ListNode sortList(ListNode head) { 
        // write your code here
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head;
        ListNode fast = head.next.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode head2 = sortList(slow.next);
        slow.next = null;
        ListNode head1 = sortList(head);
        return mergeSorted(head1,head2);
    }

    public ListNode mergeSorted(ListNode h1,ListNode h2) {
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while (h1 != null && h2 != null) {
            if (h1.val < h2.val) {
                p.next = h1;
                h1 = h1.next;
            } else {
                p.next = h2;
                h2 = h2.next;
            }
            p = p.next;
        }
        if (h1 != null) {
            p.next = h1;
        }
        if (h2 != null) {
            p.next = h2;
        }
        return dummy.next;
    }


快速排序的两种方式

- 使第一个节点为中心点
- 创建2个指针(p，q)，p指向头结点，q指向p的下一个节点
- q开始遍历,如果发现q的值比中心点的值小，则此时p=p->next，并且执行当前p的值和q的值交换，q遍历到链表尾即可
- 把头结点的值和p的值执行交换。此时p节点为中心点,并且完成1轮快排
- 使用递归的方法即可完成排序

方式一：通过交换节点的值来实现
public ListNode sortList(ListNode head) {
        // write your code here
        ListNode tail = head;
        while (tail != null && tail.next!= null) {
            tail = tail.next;
        }
        quick_sort(head,tail);
        return head;
    }


    public void quick_sort(ListNode start,ListNode end) {
        if (start == null || end == null || start == end) {
            return;
        }
        ListNode slow = start;
        ListNode fast = start.next;
        int base = start.val;
        while (fast != end.next && fast != null) {
            if (fast.val < base) {
                slow = slow.next;
                if (slow != fast) {
                    int temp = slow.val;
                    slow.val = fast.val;
                    fast.val = temp;
                }
            }
            fast = fast.next;
        }
        if (start != slow) {
            int temp = slow.val;
            slow.val = start.val;
            start.val = temp;
        }
        quick_sort(start,slow);
        quick_sort(slow.next,end);
    }


方式二，通过交换节点来实现
一次遍历把链表分成三段，第一段都是比所选分界点值小的，第二段是值和分界点值相等的，第三段是比分界点值大的，然后合并三段即可
public ListNode sortList(ListNode head) {
        // write your code here
        if (head == null || head.next == null) {
            return head;
        }
        ListNode left = new ListNode(-1);
        ListNode mid = new ListNode(-1);
        ListNode right = new ListNode(-1);
        ListNode lefthead = left;
        ListNode midhead = mid;
        ListNode righthead = right;
        int base = head.val;
        ListNode p = head;
        while (p != null) {
            if (p.val < base) {
                left.next = p;
                left = left.next;
            } else if (p.val > base) {
                right.next = p;
                right = right.next;
            } else {
                mid.next = p;
                mid = mid.next;
            }
            p = p.next;
        }
        left.next = null;
        mid.next = null;
        right.next =null;
        return merge(sortList(lefthead.next),midhead.next,sortList(righthead.next));
    }
    public ListNode merge(ListNode first,ListNode mid,ListNode end) {
        ListNode res = null;
        //判断是否有第一段
        if (first != null) {
            res = first;
            ListNode tail = findtail(first);
            tail.next = mid;
        } else {
            res = mid;
        }
        //拼接后半段
        ListNode midtail = findtail(mid);
        midtail.next = end;
        return res;
    }
    public ListNode findtail(ListNode head) {
        while (head != null && head.next != null) {
            head = head.next;
        }
        return head;
    }







复制带随机指针的链表


public RandomListNode copyRandomList(RandomListNode head) {
  if (head == null) return null;
 
  Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();
 
  // loop 1. copy all the nodes
  RandomListNode node = head;
  while (node != null) {
    map.put(node, new RandomListNode(node.label));
    node = node.next;
  }
 
  // loop 2. assign next and random pointers
  node = head;
  while (node != null) {
    map.get(node).next = map.get(node.next);
    map.get(node).random = map.get(node.random);
    node = node.next;
  }
 
  return map.get(head);
}



An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is O(N), although with a linear time complexity.

As an optimised solution, we could reduce the space complexity into constant. The idea is to associate the original node with its copy node in a single linked list. In this way, we don't need extra space to keep track of the new nodes.

The algorithm is composed of the follow three steps which are also 3 iteration rounds.

- Iterate the original list and duplicate each node. The duplicate
of each node follows its original immediately.
- Iterate the new list and assign the random pointer for each
duplicated node.
- Restore the original list and extract the duplicated nodes.

The algorithm is implemented as follows:


public RandomListNode copyRandomList(RandomListNode head) {
        RandomListNode iter = head, next;

        // First round: make copy of each node,
        // and link them together side-by-side in a single list.
        while (iter != null) {
                next = iter.next;

                RandomListNode copy = new RandomListNode(iter.label);
                iter.next = copy;
                copy.next = next;

                iter = next;
        }

        // Second round: assign random pointers for the copy nodes.
        iter = head;
        while (iter != null) {
                if (iter.random != null) {
                        iter.next.random = iter.random.next;
                }
                iter = iter.next.next;
        }

        // Third round: restore the original list, and extract the copy list.
        iter = head;
        RandomListNode pseudoHead = new RandomListNode(0);
        RandomListNode copy, copyIter = pseudoHead;

        while (iter != null) {
                next = iter.next.next;

                // extract the copy
                copy = iter.next;
                copyIter.next = copy;
                copyIter = copy;

                // restore the original list
                iter.next = next;

                iter = next;
        }

        return pseudoHead.next;
}




1、翻转一个链表
//非递归
private static ListNode reverse(ListNode head) {
             ListNode newHead = null;
             while (head != null) {
                 ListNode temp = head.next;
                 head.next = newHead;
                 newHead = head;
                 head = temp;
             }
             return newHead;
         }


//递归
 public ListNode reverse(ListNode head) {
       if(head==null||head.next==null)return head;

      ListNode temp = reverse(head.next);//head.next表示最后一个节点
      head.next.next = head;//朝前指向（最后一个指向倒数第二个）
      head.next = null;
      return temp;

        
    }
2、找中间节点（要是链表节点个数为奇数时刚好指向中间点；为偶数时指向中间两个的第一个元素）

private static ListNode findMiddle(ListNode head) {
             ListNode slow = head, fast = head.next;
             while (fast != null && fast.next != null) {
                 fast = fast.next.next;
                 slow = slow.next;
             }
             return slow;
         }

public static ListNode findMid2(ListNode head) {
            ListNode fast = head;
            ListNode slow = head;
            while (fast != null && fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
            }
            return slow;
        }
奇数时中间节点，偶数时后面一个



3、判断一个链表是否有环

如果队列中含有圆环，那么对队列的遍历会有什么影响呢。试想有一个圆形跑道，甲乙两人同时在跑道的起点，如果甲的速度是乙的两倍，那么当乙跑完半圈时，甲跑完一圈回到起点，乙跑完一圈回到起点时，甲跑完两圈也回到起点，这样的话，甲乙重新在起点相遇。

采用上面的思路，如果我们使用两个指针分别从队列的起点出发，一个指针前进一次遍历1个节点，另一个指针前进一次，遍历2个节点，如果队列中有环，那么我们可以确信，前进若干次之后，两个指针会相遇，于是算法就是让两个指针同时前进，如果两个指针能相遇的话，那么可以断定链表中有环

//1 思路：二指针，一个一次走一步，一个一次走两步。出现相遇点则有环
    public boolean hasCycle1(ListNode head) {
     if (head == null || head.next == null) return false;
     ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null) {
             slow = slow.next;
             fast = fast.next.next;
             if(slow == fast) return true;
        }
        return false;
    }
4、链表中有环，找到环开始的节点
/**
 *
思路1、假设x为从头结点到环开始的节点的距离，k为从环开始节点到相遇节点的距离，y为环的长度。
两个指针slow fast，slow每次走一步，fast每次走两步，则有
t = X + nY + K
2t = X + mY + K
化简可以得到：
X+K  =  (m-2n)Y   即 (k=y-x)
或者X = (Y - K) + (m - 2n - 1)Y
则可以得到 ：从相遇节点往下走到环的开始节点的距离和从head节点到环的开始节点的距离相等。
 */
     //1
     public ListNode detectCycle(ListNode head) {
          ListNode fast=head;
          ListNode slow=head;
          while(fast!=null&&fast.next!=null){
              slow=slow.next;
              fast=fast.next.next;
              if(fast==slow){
                   break;
              }
          }
          if(fast==null||fast.next==null){
              return null;
          }
          //走到这里说明有环
          slow=head;
          while(slow!=fast){
              slow=slow.next;
              fast=fast.next;
          }
     return slow;
    }

5、每次翻转k个

注意点：需要保存翻转的开始以及结束节点

两个一组进行操作
public ListNode swapPairs(ListNode head) {
        // write your code here
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while (p != null && p.next != null && p.next.next != null) {
            ListNode p1 = p.next;
            ListNode p2 = p.next.next;
            ListNode temp = p2.next;
            p2.next = p1;
            p1.next = temp;
            p.next = p2;
            p = p1;
        }
        return dummy.next;
    }


public ListNode swapPairs(ListNode head) {
        // Write your code here
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        dummy.next = head;
        ListNode p1 = dummy.next;
        ListNode p2 = dummy.next.next;
        while (p1 != null && p2 != null) {
            ListNode temp = p2.next;
            p.next = p2;
            p2.next = p1;
            p1.next = temp;

            if (temp == null) {
                break;
            }
            p1 = temp;
            p2 = temp.next;
            p = p.next.next;
        }

        return dummy.next;
    }

 public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k < 1) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while (p.next != null) {
            int n = k;
            ListNode q = p.next;
            ListNode start = p.next;
            while (q != null && n  > 1) {
                q = q.next;
                n--;
            }
            if (n > 1 || q == null) {
                break;
            } else {
                ListNode end = q.next;
                ListNode newhead = null;
                ListNode newend = start;
                while (start != end) {
                    ListNode t = start.next;
                    start.next = newhead;
                    newhead = start;
                    start = t;
                } //拼接新的头、尾，把当前游标移动到新的尾。
                p.next = newhead;
                newend.next = end;
                p = newend;
            }
        }
        return dummy.next;
    }

6、合并n个有序链表
 public ListNode mergeKLists(List<ListNode> lists) {
        // write your code here
        if (lists == null || lists.size() == 0) {
            return null;
        }
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        Queue<ListNode> queue = new PriorityQueue<ListNode>(lists.size(), new Comparator<ListNode>()
        {   
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val;
            }
        });
        for (ListNode node : lists) {
            if (node != null) {
                queue.offer(node);
            }
        }
        while (!queue.isEmpty()) {
             ListNode node = queue.poll();
                 p.next = node;
                 if (node.next != null) {
                     queue.offer(node.next);
                 }
                 p = p.next;
        }
        return dummy.next;
    }



删除链表中等于给定值val的所有节点。

您在真实的面试中是否遇到过这个题？


样例
给出链表 1->2->3->3->4->5->3, 和 val = 3, 你需要返回删除3之后的链表：1->2->4->5。
 

public ListNode removeElements(ListNode head, int val) {
        // Write your code here
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while ( p.next != null) {
            if (p.next.val == val) {
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return dummy.next;
    }




将两个排序链表合并为一个新的排序链表

您在真实的面试中是否遇到过这个题？

Yes

样例
给出 1->3->8->11->15->null，2->null， 返回 1->2->3->8->11->15->null。
 

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // write your code here
        ListNode dummy = new ListNode(-1);
        ListNode p =dummy;
        ListNode p1 = l1;
        ListNode p2 = l2;
        while (p1 != null && p2 != null) {
            if (p1.val < p2.val) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (p1 != null) {
            p.next = p1;
        }
        if (p2 != null) {
            p.next = p2;
        }
        return dummy.next;
    }




给定一个排序链表，删除所有重复的元素每个元素只留下一个。

您在真实的面试中是否遇到过这个题？

Yes

样例
给出 1->1->2->null，返回 1->2->null
给出 1->1->2->3->3->null，返回 1->2->3->null

标签

public static ListNode deleteDuplicates(ListNode head) {
        // write your code here
        ListNode p = head;
        while (p != null) {
            ListNode q = p.next;
            while (q != null && q.val == p.val) {
                q = q.next;
            }
            p.next = q;
            p = p.next;
        }
        return head;
    } 


给定一个链表，删除链表中倒数第n个节点，返回链表的头节点。

 注意事项
链表中的节点个数大于等于n

您在真实的面试中是否遇到过这个题？

Yes

样例
给出链表1->2->3->4->5->null和 n = 2.
删除倒数第二个节点之后，这个链表将变成1->2->3->5->null

 ListNode removeNthFromEnd(ListNode head, int n) {
        // write your code here
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        while (fast != null && n > -1) {
            fast = fast.next;
            n--;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }



给出一个所有元素以升序排序的单链表，将它转换成一棵高度平衡的二分查找树

您在真实的面试中是否遇到过这个题？

Yes

样例

              2
1->2->3  =>  / \
            1  3

public TreeNode sortedListToBST(ListNode head) {
        // write your code here
        if (head == null) {
            return null;
        }
        return helper(head,null);
    }
    public TreeNode helper(ListNode head,ListNode end) {
        if (head == end) {
           return null;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != end && fast.next != end) {
            fast = fast.next.next;
            slow = slow.next;
        }
        TreeNode root = new TreeNode(slow.val);
        root.left = helper(head,slow);
        root.right = helper(slow.next,end);
        return root;
    }



请写一个程序，找到两个单链表最开始的交叉节点。

 注意事项
- 如果两个链表没有交叉，返回null。
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。

您在真实的面试中是否遇到过这个题？

Yes

样例
下列两个链表：

A:          a1 → a2
                  ↘
                    c1 → c2 → c3
                  ↗           
B:    b1 → b2 → b3


在节点 c1 开始交叉。


public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // Write your code here
        ListNode p1 = headA;
        ListNode p2 = headB;
        int len1 = 0;
        int len2 = 0;
        while (p1 != null) {
            p1 = p1.next;
            len1++;
        }
        while (p2 != null) {
            p2 = p2.next;
            len2++;
        }
        p1 = headA;
        p2 = headB;
        if (len1 < len2) {
            for (int i = 0; i < len2 - len1; i++) {
                p2 = p2.next;
            }
        } else {
            for (int i = 0; i < len1 - len2; i++) {
                p1 = p1.next;
            }
        }
       ListNode res = null;
        while (p1 != null && p2 != null) {
                if (p1 == p2) {
                    res = p1;
                    break;
                }
                p1 = p1.next;
                p2 = p2.next;
        }
        return res;
    } 

```



单链表常见操作总结


常用技巧
1、二指针（两者根据题意保持一定得间隔）
2、遍历链表时需要注意区别的点
p = A;（不改变链表的原来结构）
p.next = A;（改变链表的结构）
3、多一个冗余节点，便于操作ListNode dummy = new ListNode(0);

 while (p != null && p.next != null) {}这种遍历链表可以使得p最后指向节点的最后一个

public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) {
     val = x;
     next = null;
     }
}

1、翻转一个链表
private static ListNode reverse(ListNode head) {
             ListNode newHead = null;
             while (head != null) {
                 ListNode temp = head.next;
                 head.next = newHead;
                 newHead = head;
                 head = temp;
             }
             return newHead;
         }
2、找中间节点（要是链表节点个数为奇数时刚好指向中间点；为偶数时指向中间两个的第一个元素）

private static ListNode findMiddle(ListNode head) {
             ListNode slow = head, fast = head.next;
             while (fast != null && fast.next != null) {
                 fast = fast.next.next;
                 slow = slow.next;
             }
             return slow;
         }

public static ListNode findMid2(ListNode head) {
            ListNode fast = head;
            ListNode slow = head;
            while (fast != null && fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
            }
            return slow;
        }
奇数时中间节点，偶数时后面一个



3、判断一个链表是否有环

//1 思路：二指针，一个一次走一步，一个一次走两步。出现相遇点则有环
    public boolean hasCycle1(ListNode head) {
     if (head == null || head.next == null) return false;
     ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null) {
             slow = slow.next;
             fast = fast.next.next;
             if(slow == fast) return true;
        }
        return false;
    }
4、链表中有环，找到环开始的节点
/**
 *
思路1、假设x为从头结点到环开始的节点的距离，k为从环开始节点到相遇节点的距离，y为环的长度。
两个指针slow fast，slow每次走一步，fast每次走两步，则有
t = X + nY + K
2t = X + mY + K
化简可以得到：
X+K  =  (m-2n)Y   即 (k=y-x)
或者X = (Y - K) + (m - 2n - 1)Y
则可以得到 ：从相遇节点往下走到环的开始节点的距离和从head节点到环的开始节点的距离相等。
 */
     //1
     public ListNode detectCycle(ListNode head) {
          ListNode fast=head;
          ListNode slow=head;
          while(fast!=null&&fast.next!=null){
              slow=slow.next;
              fast=fast.next.next;
              if(fast==slow){
                   break;
              }
          }
          if(fast==null||fast.next==null){
              return null;
          }
          //走到这里说明有环
          slow=head;
          while(slow!=fast){
              slow=slow.next;
              fast=fast.next;
          }
     return slow;
    }

5、每次翻转k个

注意点：需要保存翻转的开始以及结束节点

public ListNode swapPairs(ListNode head) {
        // Write your code here
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        dummy.next = head;
        ListNode p1 = dummy.next;
        ListNode p2 = dummy.next.next;
        while (p1 != null && p2 != null) {
            ListNode temp = p2.next;
            p.next = p2;
            p2.next = p1;
            p1.next = temp;

            if (temp == null) {
                break;
            }
            p1 = temp;
            p2 = temp.next;
            p = p.next.next;
        }

        return dummy.next;
    }

 public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k < 1) {
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while (p.next != null) {
            int n = k;
            ListNode q = p.next;
            ListNode start = p.next;
            while (q != null && n  > 1) {
                q = q.next;
                n--;
            }
            if (n > 1 || q == null) {
                break;
            } else {
                ListNode end = q.next;
                ListNode newhead = null;
                ListNode newend = start;
                while (start != end) {
                    ListNode t = start.next;
                    start.next = newhead;
                    newhead = start;
                    start = t;
                } //拼接新的头、尾，把当前游标移动到新的尾。
                p.next = newhead;
                newend.next = end;
                p = newend;
            }
        }
        return dummy.next;
    }

6、合并n个有序链表
 public ListNode mergeKLists(List<ListNode> lists) {
        // write your code here
        if (lists == null || lists.size() == 0) {
            return null;
        }
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        Queue<ListNode> queue = new PriorityQueue<ListNode>(lists.size(), new Comparator<ListNode>()
        {   
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val;
            }
        });
        for (ListNode node : lists) {
            if (node != null) {
                queue.offer(node);
            }
        }
        while (!queue.isEmpty()) {
             ListNode node = queue.poll();
                 p.next = node;
                 if (node.next != null) {
                     queue.offer(node.next);
                 }
                 p = p.next;
        }
        return dummy.next;
    }


```