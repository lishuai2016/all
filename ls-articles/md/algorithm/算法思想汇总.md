# 算法设计中的常用方法
迭代法、穷举搜索法、递推法、贪婪法、回溯法、分治法、动态规划法（一维DP，二维DP）

- 1、贪心算法
- 2、动态规划
- 3、回溯法（深度优先）
- 4、分支限界法（广度优先）
- 4、分治算法

# 1、贪心算法

所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，
他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，
但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。

一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。

贪心算法应用：1.最小生成树之Prim算法 2. 最小生成树之kruskal算法


# 2、动态规划

## 最优化原理”(Principle of optimality)

“一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，
其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略”。
简言之，一个最优策略的子策略，对于它的初态和终态而言也必是最优的。
这个“最优化原理”如果用数学化一点的语言来描述的话，就是：
假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，如若这个决策序列是最优的，
对于任何一个整数k，1 < k < n，不论前面k个决策是怎样的，以后的最优决策只取决于由前面决策所确定的当前状态，
即以后的决策Dk+1，Dk+2，…，Dn也是最优的。

最优化原理是动态规划的基础，任何一个问题，如果失去了这个最优化原理的支持，就不可能用动态规划方法计算。
能采用动态规划求解的问题都需要满足一定的条件：

(1) 问题中的状态必须满足最优化原理；

(2) 问题中的状态必须满足无后效性。

所谓的无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结”。



## 问题求解模式

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。
这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。
如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。
初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。
在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。


(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。
当然，状态的选择要满足无后效性。


(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，
状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。
但事实上常常是反过来做，根据相邻两段各状态之间的关系来确定决策。


(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

## 算法实现

动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。
使用动态规划求解问题，最重要的就是确定动态规划三要素：
问题的阶段,每个阶段的状态以及从前一个阶段转化到后一个阶段之间的递推关系。
递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，
不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，
有递归不可比拟的优势，这也是动态规划算法的核心之处。
确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，
其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值
（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，
依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。
下面分别以求解最大化投资回报问题和最长公共子序列问题为例阐述用动态规划算法求解问题的一般思路。

动态规划法的应用：
1.动态规划求0/1背包问题 
2.最长公共子串问题的实现 
3. 用动态规划实现导弹拦截 
4.最大化投资回报问题的实现

# 3、回溯法（深度优先）

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，
发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，
而满足回溯条件的某个状态的点称为“回溯点”。


用回溯法解题的一般步骤：

（1）针对所给问题，定义问题的解空间；

（2）确定易于搜索的解空间结构；

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。



回溯法应用：
1.回溯法之数的划分              
2.回溯法求解 运动员最佳配对问题
3.回溯法解决汽车加油次数最少问题 
4. 用回溯法找出n个自然数中取r个数的全排列

# 4、分支限界法（广度优先）

基本思想 ：分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。


在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。
在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。
 此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。
 这个过程一直持续到找到所需的解或活结点表为空时为止。


常见的两种分支限界法：

（1）队列式(FIFO)分支限界法

按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。


（2）优先队列式分支限界法

按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。


分支限界法与回溯法的不同:

（1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，
而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。


（2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，
而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。



分支限界法应用：
1.分支限界法之装载问题      
2. 分支限界法之布线问题
3. 分支限界法之0 1背包问题
4. 分支限界法之旅行售货员问题

# 5、分治算法（常用递归）

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

分治法所能解决的问题一般具有以下几个特征：

1) 该问题的规模缩小到一定的程度就可以容易地解决


2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（前提）


3) 利用该问题分解出的子问题的解可以合并为该问题的解；（最关键的一点）

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。


上述的第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；
第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；
第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，
而不具备第三条特征，则可以考虑用贪心法或动态规划法。第四条特征涉及到分治法的效率，
如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，
但一般用动态规划法较好。

分治法的基本步骤

分治法在每一层递归上都有三个步骤：


1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

2)解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

3)合并：将各个子问题的解合并为原问题的解。

分治法的应用：
1.递归与HANOI塔问题； 
2.二分法求方程近似解 
3.用C++实现合并排序 
4.求最大值和最小值的分治算法

快速排序和归并排序




算法概念：
1、摩尔投票算法（先找出现次数较多的元素）

摩尔投票算法的思想是，首先定义一个majority和一个count，majority用来存放当前出现次数最多的数。如当majority等于第一个数后，count=1；然后majority与第二个数比较，如果相等，则count+1，否则count-1，如果减到count=0的时候，则说明该数在出现的当前序列已经不是出现次数最多的了，因此替换为当前的数。然后继续比较下去。最后同样要对得出来的数进行检验。


2、鸽笼原理
鸽笼原理 （抽屉原理） “如果有五个鸽子笼，养鸽人养了6只鸽子，那么当鸽子飞回笼中后，至少有一个笼子中装有2只或2只以上鸽子

3、 回溯法

回溯法（backtracking）是一种系统地搜索问题解的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。

当问题是要求满足某种性质（约束条件）的所有解或最优解时，往往使用回溯法。 它有“通用解题法”之美誉。


用回溯法解题的一般步骤：
（1）针对所给问题，定义问题的解空间；
（2）确定易于搜索的解空间结构；
（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

主要用于解决两类问题：
（1）. 子集树
       所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间成为子集树。如0-1背包问题，从所给重量、价值不同的物品中挑选几个物品放入背包，使得在满足背包不超重的情况下，背包内物品价值最大。它的解空间就是一个典型的子集树。
（2）. 排列树
      所给的问题是确定n个元素满足某种性质的排列时，相应的解空间就是排列树。
如旅行售货员问题，一个售货员把几个城市旅行一遍，要求走的路程最小。它的解就是几个城市的排列，解空间就是排列树。

下面介绍回溯法的一般实现框架：

bool finished = FALSE; /* 是否获得全部解? */
backtrack(int a[], int k, data input)
{
    int c[MAXCANDIDATES]; /*这次搜索的候选 */
    int ncandidates; /* 候选数目 */
    int i; /* counter */
    if (is_a_solution(a,k,input))
    process_solution(a,k,input);
    else {
        k = k+1;
        construct_candidates(a,k,input,c,&ncandidates);
        for (i=0; i<ncandidates; i++) {
            a[k] = c[i];
            make_move(a,k,input);
            backtrack(a,k,input);
            unmake_move(a,k,input);
            if (finished) return; /* 如果符合终止条件就提前退出 */
        }
    }
}

　　对于其中的函数和变量，解释如下：

　　a[]表示当前获得的部分解；

　　k表示搜索深度；

　　input表示用于传递的更多的参数；

　　is_a_solution(a,k,input)判断当前的部分解向量a[1...k]是否是一个符合条件的解

　　construct_candidates(a,k,input,c,ncandidates)根据目前状态，构造这一步可能的选择，存入c[]数组，其长度存入ncandidates

　　process_solution(a,k,input)对于符合条件的解进行处理，通常是输出、计数等

　　make_move(a,k,input)和unmake_move(a,k,input)前者将采取的选择更新到原始数据结构上，后者把这一行为撤销。


　　其实回溯法框架就是这么简单，通过这个框架，足以解决很多回溯法问题了。不信？下面展示一下：

4、深度优先算法（DFS ）

深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法

5、广度优先遍历(BFS）



6、DP动态规划（求最优解）

当前n的最优解只取决于之前的n-1，和n-1之前以及n之后都没关系

将一个问题分解为子问题递归求解（小问题按阶段分），并且将中间结果保存以避免重复计算的办法，就叫做“动态规划”。
7、分治算法

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

分治法所能解决的问题一般具有以下几个特征：

1) 该问题的规模缩小到一定的程度就可以容易地解决


2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（前提）


3) 利用该问题分解出的子问题的解可以合并为该问题的解；（最关键的一点）

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。



例子：
排序算法(快速排序，归并排序)
8、贪心算法
贪心算法
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解
9\图论

最短路径算法



