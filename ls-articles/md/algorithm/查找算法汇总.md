# 查找算法

[常见的查找算法](https://www.open-open.com/solution/view/1410494404789)
[程序员必须知道的8大排序和3大查找](https://www.cr173.com/html/15301_all.html)
[七大查找算法](https://www.tuicool.com/articles/f2y63i7)

1、顺序查找N
2、二分查找 logN
3、分块查找
4、哈希查找
5、二叉树查找 logN

典型的查找算法

查找：

只进行查找的称为静态查找表；

在查找的过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的元素，称为动态查找表。

静态查找：

1.顺序查找：

算法思想：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功

平均查找长度：（n+1）/2

2、二分查找（有序表）：

算法思想：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。

平均查找长度：（n+1）/n *log2(n+1) -1

3、分块查找（索引顺序查找）：

算法思想：首先将一个线性表（即主表）按照一定的函数关系和条件划分为若干个逻辑字表，为每个字表建立一个索引项，由所有的字表的索引项构成一个索引表。当进行分块查找时，先根据所给的关键字查找索引表，从中找出给定k值小于或等于索引值的那个索引块，找到待查块，然后在主表中查找该快，查找待查的记录。

平均查找长度：索引表是有序的，所以在索引表中可以用顺序查找，也可以用折半查找；而块内的记录的随机排序的，所以在块中用顺序查找。

顺序查找确定块：平均查找长度为1/2 *(n/s +s)+1

二分查找确定块：平均查找长度为log2（n/s +1）+s/2

动态查找：（表结构动态生成）

http://www.doc88.com/p-930477746758.html

1、二叉排序树查找

二叉排序树（二叉搜索树、二叉查找树）：二叉排序树中序遍历得到的必定是一个有序序列。

查找过程：

（1）若查找树为空，查找失败；

（2）若查找树非空，将给定值和查找树的根节点比较：

     若相等，查找成功，结束查找过程；

     若给定值小于根节点，查找将在根节点的左子树上继续进行，转至（1）

     若给定值大于根节点，查找将在根节点的右字树上继续进行，转至（1）

时间复杂度：平均O(logn)，最坏O(n)

二叉排序树的插入：

新插入的结点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。

二叉排序树的结点删除：

假设在二叉排序树上被删结点为p，其双亲结点为f，且p为f的左孩子，下面分三种情况讨论：

（1）若p结点为叶子节点，即pl和pr均为空树，由于删去叶子节点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。

（2）若p结点只有左子树pl或者只有右子树pr，此时只要令pl和pr直接成为其双亲结点f的左子树即可。

（3）若p结点的左子树和右子树均不空。

2、二叉平衡树

左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1.若将二叉树上结点的平衡因子定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只能是-1,1,0.平衡树查找的时间复杂度为O()logn


## 二分查找
```java
public class Erfen {

    /**
     * @param args
     */
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,3,4,5,6,7,8,9,10};
System.out.println(erfen(arr,11,0,9));
System.out.println(erfen1(arr,11));
    }
    //递归
    public static int erfen(int[] arr,int target,int start,int end) {
        if (start > end) {
            return -1;
        }
        int mid = (end - start) / 2 + start;
        if (arr[mid] == target) {
            return mid;
        } else if(arr[mid] < target) {
            return erfen(arr,target,mid + 1,end);
        } else {
            return erfen(arr,target,start,mid - 1);
        }
    }
    //迭代
    public static int erfen1(int[] arr,int target) {
        int l = 0;
        int r = arr.length - 1;
        while (l <= r) {
            int mid = l + (r - l) /2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target){
                l = mid + 1;
            } else {
                r = mid -1;
            }
        }
        return -1;
    }


}

```

## 分块查找
分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

算法思想： 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；
即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；
而第2块中任一元素又都必须小于第3块中的任一元素，……

算法流程：

step1 先选取各块中的最大关键字构成一个索引表；

step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。

它的性能介于顺序查找和二分查找之间。



## 哈希查找（使用键作为索引）
哈希查找。通过计算数据元素的存储地址进行查找
哈希查找的操作步骤：
⑴用给定的哈希函数构造哈希表
⑵根据选择的冲突处理方法解决地址冲突⑶在哈希表的基础上执行哈希查找。 

建立哈希表操作步骤： 
①取数据元素的关键字key，计算其哈希 函数值。若该地址对应的存储 空间还没有被占用，则将该元素存入；否则执行step2解决冲突。 *
②根据选择的冲突处理方法，计算关键字 key的下一个存储地址。若下一个存储地 址仍被占用，则继续执行step2，直到找 到能用的存储地址为止。


```

public static int HashSearch(int[] sz, int key) {
    int mod = 15;// 大于或等于数组长度
    int[] hash = new int[mod];
    BuildHash(sz, hash);
    int hashAddress = key % mod;
    while (hash[hashAddress] != 0 && hash[hashAddress] != key) {
        hashAddress = (++hashAddress) % mod;
    }
    if (hash[hashAddress] == 0) {
        return -1;
    }
    return hashAddress;
}

public static void BuildHash(int[] sz, int[] hash) {
    int mod = hash.length;
    for (int i = 0; i < sz.length; i++) {
        int hashAddress = sz[i] % mod;
        while (hash[hashAddress] != 0) {// 如果对应的地址已经有值，则使用开放地址法解决
            hashAddress = (++hashAddress) % mod;
        }
        hash[hashAddress] = sz[i];
    }
}


```



排序和查找


1、合并另个有序数组A,B（ 其中A中有足够的空间存放结果）
倒着合并即可
2、对字符串数组进行排序，将所有的变位词排在相邻的位置



3、在一个排序后的数组经过旋转多次后，找一个元素（按照从小到大的排列顺序）

4、设想你有一个20GB的文件，每一行是一个字符串。如何对文件进行排序

5、有一个排序后的字符串数组，其中散布者一些空的字符串，找到给定的字符串的位置


6、给定一个M*N的矩阵，每一行、每一列都是按照升序排列，找出某个元素


7最长递增的子序列

8
