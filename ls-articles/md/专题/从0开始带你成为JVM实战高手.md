
<!-- TOC -->

- [001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！](#001开篇词jvm优化实战广大java工程师心中永远的痛)
- [002、一探究竟：我们写的Java代码到底是如何运行起来的？](#002一探究竟我们写的java代码到底是如何运行起来的)
- [003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？](#003面试官对于-jvm-类加载机制的猛烈炮火你能顶住吗)
- [004、大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？](#004大厂面试题jvm中有哪些内存区域分别都是用来干嘛的)
- [005、JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？](#005jvm的垃圾回收机制是用来干嘛的为什么要垃圾回收)
- [006、第1周作业：不借助任何资料，画出JVM整体运行原理图！](#006第1周作业不借助任何资料画出jvm整体运行原理图)
- [007、第1周答疑：本周问题统一答疑](#007第1周答疑本周问题统一答疑)
- [008、聊聊JVM分代模型：年轻代、老年代、永久代](#008聊聊jvm分代模型年轻代老年代永久代)
- [009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？](#009大厂面试题你的对象在jvm内存中如何分配如何流转的)
- [010、动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？](#010动手实验亲自感受一下线上系统部署时如何设置jvm内存大小)
- [011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？](#011案例实战每日百万交易的支付系统如何设置jvm堆内存大小)
- [012、案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？](#012案例实战每日百万交易的支付系统jvm栈内存与永久代大小又该如何设置)
- [013、第2周作业：看看你们的线上系统是如何设置JVM内存大小的？](#013第2周作业看看你们的线上系统是如何设置jvm内存大小的)
- [014、第2周答疑：本周问题答疑，上周作业点评](#014第2周答疑本周问题答疑上周作业点评)
- [015、大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？](#015大厂面试题什么情况下jvm内存中的一个对象会被垃圾回收)
- [016、大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？](#016大厂面试题jvm中有哪些垃圾回收算法每个算法各自的优劣)
- [017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？](#017大厂面试题年轻代和老年代分别适合什么样的垃圾回收算法)
- [018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？](#018大厂面试题jvm中都有哪些常见的垃圾回收器各自的特点是什么)
- [019、“Stop the World”问题分析：JVM最让人无奈的痛点！](#019stop-the-world问题分析jvm最让人无奈的痛点)
- [020、第3周作业：自己动手画出各种垃圾回收算法和垃圾回收器的原理图](#020第3周作业自己动手画出各种垃圾回收算法和垃圾回收器的原理图)
- [021、第3周答疑：本周问题答疑，上周作业点评](#021第3周答疑本周问题答疑上周作业点评)
- [022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！](#022一步一图深入揭秘jvm的年轻代垃圾回收器parnew是如何工作的)
- [023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？](#023一步一图那jvm老年代垃圾回收器cms工作时内部又干了些啥)
- [024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？](#024动手实验线上部署系统时如何设置垃圾回收相关参数)
- [025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？](#025案例实战每日上亿请求量的电商系统年轻代垃圾回收参数如何优化)
- [026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？](#026案例实战每日请求上亿的电商系统老年代的垃圾回收参数又该如何优化呢)
- [027、第4周作业：看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？](#027第4周作业看看你们的线上系统是怎么设置的jvm垃圾回收参数设置的合理吗)
- [028、第4周答疑：本周问题统一答疑](#028第4周答疑本周问题统一答疑)
- [029、大厂面试题：最新的G1垃圾回收器的工作原理，你能聊聊吗？](#029大厂面试题最新的g1垃圾回收器的工作原理你能聊聊吗)
- [030、G1分代回收原理深度图解：为什么回收性能比传统GC更好？](#030g1分代回收原理深度图解为什么回收性能比传统gc更好)
- [031、动手实验：线上系统部署如果采用G1垃圾回收器，应该如何设置参数？](#031动手实验线上系统部署如果采用g1垃圾回收器应该如何设置参数)
- [032、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（上）？](#032案例实战百万级用户的在线教育平台如何基于g1垃圾回收器优化性能上)
- [033、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（下）？](#033案例实战百万级用户的在线教育平台如何基于g1垃圾回收器优化性能下)
- [034、第一阶段复习：当你开发完一个系统准备部署上线时，如何设置JVM参数？](#034第一阶段复习当你开发完一个系统准备部署上线时如何设置jvm参数)

<!-- /TOC -->








14
1当前包下的类会覆盖依赖包下的同名类？


21
1新建对象直接可以被分到s区？


# 001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！



# 002、一探究竟：我们写的Java代码到底是如何运行起来的？


我们平时写的Java代码，到底是怎么运行起来的？

针对这个问题，我们来一步一步的分析。

首先假设咱们写好了一份Java代码，那这份Java代码中，是不是会包含很多的“.java”为后缀的代码文件？

比如User.java，OrderService.java，CustomerManager.java

其实咱们Java程序员平时在Eclipse、Intellij IDEA等开发工具中，就有很多类似这样的Java源代码文件。

那么大家现在思考一下，当我们写好这些“.java”后缀的代码文件之后，接下来你要部署到线上的机器上去运行，你会怎么做？

一般来说，都是把代码给打成“.jar”后缀的jar包，或者是“.war”后缀的war包，是不是？

然后呢，就是把你打包好的jar包或者是war包给放到线上机器去部署。

这个部署就有很多种途径了，但是最基本的一种方式，就是通过Tomcat这类容器来部署代码，也可以是你自己手动通过“java”命令来运行一个jar包中的代码。

咱们先用下面这张图，回忆一下这个顺序。

![01_打包](../../pic/2019-08-03-18-16-56.png)


但是实际上这里有一个非常关键的步骤，那就是“编译”

也就是说，在我们写好的“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件，比如“User.class”，“Hello.class”，”Customer.class“。

然后这个“.class”后缀的字节码文件，他才是可以被运行起来的！

所以首先，无论大家对JVM机制是否熟悉，咱们都先来回顾一下这个编译的过程，以及“.class”字节码文件的概念。

来看看下图，一起来感受一下：


![02_编译](../../pic/2019-08-03-18-18-10.png)

接着我们可能就要思考下一个问题：

对于编译好的这些“.class”字节码，是怎么让他们运行起来的呢？

这个时候就需要使用诸如“java -jar”之类的命令来运行我们写好的代码了。

此时一旦你采用“java”命令，实际上此时就会启动一个JVM进程。

这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

所以平时我们写好的某个系统在一台机器上部署的时候，你一旦启动这个系统，其实就是启动了一个JVM，由它来负责运行这台机器上运行的这个系统。

对这个概念，大家一定要先搞清楚。

我们还是用一张图来展示一下，相信大家图文结合，会理解的更好。


![03_jvm](../../pic/2019-08-03-18-19-24.png)



接着下一步，JVM要运行这些“.class”字节码文件中的代码，那是不是首先得把这些“.class”文件中包含的各种类给加载进来？

这些“.class”文件不就是我们写好的一个一个的类吗？对不对？

此时就会有一个“类加载器”的概念。

此时会采用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

我们再看下图。

![04_类加载](../../pic/2019-08-03-18-20-07.png)


接着，最后一步，JVM就会基于自己的字节码执行引擎，来执行加载到内存里的我们写好的那些类了

比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。

他需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中。

大家最后看看下面的图。


![05_执行代码](../../pic/2019-08-03-18-21-13.png)


好，最后我们来对本文小结一下：

所以本文从我们平时写“.java”后缀的源代码开始，一步一步梳理了以下的流程：

写好的代码编译成“.class”后缀的字节码文件

JVM是个什么东西

JVM跟我们平时运行在机器上的系统之间是什么关系

类加载器的概念

针对加载进内存的类进行代码的执行

这就是本文讲解的内容总结，希望大家对这部分内容高屋建瓴的先有一个认识。

另外，最后我给大家留一个思考题：既然“.java”文件可以编译成“.class”文件再运行，那么也肯定可以将“.class”文件反编译成“.java”文件。

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

大家可以思考思考，踊跃提问和发言，明天的文章里，在末尾我会跟大家探讨一下这个问题


> 自己总结

主要详细描述了编写的xxx.java到执行的流程。首先编写的是xxx.java文件，然后经过编译后生成xxx.class文件，封装成x.jar包，当我们执行名称java -jar x.jar，会启动一个jvm，这个jvm进程会把这个jar包的主类的main函数执行，在执行main函数之前需要先由类加载器加载main函数所在的主类，然后在main函数执行的过程中，使用到那个类，然后由类加载器去加载这个类。

![05_执行代码](../../pic/2019-08-03-18-21-13.png)

备注：使用java -jar x.jar执行的时候，需要保证在打这个jar包的时候指定主类的main函数入口。

比如在com.demo.Main类中有主函数mian

```xml
  <build>
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.1.0</version>
        <executions>
            <execution>
                <phase>package</phase>
                <goals>
                    <goal>shade</goal>
                </goals>
                <configuration>
                    <transformers>
                        <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                            <mainClass>com.demo.Main</mainClass>
                        </transformer>
                    </transformers>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
    </build>
```



运行结果：

![](../../pic/2019-08-03-18-41-51.png)



# 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

目录：

前文回顾

JVM在什么情况下会加载一个类？

从实用角度出发，来看看验证、准备和初始化的过程

核心阶段：初始化

类加载器和双亲委派机制

昨日思考题的解答





> 1、前文回顾

咱们今天先来回顾一下昨天讲到的JVM整体的一个运行原理。

我们首先从“.java”代码文件，编译成“.class”字节码文件

然后类加载器把“.class”字节码文件中的类给加载到JVM中

接着是JVM来执行我们写好的那些类中的代码，整体是这么个顺序。

再看看下图，感受一下这个过程：

![05_执行代码](../../pic/2019-08-03-18-21-13.png)

那么今天，我们就来仔细看看上图中的“类加载”这个过程，看看JVM的类加载机制到底是怎么样的？

搞清楚这个过程了，那么以后在面试时，对面试官常问的JVM类加载机制，就能把一些核心概念说清楚了。



> 2、JVM在什么情况下会加载一个类？

其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。

一个类从加载到使用，一般会经历下面的这个过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？

也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。

其实答案非常简单，就是在你的代码中用到这个类的时候。

举个简单的例子，比如下面你有一个类（Kafka.class），里面有一个“main()”方法作为主入口。

那么一旦你的JVM进程启动之后，它一定会先把你的这个类（Kafka.cass）加载到内存里，然后从“main()”方法的入口代码开始执行。

![](../../pic/image.png.png)



我们还是坚持一步一图，大家先看看下图，感受一下：
![](../../pic/2019-08-03-22-13-46.png)


接着假设上面的代码中，出现了如下的这么一行代码：


![](../../pic/2019-08-03-22-14-13.png)


这时可能大家就想了，你的代码中明显需要使用“ReplicaManager”这个类去实例化一个对象，此时必须得把“ReplicaManager.class”字节码文件中的这个类加载到内存里来啊！是不是？

所以这个时候就会触发JVM通过类加载器，从“ReplicaManager.class”字节码文件中加载对应的类到内存里来使用，这样代码才能跑起来。

我们来看下面的图：

![](../../pic/2019-08-03-22-15-13.png)

上面就是给大家举的一个例子，相信非常的通俗易懂。

简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



> 3、从实用角度出发，来看看验证、准备和初始化的过程

其实上面的类加载时机的问题，对于很多有经验的同学来说不是什么问题。

但是对于很多初学者来说，是一个非常重要的需要捋清的概念。

接下来就来简单带着大家，从实用的角度出发，过一下另外三个概念：

验证、准备、初始化

其实对于这三个概念，没太大的必要去深究里面的细节，这里的细节很多很繁琐，对于大部分同学而言，只要脑子里有下面的几个概念就可以了：

（1）验证阶段

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

这个相信很好理解，假如说，你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

所以把“.class”加载到内存里之后，必须先验证一下，校验他必须完全符合JVM规范，后续才能交给JVM来运行。

下面用一张图，展示了这个过程：

![](../../pic/2019-08-03-22-17-22.png)

（2）准备阶段

这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量

比如下面的这个“ReplicaManager”类：

![](../../pic/2019-08-03-22-17-44.png)

假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的

接着就会进行准备工作。

这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间

然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值

比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

整个过程，如下图所示：

![](../../pic/2019-08-03-22-19-02.png)



（3）解析阶段

这个阶段干的事儿，实际上是把符号引用替换为直接引用的过程，其实这个部分的内容很复杂，涉及到JVM的底层

但是注意，同学们，就我本意而言，希望第一周的文章，绝对是浅显易懂的，循序渐进，要保证每个同学都能绝对看懂。

所以针对这个阶段，现在不打算做过深的解读，因为从实用角度而言，对很多同学在工作中实践JVM技术其实也用不到，所以这里大家就暂时知道有这么一个阶段就可以了。

同样，我还是给大家画图展示一下：

![](../../pic/2019-08-03-22-19-26.png)

（4）三个阶段的小结

其实这三个阶段里，最核心的大家务必关注的，就是“准备阶段”

因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要有。



> 4、核心阶段：初始化[这里是类的初始化而不是实例的初始化]

之前说过，在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间

另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

那么什么是类初始化的代码呢？我们来看看下面这段代码：

![](../../pic/2019-08-03-22-20-40.png)

大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

但是在准备阶段会执行这个赋值逻辑吗？

NO！在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。

那么这段赋值的代码什么时候执行呢？答案是在“初始化”阶段来执行。

在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

另外比如下图的static静态代码块，也会在这个阶段来执行。

类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

![](../../pic/2019-08-03-22-21-27.png)

那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

什么时候会初始化一个类？

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

比如下面的代码：

![](../../pic/2019-08-03-22-23-09.png)

如果你要“new ReplicaManager()”初始化这个类的实例，那么会加载这个类，然后初始化这个类

但是初始化这个类之前，发现AbstractDataManager作为父类还没加载和初始化，那么必须先加载这个父类，并且初始化这个父类。

这个规则，大家必须得牢记，再来一张图，借助图片来进行理解：

![](../../pic/2019-08-03-22-24-09.png)




> 5、类加载器和双亲委派机制

现在相信大家都搞明白了整个类加载从触发时机到初始化的过程了，接着给大家说一下类加载器的概念

因为实现上述过程，那必须是依靠类加载器来实现的

那么Java里有哪些类加载器呢？简单来说有下面几种：

（1）启动类加载器

Bootstrap ClassLoader，他主要是负责加载我们在机器上安装的Java目录下的核心类的

相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

那么在你的Java安装目录下，就有一个“lib”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

（2）扩展类加载器

Extension ClassLoader，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

（3）应用程序类加载器

Application ClassLoader，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

（4）自定义类加载器

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

（5）双亲委派机制

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

大家看下图：

![](../../pic/2019-08-03-22-27-18.png)


然后，基于这个亲子层级结构，就有一个双亲委派的机制

什么意思呢？

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，自己找去！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的双亲委派模型：先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

最后，给大家来一张图图，感受一下类加载器的双亲委派模型。

![](../../pic/2019-08-03-22-28-49.png)



> 6、昨日思考题的解答

好！今天的文章看完了，相信大家就能大致推测出昨日的思考题的答案了。

我昨天的问题是：如何对“.class”文件处理保证不被人拿到以后反编译获取公司源代码？

其实认真看完今天的文章，就很简单了。

首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理

现在有很多第三方公司，都是专门做商业级的字节码文件加密的，所以可以付费购买他们的产品。

然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人窃取。

> 7、今日思考题

今天再给大家留一个思考题，相信每个做Java的同学，都知道现在一般用Java开发的Web系统，除非是基于Java写中间件，一般都是采用Tomcat之类的Web容器来部署的。

那么大家想想，Tomcat本身就是用Java写的，他自己就是一个JVM。

我们写好的那些系统程序，说白了，就是一堆编译好的.class文件放入一个war包，然后在Tomcat中来运行的。

那么，Tomcat的类加载机制应该怎么设计，才能把我们动态部署进去的war包中的类，加载到Tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

大家先思考，明天文末会给大家进行梳理并给出答案。





> 自己总结

1、类的加载过程

类的加载时机是在使用的时候才会进行加载。类的加载和初始化过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化。重要的是准备和初始化阶段，准备阶段为类的静态变量等属性分配内存空间，初始化阶段给静态属性进行初始化赋值。[这里的初始化为类的初始化而不是实例的初始化]。

如：![](../../pic/2019-08-03-22-24-09.png)


2、类的双亲委派机制

简单来说就是，当我们的程序运行的时候，当使用到某个类，发现还没有加载，首先会让应用类加载器去加载，应用类加载器再委托扩展类加载器去加载，扩展类加载器委托启动类加载器去加载，到了扩展类加载器这里，它看下java的安装目录/lib下是否有这个类，没有的话让扩展类加载器去加载，扩展类加载器看下/lib/ext目录下是否有这个类，没有的话再让应用类加载器去加载，如果应用类加载器也没有就会报错，找不到这类。

第一个方向的委托加载：应用类加载器--->扩展类加载器--->启动类加载器

第二个方向的当前类加载器加载不到，下放加载:启动类加载器--->扩展类加载器--->应用类加载器


![](../../pic/2019-08-03-22-28-49.png)

3、类的加载和初始化时机[类加载了为什么会存在不进行初始化]

- 类加载：使用的时候才会加载

- 类的初始化

我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定 会立即初始化。

补充类初始化的时机如下：

- 1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

- 2.当调用某个类的静态方法时

- 3.当使用某个类或接口的静态字段时

- 4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

- 5.当初始化某个子类时

- 6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)
 
 不满足上面6种情况，也就没有做初始化





> 问题：

- 1、类的class对象是什么时候生成的？存在哪里，堆内存？

- 2、当我们使用一个类的时候如何得知这个类已经被加载了？是通过去方法区看下有没有吗？这个判断如何做的？每个类加载器如何维护自己加载的类？这个双亲委派机制应该是父加载器的优先级比较高，先去父加载器找是否加载了，没有加载继续往上传递，直达最上面，然后看自己能否加载，加载不了才一级一级往下找子加载器去加载，我觉得加载类的过程分为两步，第一逐层判断是否已经加载了类，第二步在看自己是否可以加载，加载不了再逐层下放？在jvm中应该是通过类加载器+类全限定名唯一确认一个类？

- 3、每个类加载器只会加载自己对应类路径下的class文件？



# 004、大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？

目录：

前文回顾

大厂面试背景引入

到底什么是JVM的内存区域划分？

存放类的方法区

执行代码指令用的程序计数器

Java虚拟机栈

Java堆内存

核心内存区域的全流程串讲

其他内存区域

本文小结

昨日思考题解答

今日思考题



> 1、前文回顾

上一篇文章我们聊了一下JVM类加载这块的机制，先简单回顾一下。

大家需要搞明白的是，在什么情况下会触发类的加载？加载之后的验证、准备和解析分别是干什么的？

尤为重要的是准备阶段和初始化阶段，是如何为类分配内存空间的？然后类加载器的规则是什么？

来看一下上篇文章的图，简单回顾一下。

![](../../pic/2019-08-03-22-28-49.png)



> 2、大厂面试背景引入

很多人想要到阿里、美团、京东等互联网大公司去面试，但是现在互联网大厂面试一般都必定会考核JVM相关的知识积累

所以在了解完了JVM的类加载机制之后，先一起来看看JVM的内存区域划分，这个基本上是互联网公司面试必问。



> 3、到底什么是JVM的内存区域划分？

其实这个问题非常简单，JVM在运行我们写好的代码时，他是必须使用多块内存空间的，不同的内存空间用来放不同的数据，然后配合我们写的代码流程，才能让我们的系统运行起来。

举个最简单的例子，比如咱们现在知道了JVM会加载类到内存里来供后续运行，那么我问问大家，这些类加载到内存以后，放到哪儿去了呢？想过这个问题吗？

所以JVM里就必须有一块内存区域，用来存放我们写的那些类。

我们来看下面的图：

![](../../pic/2019-08-03-23-13-51.png)

继续来看，我们的代码运行起来时，是不是需要执行我们写的一个一个的方法？

那么运行方法的时候，方法里面有很多变量之类的东西，是不是需要放在某个内存区域里？

接着如果我们写的代码里创建一些对象，这些对象是不是也需要内存空间来存放？

同样的，大家看下图：

![](../../pic/2019-08-03-23-14-22.png)


这就是为什么JVM中必须划分出来不同的内存区域，它是为了我们写好的代码在运行过程中根据需要来使用的。

接下来，我们就依次看看JVM中有哪些内存区域。



> 4、存放类的方法区

这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。

主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。

但是在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

举个例子，还是跟我们之前说的那样，假设我们有一个“Kafka.class”类和“ReplicaManager.class”类，类似下面的代码。

![](../../pic/2019-08-03-23-15-16.png)


这两个类加载到JVM后，就会放在这个方法区中，大家看下图：

![](../../pic/2019-08-03-23-15-28.png)


> 5、执行代码指令用的程序计数器

继续假设我们的代码是如下所示：

![](../../pic/2019-08-03-23-15-57.png)



之前给大家讲过，实际上上面那段代码首先会存在于“.java”后缀的文件里，这个文件就是java源代码文件。

但是这个文件是面向我们程序员的，计算机他是看不懂你写的这段代码的。

所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。

这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算器可以理解的一种语言，而不是我们写出来的那一堆代码。

字节码看起来大概是下面这样的，跟上面的代码无关，就是一个示例而已，给大家感受一下。

```java
public java.lang.String getName();
     descriptor: ()Ljava/lang/String;
     flags: ACC_PUBLIC
     Code:
         stack=1, locals=1, args_size=1
             0: aload_0
             1: get_field    #2
             4: areturn
```


这段字节码就是让大家知道“.java”翻译成的“.class”是大概什么样子的。

比如“0: aload_0”这样的，就是“字节码指令”，他对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。

比如字节码指令可能会让计算机从内存里读取某个数据，或者把某个数据写入到内存里去，都有可能，各种各样的指令就会指示计算机去干各种各样的事情。

所以现在大家首先明白一点：我们写好的Java代码会被翻译成字节码，对应各种字节码指令

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的字节码执行引擎，去执行我们写的代码编译出来的代码指令，如下图。

![](../../pic/2019-08-03-23-17-15.png)


那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

我们通过一张图来说明：

![](../../pic/2019-08-03-23-17-42.png)


大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令

因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了

下图更加清晰的展示出了他们之间的关系。

![](../../pic/2019-08-03-23-18-07.png)


> 6、Java虚拟机栈

Java代码在执行的时候，一定是线程来执行某个方法中的代码

哪怕就是下面的代码，也会有一个main线程来执行main()方法里的代码

在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

![](../../pic/2019-08-03-23-18-39.png)

但是在方法里，我们经常会定义一些方法内的局部变量

比如在上面的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的，关于这个对象我们先别去管他，先来看方法和局部变量。

因此，JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈

每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。

如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧

栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西，这里大家先不用全都理解，我们先关注局部变量。

比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈

同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量

上述过程，如下图所示：

![](../../pic/2019-08-03-23-21-03.png)

然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad”

![](../../pic/2019-08-03-23-21-40.png)


那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

整个过程如下图所示：

![](../../pic/2019-08-03-23-21-55.png)

接着如果“loadReplicasFromDisk”方法调用了另外一个“isLocalDataCorrupt()”方法 ，这个方法里也有自己的局部变量

比如下面这样的代码：

![](../../pic/2019-08-03-23-22-36.png)



那么这个时候会给“isLocalDataCorrupt”方法又创建一个栈帧，压入线程的Java虚拟机栈里。

而且“isLocalDataCorrupt”方法的栈帧的局部变量表里会有一个“isCorrupt”变量，这是“isLocalDataCorrupt”方法的局部变量

整个过程，如下图所示：

![](../../pic/2019-08-03-23-23-02.png)

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。

上述就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈

在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。

咱们再来看一个图，了解一下每个线程在执行代码时，除了程序计数器以外，还搭配了一个Java虚拟机栈内存区域来存放每个方法中的局部变量表。

![](../../pic/2019-08-03-23-23-42.png)



> 7、Java堆内存

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。

此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如下面的代码：

![](../../pic/2019-08-03-23-24-15.png)



上面的“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，如下面的代码所示。

这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。

类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。

![](../../pic/2019-08-03-23-25-10.png)



Java堆内存区域里会放入类似ReplicaManager的对象，然后我们因为在main方法里创建了ReplicaManager对象的，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址

相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象

还是给大家来一张图，更加清晰一些：

![](../../pic/2019-08-03-23-26-32.png)



> 8、核心内存区域的全流程串讲

其实我们把上面的那个图和下面的这个总的大图一起串起来看看，还有配合整体的代码，我们来捋一下整体的流程，大家就会觉得很清晰。

![](../../pic/2019-08-03-23-27-44.png)

![](../../pic/2019-08-03-23-30-22.png)

首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。

main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

大家结合上图中的程序计数器来理解一下。

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

看到这里，大家结合上面的两个图理解一下。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了



> 9、其他内存区域

其实在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库

比如下面这样的：public native int hashCode();

在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

还有一个区域，是不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。



> 10、本文小结

本文到这里就结束了，基本上把JVM里的核心内存区域的功能解释清楚了

大家需要重点去关注方法区、程序计数器、Java虚拟机栈和Java堆这些内存区域的作用，和我们配套的图以及代码结合起来去理解。



> 11、昨日思考题解答

昨天让大家去思考一下：Tomcat这种Web容器中的类加载器应该如何设计实现？

这里给大家一个简单的思路给回复。

首先Tomcat的 类加载器体系如下图所示，他是自定义了很多类加载器的。

![](../../pic/2019-08-03-23-30-50.png)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。

然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类

至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。

而且大家一定要记得，Tomcat是打破了双亲委派机制的

每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。

如果大家感兴趣，可以自己找资料去学习研究Tomcat的类加载机制。



> 12、今日思考题

今天我们学习了JVM中的各个内存区域，那么先留给大家一个思考题：

我们在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个压力呢？

大家思考一下，明天的文章末尾会给出答案。




> 自己总结


主要讲解了内存的区域包含哪些：

- 程序计数器，保存当前线程执行到那条字节码了；
- 虚拟机栈，当前线程执行的方法中包含的信息，每个方法是一个栈帧，栈帧中存的是局部变量和方法相关的信息；
- 本地方法栈，保存当前线程的native方法相关信息，同虚拟机栈；

- 方法区/元数据区：保存的类的相关信息
- 堆：保存对象


![](../../pic/2019-08-03-23-27-44.png)

![](../../pic/2019-08-03-23-30-22.png)


> 问题

- 1、一个线程会同时关联一个虚拟机栈和本地方法栈吗？那程序计数器呢？是不是只会有一个程序计数器？即一个线程先调用普通的方法，然后调用到了本地native方法

- 2、栈空间占用的内存在哪里分配？也就是每个线程占用的空间？


# 005、JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？


目录：

前文回顾

对象的分配与引用

一个方法执行完毕后会怎样？

我们创建的Java对象其实都是占用内存资源的

不再需要的那些对象应该怎么处理？

本文小结





> 1、前文回顾

上一篇文章给大家分析了JVM中的几块内存区域分别都是干什么的，今天的文章就给大家初步介绍一下垃圾回收的概念。

但是今天的文章对垃圾回收不会切入过深，因为很多学习专栏的朋友都是一些初学者。

因此，咱们还是那句话，尽量用最通俗的语言配合大量手绘图，让大家初步了解垃圾回收到底是什么。

先来看一下昨天的一张图，回顾一下JVM中几块内存区域的作用。

![](../../pic/2019-08-03-23-27-44.png)


大家脑子里一定要有一个会动的图，你的代码在运行的时候，起码有一个main线程会去执行所有的代码，当然也可能是你启动的别的线程。

然后线程执行时必须通过自己的程序计数器来记录执行到哪一个代码指令了

另外线程在执行方法时，为每个方法都得创建一个栈帧放入自己的Java虚拟机栈里去，里面有方法的局部变量。

最后就是代码运行过程中创建的各种对象，都是放在Java堆内存里的。

结合上面的大图看一看，相信大家一定就明白是怎么回事了，大家对JVM的运行原理也应该都有了一个初步的理解和把握。



> 2、对象的分配与引用

现在我们假设有下面一段代码，大概意思你可以理解为通过“loadReplicasFromDisk”方法的执行，去磁盘上加载需要的副本数据

然后通过“ReplicaManager”对象实例完成了这个操作。

代码如下所示：

![](../../pic/2019-08-03-23-46-31.png)

结合我们之前理解过的JVM运行原理，一起通过动态的图来拆解一下上述代码的运行流程。

首先一个main线程肯定会来执行main()方法里的代码

main线程自己是有一个Java虚拟机栈的，他会把main()方法的栈帧压入Java虚拟机栈

如下图所示：

![](../../pic/2019-08-03-23-47-23.png)

接着main()方法里调用了loadReplicasFromDisk()方法

那么就会创建loadReplicasFromDisk()方法的栈帧，压入main线程的Java虚拟机栈里去

这个过程如下图：

![](../../pic/2019-08-03-23-47-42.png)

此时发现在loadReplicasFromDisk()方法里，有一个“repliaManager”变量，那么就会在loadReplicasFromDisk()方法对应的栈帧里，放入一个“repliaManager”变量。

继续看下图：

![](../../pic/2019-08-03-23-48-25.png)

接着发现在代码里创建了一个“ReplicaManager”类的实例对象，此时就会在Java堆内存中分配这个实例对象的内存空间。

同时，让loadReplicasFromDisk()方法的栈帧内的“replicaManager”局部变量去指向那个Java堆内存里的ReplicaManager实例对象，大家看下图：

![](../../pic/2019-08-03-23-48-45.png)

接下来，就会执行通过“replicaManager”局部变量引用的“ReplicaManager”实例对象去执行他的load()方法，去完成我们实现的业务逻辑。

好，到这里为止，其实都是上篇文章讲解过的知识，我们就是重新串联了一遍，相信大家都很好理解。



> 3、一个方法执行完毕之后会怎么样？

接着大家来回顾一下上面的代码。

![](../../pic/2019-08-03-23-46-31.png)

其实目前的图我们已经表述到了“replicaManager.load()”这行代码这里

那么现在有个问题，如果这行代码执行结束了，此时会怎么样？

大家还记得之前文章说过，一旦方法里的代码执行完毕，那么方法就执行完毕了，也就是说loadReplicasFromDisk()方法就执行完毕了。

一旦你的loadReplicasFromDisk()方法执行完毕，此时就会把loadReplicasFromDisk()方法对应的栈帧从main线程的Java虚拟机栈里出栈

如下图所示：

![](../../pic/2019-08-03-23-49-53.png)

此时一旦loadReplicasFromDisk()方法的栈帧出栈，那么大家会发现那个栈帧里的局部变量，“replicaManager”，也就没有了。

也就是说，没有任何一个变量指向Java堆内存里的“ReplicaManager”实例对象了。



> 4、我们创建的Java对象其实都是占用内存资源的

核心点来了，此时大家发现了，Java堆内存里的那个“ReplicaManager”实例对象已经没有人引用他了

这个对象实际上已经没用了，该干的事儿都干完了，现在你还让他留在内存里干啥呢？

大家要知道，内存资源是有限的。

一般来说，我们会在一台机器上启动一个Java系统，机器的内存资源是有限的，比如就4个G的内存

然后我们启动的Java系统本质就是一个JVM进程，他负责运行我们的系统的代码，这个之前都解释过了。

那么这个JVM进程本身也是会占用机器上的部分内存资源，比如占用2G的内存资源。

那么我们在JVM的Java堆内存中创建的对象，其实本质也是会占用JVM的内存资源的，比如“ReplicaManager”实例对象，会占用500字节的内存。

所以大家看到这里，心中应该无比明白的一个核心点：我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

大家看下面的图，感受会深一点。

![](../../pic/2019-08-03-23-53-12.png)


> 5、不再需要的那些对象应该怎么处理？

继续思考上面的图，既然“ReplicaManager”对象实例是不需要使用的，已经没有任何方法的局部变量在引用这个实例对象了，而且他还空占着内存资源，那么我们应该怎么处理呢？

答案呼之欲出：JVM的垃圾回收机制

JVM本身是有垃圾回收机制的，他是一个后台自动运行的线程

你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。

这个线程会在后台不断检查JVM堆内存中的各个实例对象

还是给大家画一张图，来看看这个过程：

![](../../pic/2019-08-03-23-53-48.png)

如果某个实例对象没有任何一个方法的局部变量指向他，也没有任何一个类的静态变量，包括常量等地方在指向他。

那么这个垃圾回收线程，就会把这个没人指向的“ReplicaManager”实例对象给回收掉，从内存里清除掉，让他不再占用任何内存资源。

这样的话，这些不再被人指向的对象实例，即JVM中的“垃圾”，就会定期的被后台垃圾回收线程清理掉，不断释放内存资源

大家看下图：

![](../../pic/2019-08-03-23-54-16.png)

到此为止，相信大家跟上文章思路一路看下来，就很清晰明了。到底什么是JVM中的“垃圾”？什么又是JVM的“垃圾回收”！



> 6、本文小结

不知不觉，第一周的文章都更新完毕了，希望大家温故而知新。

既然是付费来学习知识的，一定要对自己负责，坚持把每篇文章多看几遍，把知识吃透。

这周，我们为了照顾很多JVM的小白同学，从0起步，用最通俗易懂的语言和一步一图的方式，把你写好的Java代码如何通过JVM运行起来的核心原理都讲清楚了。

目前为止，大家应该对JVM的核心运行流程、JVM的类加载机制、JVM的内存区域以及垃圾回收机制都有一个初步的了解。

很多对JVM有一定了解的朋友一定会说：这些内容都很简单，有没有深入点的干货？

有！但是请不要着急，我们的专栏是兼顾各种基础的朋友，所以需要循序渐进，从浅入深。

比如JVM垃圾回收机制，就会在第三周详细讲解JVM的各种垃圾回收的细节

所以请大家稍安勿躁，一步一步来，如果有一定基础的同学，就当做复习一遍。

马上周末就是第一周的作业和答疑集锦了，大家周末记得完成作业，同时看一下每周最新的精华答疑集锦，从答疑中也能学习到一些知识。




> 7、昨日思考题解答

我们回到文章中，昨天给了一个思考题：我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？

这个其实很简单，一个对象对内存空间的占用，大致分为两块：

- 一个是对象自己本身的一些信息

- 一个是对象的实例变量作为数据占用的空间

比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存了。

另外JVM对这块有很多优化的地方，比如补齐机制、指针压缩机制，这块东西我们不会单独拿出来讲，因为比较复杂，而且暂时对大家还不是很需要。

其实我信奉的一个道理，就是用案例实战来说话，引出很多技术和知识点的讲解，所以很多类似的知识，我会在后期大量的案例中去分析，需要的时候再学，效果最好。

这里就是先科普一下，让大家有一个基本的概念，如果有兴趣可以百度资料自己查阅。



> 8、今日思考题

既然今天提到了Java堆内存里的对象会被回收掉，那么加载到方法区的类会被垃圾回收吗？什么时候被回收？为什么呢？

大家可以思考一下这个问题，下周一的文章里会给出解答。


> 自己总结

在程序的运行过程中，我们在方法中会创建对象并赋值给方法内的局部变量，当方法执行完毕，从虚拟机栈出栈，局部变量被销毁，就会造成创建的对象没有再被应用，成为垃圾对象，如果不进行销毁就会占着内存不释放，长时间下去就会造成内存不足，因此需要进行垃圾回收，垃圾回收是一个后台线程进行的，把多余的垃圾对象清理掉。


# 006、第1周作业：不借助任何资料，画出JVM整体运行原理图！

作业内容：

这是我们的专栏第一周的作业，首先我们来简单回顾一下。

这一周，我们从JVM的整体运行原理开始学习，分析了JVM的类加载机制，JVM的内存区域划分以及对应的工作原理，JVM的垃圾回收到底是什么。


那么第一周的作业是什么呢？

很简单，希望大家把第一周的文章反复看几遍，完全做到心里有数

接着在不看任何资料的前提下，自己仿照文章那样，写出来一段代码，然后找一个画图工具，动手画图，把那段代码运行的时候，JVM的整个工作原理画出来。比如：

执行多个方法的调用时，如何把方法的栈帧压入线程的Java虚拟机栈？

栈帧里如何放局部变量？

如何在Java堆里创建实例对象？

如何让局部变量引用那个实例对象？

方法运行完之后如何出栈？

垃圾回收是如何运行的？

希望大家不借助资料，直接根据自己心里对JVM原理的理解，把这个图画出来。

再强调一下，我设计这个专栏的思路，就是每周必须有作业，因为光看不复习，光看不练，看了等于白看。

大家必须跟着完成作业，才能真正把学到的东西吸收成自己的东西，一个专栏跟下来，才能真正积累很多硬核技术。

希望大家周末都抽一点时间，完成本周作业。



# 007、第1周答疑：本周问题统一答疑


下面是本周大家的问题汇总，所有同学都可以看看，边看边思考！



- 问题一

方法走完，引用消失，堆内存还未必消失。好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，请问这种大文件导出怎么破？

答：建议不要在for里创建对象，可以在外面搞一个对象，for循环里对一个对象修改数据即可

- 问题二[每个线程有自己的Java虚拟机栈和本地方法栈]

1.Java支持多线程，每个线程有自己的Java虚拟机栈和本地方法栈，是这样吗？ 

2.新建的实例在堆内存，实例变量也是在堆内存? 是这样吗？

答：1、2两点均理解正确


- 问题四[子类加载的时候，必须先加载父类，初始化父类]

如果是父类子类的情况是下面哪种呢? 加载父类->加载子类->初始化父类->初始化子类, 加载父类->初始化父类->加载子类->初始化子类

答：不是的，加载父类就是父类，除非用到子类才会加载子类；但是加载子类要初始化之前，必须先加载父类，初始化父类

- 问题五

类加载器有三层，如果在第二层的类加载器可以加载这些类的话，就没有必要往上去找他的父类加载吗？[这个问题没有回答？？？]

既然说类只有用到的时候才加载到内存中，那么new对象的时候肯定用到，但是是不是先经历过类的所有过程才将类实例化？

答：没错，必须先加载类，再实例化对象



- 问题七[对象头32位和64位占用的大小不一样]

Object Header（4字节） + Class Pointer（4字节）+ Fields（看存放类型），但是jvm内存占用是8的倍数，所以结果要向上取整到8的倍数

答：很好，就是这样

- 问题八

如果我有一个静态的成员变量int,那我多线程更改是否会有线程安全问题，为什么？

答：静态成员变量，他在内存里，只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。

- 问题九

类加载是按需加载，可以一次性加载全部的类吗？

答：如果是默认的类加载机制，那么是你的代码运行过程中，遇到什么类加载什么类。如果你要自己加载类，那么需要写自己的类加载器

- 问题十

为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？[这个问题感觉回答的不是很好？？？]

答：其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。

至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的父子关系模型

你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

这就是一个代码设计思想，保证代码的可扩展性。

- 问题十一

是在执行new replicamanager()这行代码的时候加载replicamanger类吗？还是说加载cafka的时候就同时加载了呢？

答：执行new ReplicaManager的时候加载类

- 问题十二

还是没有明白 jvm和平时运行在机器上的系统之间是什么关系呢

答：其实很简单，你运行在机器上的系统，其实就是一个JVM进程，JVM进程会执行你系统里写好的那些代码

- 问题十三

class文件分配内存是在准备阶段，那类的class对象是在准备阶段创建的吗？ [类的class对象在什么时候创建并没有回答]

如果实例变量有初始值，那实例变量是和类变量一同在初始化阶段赋值的吗？

初始化之后是不是就有实例了

答：

类是在准备阶段分配内存空间的

实例变量得在你创建类的实例对象时才会初始化

类的初始化阶段，仅仅是初始化类而已，跟对象无关，用new关键字才会构造一个对象出来



- 问题十四

双亲委派可以解决类重复加载的问题。按照文章中介绍每个类加载器有不同的类加载路径，这些类加载路径是否可能重叠？

答：不同类加载器的路径，一般是不会重叠的

- 问题十五

自定义的类加载器本身是由系统加载器加载的，也就是说其本身是没有加密的，那么我拿到该类反编译就可以看到如果解密class文件了，请问老师是这样么？

答：是的，所以说对class文件需要做特殊混淆处理，有商用的产品可以用



- 问题十七

用户使用类的时候应该是希望类已经准备好了一些数据，我猜想jvm设计者设计先执行static代码块的机制，是希望开发者在这里把使用类之前需要准备的工作在这里准备好 

为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？

启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要？

答：

没错，必须有初始化过程，准备好类级别的数据

没错，类在方法区，他在内存里，所以你必须给他初始化，赋值

还是有必要，比如启动类加载器，可以通过一些方式指定加载其他目录的类，那么你必须得走双亲委派，如果对那些特殊区域的类加载，走双亲委派，才能上推到启动类加载器去执行，不会重复加载

- 问题十八

其实初始化时机就是对类的主动使用：调用静态方法时对类的主动使用的一种场景，main方法本质上是个static方法，没有调用的main方法和没有调用的static方法没区别！

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

答：不会的，你启动一个jar包，需要指定某个main主类，优先就是加载他

- 问题十九

tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中

这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了（此问题是003文章底下的评论）

答：非常好的回复，明天文章会给出答案

- 问题二十

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

答：你启动一个jar包的时候，会指定是走哪个main方法所在的类，是唯一的



- 问题二十二

老师好请问类加载双亲委派机制 为什么要先找父加载 而不是自己找？这种设计的好处是？

答：好处就在于，每个层级的类加载器各司其职，而且不会重复加载一个类。

比如你代码里用两个不同层级的类加载器，都去尝试加载了某个类，如果有双亲委派机制，那么都会先找父类加载器去加载，如果加载到了，那么以后就只会是他去加载这个类。

否则如果没有双亲委派机制，那么岂不是两个不同层级的类加载器可以加载同一个类，造成类的重复加载！

- 问题二十三

自定义类加载器如何实现？

答：自己写一个类，继承ClassLoader类，重写类加载的方法，然后在代码里面可以用自己的类加载器去针对某个路径下的类加载到内存里来

- 问题二十四

看到一个词:动态部署，那么是否也有对应的静态部署?如何解释呢？ (谢老师回答)

答：假设一个背景在Tomcat部署系统的话，那么动态部署，也成为热部署

就是直接系统放入Tomcat对应目录，他自动就重新加载你最新的代码给你热部署了，不需要对Tomcat进行停机再重启；

反之，则是先停止Tomcat，然后部署最新代码到Tomcat对应目录里，然后重启Tomcat

- 问题二十五

-XX:+TraceClassLoading 可以看加载了哪些类，动手实验了一下，jre\lib\rt.jar下的类全部加载了，其他都是用到时候加载。

答：没错，明天更新的第三篇文章里，会讲解类加载机制，rt.jar这属于核心类库，属于支撑我们Java系统运行的底层类库，所以他一定会被加载

我们自己写的代码，一般是你代码运行使用到了哪个类，就会去加载哪个类

- 问题二十六

老师，类加载器是把jar包里的所有类一次性全部加载进去吗？

答：不是的，首先加载包含main方法的主类，接着是运行你写的代码的时候，遇到你用了什么类，再加载什么类

- 问题二十七

通过代码混淆机制，加大反编译之后的可读性！ 或者是否可以基于二进制加密呢，学生没用过！

答：其实现在对于这个一般都是用商业产品的，有很多第三方公司提供加密产品，可以百度一下，class文件加密，就可以看到，直接用他们的产品即可

- 问题二十八

Class源文件的保护，可以采用代码混淆技术，方式有很多，如回答区中老师提到的商用加密软件

答：非常好，就是这样

- 问题二十九

看文中内容，是会加载两次字节码吗，第一次加载进jvm，然后程序执行的时候再加载。有点不解！

答：你好，不是加载两次，是JVM先把“.class”字节码文件中的类加载到内存里，然后执行的时候，就直接使用加载好的类即可，不会重复加载

- 问题三十

class文件通过工具可以反编译的，请问有没有方法对class文件进行加密又不影响它的执行。windows桌面程序里一般都是打包成dll文件，java中有没有比较好的方式？

答：可以的，比如jvmti小工具就可以实现class文件的加密

另外其实为了保护源代码安全，有很多商业公司推出了专业级别的class加密产品，可以付费使用。

解密的话一般可以基于自定义的类加载器来实现，在加载类的时候把class给解密，这样就可以保护自己的源代码安全了。

最后，附上两张Tomcat类加载如果按委派模型的加载流程和实际实现的流程（专栏读者所画）

![](../../pic/2019-08-04-00-21-12.png)



Tomcat的真实加载流程：

![](../../pic/2019-08-04-00-21-45.png)




# 008、聊聊JVM分代模型：年轻代、老年代、永久代

目录：

背景引入

大部分对象其实存活周期极短

少数对象是长期存活的

JVM分代模型：年轻代和老年代

为什么要分成年轻代和老年代？

什么是永久代？

上周思考题解答

今日思考题





> 1、背景引入

今天开始，咱们进入第二周的内容，这一周会重点关注JVM内存划分的一些细节。

我会帮助大家更加深入的去理解JVM内存划分的原理细节，以及我们创建的那些对象在JVM中到底是如何分配，如何流动的，这对于大家理解JVM原理有更深一层的帮助。

首先这篇文章作为本周的一个开篇，我们来给大家介绍一下JVM内存的一个分代模型：年轻代、老年代、永久代。

大家现在应该都知道一点，那就是我们在代码里创建的对象，都会进入到Java堆内存中，比如下面的代码：


![](../../pic/2019-08-04-09-35-11.png)



这段代码，我们稍微做了点改动，在main()方法里，会周期新的执行loadReplicasFromDisk()方法，加载副本数据。

首先一旦执行main()方法，那么就会把main()方法的栈帧压入main线程的Java虚拟机栈

如下图。

![](../../pic/2019-08-04-09-36-28.png)


然后每次在while循环里，调用loadReplicasFromDisk()方法，就会把loadReplicasFromDisk()方法的栈帧压入自己的Java虚拟机栈

如下图。

![](../../pic/2019-08-04-09-36-57.png)

接着在执行loadReplicasFromDisk()方法的时候，会在Java堆内存里会创建一个ReplicaManager对象实例

而且loadReplicasFromDisk()方法的栈帧里会有“replicaManager”局部变量去引用Java堆内存里的ReplicaManager对象实例

如下图：

![](../../pic/2019-08-04-09-37-22.png)

然后就会执行ReplicaManager对象的load()方法。



> 2、大部分对象都是存活周期极短的

现在有一个问题，在上面代码中，那个ReplicaManager对象，实际上属于短暂存活的这么一个对象

大家可以观察一下，在loadReplicasFromDisk()方法中创建这个对象，然后执行ReplicaManager对象的load()方法，然后执行完毕之后，loadReplicasFromDisk()方法就会结束。

一旦方法结束，那么loadReplicasFromDisk()方法的栈帧就会出栈，如下图。

![](../../pic/2019-08-04-09-38-27.png)

然后接着上篇文章已经说过，此时一旦没人引用这个ReplicaManager对象了，就会被JVM的垃圾回收线程给回收掉，释放内存空间，如下图。

![](../../pic/2019-08-04-09-38-49.png)

然后在main()方法的while循环里，下一次循环再次执行loadReplicasFromDisk()方法的时候，又会走一遍上面那个过程，把loadReplicasFromDisk()方法的栈帧压入Java虚拟机栈，然后构造一个ReplicaManager实例对象放在Java堆里。

一旦执行完ReplicaManager对象的load()方法之后，loadReplicasFromDisk()方法又会结束，再次出栈，然后垃圾回收释放掉Java堆内存里的ReplicaManager对象。

所以其实这个ReplicaManager对象，在上面的代码中，是一个存活周期极为短暂的对象

可能每次执行loadReplicasFromDisk()方法的时候，被创建出来，然后执行他的load()方法，接着可能1毫秒之后，就被垃圾回收掉了。

所以从这段代码就可以明显看出来，大部分在我们代码里创建的对象，其实都是存活周期很短的。这种对象，其实在我们写的Java代码中，占到绝大部分的比例。



> 3、少数对象是长期存活的

但是我们来看另外一段代码，假如说咱们用下面的这种方式来实现同样的功能：

![](../../pic/2019-08-04-09-40-01.png)



上面那段代码的意思，就是给Kafka这个类定义一个静态变量，也就是“replicaManager”，这个Kafka类是在JVM的方法区里的

然后让“replicaManager”引用了一个在Java堆内存里创建的ReplicaManager实例对象，如下图。

![](../../pic/2019-08-04-09-40-51.png)

接着在main()方法中，就会在一个while循环里，不停的调用ReplicaManager对象的load()方法，做成一个周期性运行的模式。

这个时候，我们就要来思考一下，这个ReplicaManager实例对象，他是会一直被Kafka的静态变量引用的，然后会一直驻留在Java堆内存里，是不会被垃圾回收掉的。

因为这个实例对象他需要长期被使用，周期新的被调用load()方法，所以他就成为了一个长时间存在的对象。

那么类似这种被类的静态变量长期引用的对象，他需要长期停留在Java堆内存里，这这种对象就是生存周期很长的对象，他是轻易不会被垃圾回收的，他需要长期存在，不停的去使用他。



> 4、JVM分代模型：年轻代和老年代

接下来就要进入今天的核心主题了，就是JVM的分代模型，年轻代和老年代。

现在大家已经看到，其实根据你写代码方式的不同，采用不同的方式来创建和使用对象，其实对象的生存周期是不同的。

所以JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

其中年轻代，顾名思义，就是把第一种代码示例中的那种，创建和使用完之后立马就要回收的对象放在里面

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面，大家看下图：

![](../../pic/2019-08-04-09-42-11.png)


比如下面的代码，我们再次来改造一下，再结合图，大家会看的更加的明确一些。

![](../../pic/2019-08-04-09-42-52.png)



上面那段代码稍微复杂了点，我们解释一下

Kafka的静态变量“fetcher”引用了ReplicaFetcher对象，这是长期需要驻留在内存里使用的

这个对象会在年轻代里停留一会儿，但是最终会进入老年代，大家看下图。

![](../../pic/2019-08-04-09-43-09.png)

进入main()方法之后，会先调用loadReplicasFromDisk()方法，业务含义是系统启动就从磁盘加载一次副本数据，这个方法的栈帧会入栈

然后在这个方法里面创建了一个ReplicaManager对象，这个对象他是用完就会回收，所以是会放在年轻代里的，由栈帧里的局部变量来引用

此时对应着下图：

![](../../pic/2019-08-04-09-45-39.png)

然后一旦loadReplicasFromDisk()方法执行完毕了，方法的栈帧就会出栈，对应的年轻代里的ReplicaManager对象也会被回收掉，如下图：

![](../../pic/2019-08-04-09-46-04.png)

但是接着会执行一段while循环代码，他会周期性的调用ReplicaFetcher的fetch()方法，去从远程加载副本数据。

所以ReplicaFetcher这个对象因为被Kafka类的静态变量fetcher给引用了，所以他会长期存在于老年代里的，持续被使用。



> 5、为什么要分成年轻代和老年代？

相信看完这篇文章，大家就一定看明白了，什么样的对象是短期存活的对象，什么样的对象是长期存在的对象，然后如何分别存在于年轻代和老年代里。

那么为什么需要这么区分呢？

因为这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

很多人又会问了，你不是说“ReplicaFetcher”这个长期存在的对象，刚开始也在年轻代，后来才会进入老年代么？那他到底什么时候进入老年代？

别急，明天的文章就会分析这块。

然后还有人还会问了，那么年轻代和老年代分别怎么进行垃圾回收呢？

别急，下周的文章会主要分析垃圾回收这块的原理。这周我们主要关注JVM的内存划分的细节，搞明白对象是如何在不同的内存区域里分配的就可以了，学习要循序渐进。



> 6、什么是永久代？

很简单，JVM里的永久代其实就是我们之前说的方法区

上面那个图里的方法区，其实就是所谓的永久代，你可以认为永久代就是放一些类信息的。

这个话题现在不用过多考虑，后续涉及到的时候，我们会讲到的。



> 7、上周思考题解答

上周留了一个思考题，让大家思考方法区内会不会进行垃圾回收

其实有同学都回答了，非常的好，在以下几种情况下，方法区里的类会被回收。

- 1、首先该类的所有实例对象都已经从Java堆内存里被回收

- 2、其次加载这个类的ClassLoader已经被回收

- 3、最后，对该类的Class对象没有任何引用

满足上面三个条件就可以回收该类了。



> 8、今日思考题

给大家出一个脑筋急转弯，出题思路有点偏：每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？



> 9、自己思考

jvm分代模型的原因是不同的代使用不同的垃圾回收算法，本质是不同的对象生存周期不一样，大部分对象生成以后很快就不再使用成为垃圾对象，只有少数的对象才会长时间存活，被程序不停的使用。

- 年轻代
- 老年代
- 方法区
    类被回收的条件：
    - 1、首先该类的所有实例对象都已经从Java堆内存里被回收
    - 2、其次加载这个类的ClassLoader已经被回收
    - 3、最后，对该类的Class对象没有任何引用[没有调用class的静态变量或静态方法，没有利用反射访问class]




# 009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？


目录：

前文回顾

大部分正常对象都优先在新生代分配内存

到底什么情况下会触发新生代的垃圾回收？

长期存活的对象会躲过多次垃圾回收

老年代会垃圾回收吗？

关于新生代和老年代的对象分配，这就完了吗？

昨日思考题解答

今日思考题



> 1、前文回顾

经过昨天的文章铺垫了一些对象分配的基础知识后，想必大家现在都心里非常有数了，咱们平时代码里创建出来的对象，一般就是两种：

一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收

另外一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用

第一种短期存活的对象，是在Java堆内存的新生代里的。第二种长期存活的对象，是在Java堆内存的老年代里的。这个结论，想必大家都已经理解了

好，那么接下来我们就来聊聊，对象到底什么时候进入新生代？然后什么情况下会进入老年代？

提示一下：本文是建立在大家都绝对理解上文的基础上来写的，上文是结合代码示例来阐述的核心原理，包括对象什么情况下短期存活，什么情况下长期存活。

所以本文就直接通过大量图示来给大家分析对象在内存中的分配机制了，大家务必透彻理解上文。

> 2、大部分正常对象都优先在新生代分配内存

首先我们先来看上篇文章中的一段代码，稍微带着大家来理解一个概念：大部分的正常对象，都是优先在新生代分配内存的。

![](../../pic/2019-08-04-09-58-46.png)



大家还记得上面那段代码吗？虽然我们看代码知道，类静态变量“fetcher”引用的那个“ReplicaFetcher”对象，是会长期存活在内存里的

但是哪怕是这种对象，其实刚开始你通过“new ReplicaFetcher()”代码来实例化一个对象时，他也是分配在新生代里的。

包括在“loadReplicasFromDisk()”方法中创建的“ReplicaManager”实例对象，也都是一样分配在新生代里的

同样，我们以一张图，来展示一下：

![](../../pic/2019-08-04-09-59-13.png)



> 3、到底什么情况下会触发新生代的垃圾回收？

现在咱们来假设一个场景，大家应该都知道，一旦“loadReplicasFromDisk()”方法执行完毕之后，这个方法的栈帧出栈，会导致没有任何局部变量引用那个“ReplicaManager”实例对象了。

此时可能会如下图所示：

![](../../pic/2019-08-04-09-59-47.png)

那么此时就一定会立即发生垃圾回收，去回收掉Java堆内存里那个没人使用的“ReplicaManager”实例对象吗？

NO！大家别想的那么简单了，实际上垃圾回收他也得有点触发的条件。

其中一个比较常见的场景可能是这样的，假设我们写的代码中创建了N多对象，然后导致Java堆内存里囤积了大量的对象。

然后这些对象都是之前有人引用，比如各种各样的方法中的局部变量，但是现在也都没人引用了。

如下图所示：

![](../../pic/2019-08-04-10-00-25.png)

这个时候，如果新生代我们预先分配的内存空间，几乎都被全部对象给占满了！此时假设我们代码继续运行，他需要在新生代里去分配一个对象，怎么办？发现新生代里内存空间都不够了！

这个时候，就会触发一次新生代内存空间的垃圾回收，新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”，他会尝试把新生代里那些没有人引用的垃圾对象，都给回收掉。

比如上图中，那个“ReplicaManager”实例对象，其实就是没有人引用的垃圾对象

此时就会当机立断，把“ReplicaManager”实例对象给回收掉，腾出更多的内存空间，然后放一个新的对象到新生代里去。

包括上图中那大量的实例对象，其实也都没人引用，在这个新生代垃圾回收的过程中，就会把这些垃圾对象也都回收掉。

其实话说回来，大家自己仔细回忆一下，我们在代码中创建的大部分对象，其实都是这种使用之后立马就可以回收掉的生存周期极短的对象，是不是？

可能我们会在新生代里分配大量的对象，但是使用完之后立马就没人引用了，此时新生代差不多满了

然后要分配新的对象的时候，发现新生代内存空间不足，就会触发一次垃圾回收，然后就把所有垃圾对象给干掉，腾出大量的内存空间

如下图所示：

![](../../pic/2019-08-04-10-02-01.png)



> 4、长期存活的对象会躲过多次垃圾回收

接着我们来看下一个问题，上图中大家都注意到了“ReplicaFetcher”实例对象，他是一个长期被“Kafka”类的静态变量“fetcher”引用的长期存活的对象。

所以虽然你的新生代可能随着系统的运行，不停的创建对象，然后让新生代变满，接着垃圾回收一次，大量对象被回收掉

但是你的这个“ReplicaFetcher”对象，他确是一直会存活在新生代里的。

因为他一直被“Kafka”类的静态变量给引用了，所以他不会被回收。那么此时JVM就有一条规定了

如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还是没被回收掉，就说明他已经15岁了。

这是对象的年龄，每垃圾回收一次，如果一个对象没被回收掉，他的年龄就会增加1。

所以如果上图中的那个“ReplicaFetcher”对象在新生代中成功躲过10多次垃圾回收，成为一个“老年人”，那么就会被认为是会长期存活在内存里的对象。

然后他会被转移到Java堆内存的老年代中去，顾名思义，老年代就是放这些年龄很大的对象。

我们再来看一张图：

![](../../pic/2019-08-04-10-02-51.png)



> 5、老年代会垃圾回收吗？

接着下一个问题就是，老年代里的那些对象会被垃圾回收吗？

答案是肯定的，因为老年代里的对象也有可能随着代码的运行，不再被任何人引用了，就需要被垃圾回收。

大家可以思考一下，如果随着类似上面的情况，越来越多的对象进入老年代，一旦老年代也满了，是不是就要对老年代垃圾回收了？

没错，这是肯定的，但是暂时我们先不用过多的去考虑这里的细节，因为这将是下周的主题，下周我们会进行深入剖析。



> 6、关于新生代和老年代的对象分配，这就完了吗？

还有人会说，关于新生代和老年代的对象分配，这就结束了吗？

当然不是，今天这篇文章，仅仅是相较于之前的文章，更进一步给大家分析了一下对象分配的一些机制。

但是其实在对象分配这块，还有很多其他的复杂机制，比如：

新生代垃圾回收之后，因为存活对象太多，导致大量对象直接进入老年代

特别大的超大对象直接不经过新生代就进入老年代

动态对象年龄判断机制

空间担保机制

可能一些JVM书籍会在这里一下把这些复杂的东西都写出来给大家，但是我们的专栏不会是这个思路。

还是那句话，我们的专栏写作思路是循序渐进，从浅入深，通俗易懂，一步一图。

很多底层技术细节，不要在前期铺垫太多，会导致很多同学吃了没法消化

我会结合后续大量案例，结合真实生产问题，把JVM各种底层细节带出来。结合实战食用，效果更佳。

因此第二周，大家对对象内存分配，了解到这个程度就行了，给大家总结一下：

先理解对象优先分配在新生代

新生代如果对象满了，会触发Minor GC回收掉没有人引用的垃圾对象

如果有对象躲过了十多次垃圾回收，就会放入老年代里

如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉

大家通过本文，先理解上面几点即可。



> 7、昨日思考题解答

昨天的思考题，是一个脑筋急转弯，说每个线程执行方法的时候，那些方法对应的栈帧出栈了，那么那里的局部变量需要垃圾回收吗？

其实这是一个偏题，JVM里垃圾回收针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧。

方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。



> 8、今日思考题

今天想给大家出一个预习类的思考题：理解了今天的对象内存分配，垃圾回收以及老年代转移的机制之后。

大家能否结合短生存周期的对象的特点，以及长生存周期的对象的特点，思考一下，看看你们手头正在负责的系统，梳理梳理里面短生存周期的对象都有什么，长生存周期的对象都有什么。

可以在评论区踊跃回复，让大家开始从JVM的角度去思考自己手头负责的系统中的代码是怎么运行的。

> 自己总结

- 对象优先分配在新生代；
- 新生代如果对象满了，会触发Minor GC回收掉没有人引用的垃圾对象；
- 如果有对象躲过了十五次垃圾回收，就会放入老年代里；[可以配置]
- 如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉




# 010、动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？


目录：

前文回顾

跟JVM内存相关的几个核心参数图解

如何在启动系统的时候设置JVM参数？

通过案例，学习参数优化设置的预告

昨日思考题解析

今日思考题



> 1、前文回顾

咱们先简单回顾一下目前为止已经学到的内容，现在大家肯定都知道，我们平时代码里创建的对象，都是优先在新生代分配的

然后随着一些方法执行完毕，大部分新生代里的对象就没有人引用了，就成了垃圾对象，如下图所示：

![](../../pic/2019-08-04-10-07-43.png)

大家可以想象一下，随着代码持续运行，新生代里对象会越来越多，而且里面大部分的对象其实都是那种短生存周期的对象，很快就没有人引用他们了，因此大部分都会是一些垃圾对象。

然后代码继续运行，是不是肯定会创建新的对象分配在新生代里？

肯定是的，所以一旦新生代里内存不够了，就会触发一次Minor GC，把新生代里那些没有人引用的垃圾对象都给回收掉，腾出来内存空间。如下图所示：

![](../../pic/2019-08-04-10-08-08.png)

如果是那种在长周期存活的对象，他在新生代里会持续躲过多次垃圾回收，每躲过 一次垃圾回收，年龄会增长1岁

然后当他成为是十多岁的“老年人”的时候，就会被转移到老年代里去，如下图：

![](../../pic/2019-08-04-10-08-23.png)

好，到此为止，我们撇开一些特殊情况，至少JVM中基本的内存分配原理，大家就搞清楚了

本周最核心的概念，就是让大家屡清楚短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor GC，然后长生存周期的对象如何转移到老年代里去。



> 2、跟JVM内存相关的几个核心参数图解

本文就不涉及到任何原理性的东西了，直接开始逐步给大家讲解JVM的参数如何设置。

在JVM内存分配中，有几个参数是比较核心的，如下所示。

-Xms：Java堆内存的大小

-Xmx：Java堆内存的最大大小

-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了

-XX:PermSize：永久代大小

-XX:MaxPermSize：永久代最大大小

-Xss：每个线程的栈内存大小

下面我们对上述参数来进行一一说明。

-Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。

对于这对参数，通常来说，都会设置为完全一样的大小。大家先不用太过于纠结这里的细节，因为其实JVM里的各种技术细节真的太多了，不能一下子全部都搞定，要随着后续几十个案例，层层铺展开来。

但是至少大家需要清楚，这两个参数，是用来限定Java堆内存的总大小的，如下图。

![](../../pic/2019-08-04-10-09-28.png)


-Xmn，这个参数也是很常见的，他用来设置Java堆内存中的新生代的大小，然后扣除新生代大小之后的剩余内存就是给老年代的内存大小，我们看下图：

![](../../pic/2019-08-04-10-09-50.png)

-XX:PermSize和-XX:MaxPermSize，分别限定了永久代大小和永久代的最大大小

通常这两个数值也是设置为一样的，至于原因，请看后面结合案例的文章分析。

如果是JDK 1.8以后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-XX:MaxMetaspaceSize，但是大家至少得知道，这两个参数限定了永久代的大小，如下图所示：

![](../../pic/2019-08-04-10-10-12.png)

-Xss，这个参数限定了每个线程的栈内存大小

大家都很清楚，每个线程都有一个自己的虚拟机栈，然后每次执行一个方法，就会将方法的栈帧压入线程的栈里，方法执行完毕，那么栈帧就会从线程的栈里出栈，如下图：

![](../../pic/2019-08-04-10-10-30.png)



> 3、如何在启动系统的时候设置JVM参数？

那么现在大家结合图示都知道了JVM内存各个区域的大小该使用什么参数来设置，那么到底怎么设置呢？

现在就带着大家来做一些实验

你要是在Eclipse/IntelliJ IDEA里开发代码的话，如果要在这种开发IDE里启动一个程序，然后设置JVM参数，那么就需要对按照下面的步骤来设置：

首先右击你写好的一个带main()方法的类，他有一个菜单栏，里面有一个“Debug as”选项，鼠标移动进入，会看到一个“Debug Configuration”选项，接着会看到下面的面板。

![](../../pic/2019-08-04-10-10-57.png)

这个面板里有一个“Arguments”的选项，点击他，会看到下面的图。然后在“VM arguments”中输入你的JVM参数即可

比如你可以按照下面的示例来设置，-Xms之类的参数直接后面跟上你要设置的内存大小，多少M即可。

但是-XX:PermSize这种格式的参数，需要跟一个“=”符号，跟上你要设置的内存大小即可。


![](../../pic/2019-08-04-10-11-47.png)


那么如果是在线上部署系统应该如何设置JVM参数呢？

其实都很简单，比如说采用“java -jar”的方式启动一个jar包里的系统，那么就可以采用类似下面的格式：

java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar

如果是现在非常流行的那种启动Spring Boot开发的系统呢？

其实都是类似的，大家自行翻阅一下Spring Boot的文档即可。



> 4、通过案例，学习参数优化设置的预告

明天开始，我们会做发布本专栏的第一个案例，就是百万交易的支付系统案例

通过分析一个支付系统的核心业务流程，然后结合我们学习到的JVM相关的知识，来一步步探究，JVM内存相关的这些核心参数，到底在我们上线一个生产系统的时候，针对预估的并发压力，到底应该如何合理的给出一个未经过调优的比较合理的初始值。

另外我们会分析各种参数在设置的时候有哪些考虑的点，Java堆内存到底需要多大？新生代和老年代的内存分别需要多大？永久代和虚拟机栈分别 需要多大？这些我们都结合案例来一步一步的分析。

其实JVM参数到底该如何设置，一定是根据不同的业务系统他具体的一些场景来调整的，不是说有一个通用的配置和模板，照着设就没问题了，那个思路肯定是不对的，也不能干巴巴的告诉你，这个参数应该这样设置，那个参数应该那样设置。

一切都要从案例出发，结合业务场景来分析。



> 5、昨日思考题解析

昨天让大家结合学到的知识，去分析一下自己手头负责的那些业务系统，哪些是短生存周期的对象，哪些是长生存周期的对象

其实就是让大家开始在脑子里建立起来自己负责的系统在JVM中运行时的一个概念图，要有这个意识，才能更好的进行JVM调优。



> 6、今日思考题

给大家留一个思考题，大家都知道平时我们一般部署Java系统，主要以Tomcat部署Web系统居多，现在还更多的是通过Spring Boot来部署系统。

那么大家可以自行去网上查阅一下，Tomcat、Spring Boot部署启动系统的时候，JVM参数如何设置？

然后大家再看看自己公司手头负责的系统，你们部署系统的时候是通过什么方式来设置JVM参数的？



> 7、自己总结

jvm核心参数：

-Xms：Java堆内存的大小

-Xmx：Java堆内存的最大大小

-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了

-XX:PermSize：永久代大小

-XX:MaxPermSize：永久代最大大小

-Xss：每个线程的栈内存大小


![](../../pic/2019-08-04-10-10-30.png)


# 011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？

目录：

前文回顾

支付系统背景引入

支付的核心业务流程

每日百万交易的支付系统的压力在哪里？

支付系统每秒钟需要处理多少笔支付订单？

每个支付订单处理要耗时多久？

每个支付订单大概需要多大的内存空间？

每秒发起的支付请求对内存的占用

让支付系统运行起来分析一下

对完整的支付系统内存占用需要进行预估

支付系统的JVM堆内存应该怎么设置？

本文总结

昨日思考题解答

今日思考题



> 1、前文回顾

本文是我们专栏的第一个案例，我将用一个每日百万交易的支付系统作为背景，来给大家分析一下，咱们在上线部署一个系统时，应该如何根据系统的业务量来合理的设置JVM的堆内存大小。

通过之前的文章，大家其实都知道我们写好的代码在JVM中运行的基本原理了，而且也知道通过什么参数可以设置JVM各个内存区域的大小。

但单看之前的文章，大家在自己部署一个线上系统的时候，一定还是会两眼一蒙圈，发现自己压根儿就不知道怎么来设置自己线上系统的JVM内存大小

所以我们通过一个案例来分析一下，教会大家自己负责的线上系统，到底该如何合理设置JVM内存大小。



> 2、支付系统背景引入

先来看看，如果在一个电商系统里，一个支付系统大概应该是一个什么样的位置，如下图。

![](../../pic/2019-08-04-10-15-40.png)

其实只要大家网购过，大概的流程都会非常的清晰，假设我们在一个APP或者一个网站里买东西，大体上都是对一些商品加到购物车里，然后下个订单，接着对订单进行支付，钱从我们的账户划拨到人家网站的账户里去，大致如此。

上面的图就很清晰的展示了这个过程，所谓的支付系统，是一个网站或者APP后台系统中非常核心的一个环节，负责管理公司的资金流

它负责对接用户的支付请求，然后根据用户的付款方式，跟第三方的支付渠道对接起来，比如微信、支付宝，等等。

比如用户通过微信付款88元，那么他的钱在微信钱包里，需要划拨88块到电商公司账户里去，那么此时支付系统就得跟微信支付渠道对接，资金从微信划拨过来，大概的流程就是这个意思。



> 3、支付的核心业务流程

接着我们来讲一下支付的核心业务流程，大家先看下面的图。

![](../../pic/2019-08-04-10-16-28.png)

通过上图标号序号的步骤，大家可以很清晰的知道这个流程了

首先用户在我们的商城系统提交支付一个订单的请求，接着商城系统把这个请求提交给支付系统，支付系统就会生成一个支付订单，此时订单状态可能是“待支付”的状态。

然后支付系统指引用户跳转到付款页面，选择一个付款方式

然后用户发起实际支付请求，支付系统把实际支付请求转交给第三方支付渠道，比如微信或者支付宝，它们会去处理支付请求进行资金转移。

如果微信或者支付宝处理完支付之后，就会返回支付结果给支付系统，支付系统可以更新自己本地的支付订单的状态变成“已完成”。

当然，其实一个完整的支付系统还包含很多东西。

比如还要负责对账以及跟合作商户之间的资金清算，支付系统得包含应用管理、账户管理、渠道管理、支付交易、对账管理、清算管理、结算管理，等各种功能模块，但是我们这里就关注最核心的支付流程即可。



> 4、每日百万交易的支付系统的压力在哪里？

接着我们来考虑一下，一个每日百万交易的支付系统的压力到底集中在哪里呢？

比如上面的那个核心支付流程，我们的这套系统每日要发生百万次交易。

一般达到百万交易，要不然是国内最大的互联网公司，要不就是一个通用型第三方支付平台，对接各种APP的支付交易。

其实大家通过上图都能明显看到，上述业务流程中，最核心的环节，就是在用户发起支付请求的时候，会生成一个支付订单

这个支付订单需要记录清楚比如是谁发起支付？对哪个商品的支付？通过哪个渠道进行支付？还有发起支付的时间？等等，诸如此类的信息。

如果每日百万交易，那么大家可以想象一下，在我们的JVM的角度来看，就是每天会在JVM中创建上百万个支付订单对象

大家仔细想想，是不是这么回事？如下图：

![](../../pic/2019-08-04-10-17-46.png)

所以我们的支付系统，其实他的压力有很多方面，包括高并发访问、高性能处理请求、大量的支付订单数据需要存储，等等技术难点。

但是抛开这些系统架构层面的东西，单单是在JVM层面，我们的支付系统最大的压力，就是每天JVM内存里会频繁的创建和销毁100万个支付订单，所以这里就牵扯到一个核心的问题。

我们的支付系统需要部署多少台机器？

每台机器需要多大的内存空间？

每台机器上启动的JVM需要分配多大的堆内存空间？

给JVM多大的内存空间才能保证可以支撑这么多的支付订单在内存里的创建，而不会导致内存不够直接崩溃？

这就是我们本文要考虑的核心问题。



> 5、支付系统每秒钟需要处理多少笔支付订单

要解决线上系统最核心的一个参数，也就是JVM堆内存大小的合理设置，我们首先第一个要计算的，就是每秒钟我们的系统要处理多少笔支付订单。

假设每天100万个支付订单，那么一般用户交易行为都会发生在每天的高峰期，比如中午或者晚上。

假设每天高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概是每秒100笔订单左右，咱们就以每秒100笔订单来计算一下好了。

假设我们的支付系统部署了3台机器，每台机器实际上每秒大概处理30笔订单。

大家看下面的图，这个图可以反映出来支付系统每秒钟的订单处理压力。

![](../../pic/2019-08-04-10-19-47.png)



> 6、每个支付订单处理要耗时多久？

下一个问题，咱们必须要搞明白的一个事儿，就是每个支付订单大概要处理多长时间？

如果用户发起一次支付请求，那么支付需要在JVM中创建一个支付订单对象，填充进去数据，然后把这个支付订单写入数据库，还可能会处理一些其他的事情

咱们就假设一次支付请求的处理，包含一个支付订单的创建，大概需要1秒钟的时间。

那么大体上你的脑子里可以出现的一个流动的模型，应该是每台机器一秒钟接收到30笔支付订单的请求，然后在JVM的新生代里创建了30个支付订单的对象，做了写入数据库等处理

接着1秒之后，这30个支付订单就处理完毕，然后对这些支付订单对象的引用就回收了，这些订单在JVM的新生代里就是没人引用的垃圾对象了。

接着再是下一秒来30个支付订单，重复这个步骤。



> 7、每个支付订单大概需要多大的内存空间？

接着我们来计算一下，每个支付订单对象大概需要多大的内存空间？

之前的文章里有一个思考题， 已经教过大家这个怎么计算了，其实不考虑别的，你就直接根据支付订单类中的实例变量的类型来计算就可以了。

比如说支付订单类如下所示，你只要记住一个Integer类型的变量数据是4个字节，Long类型的变量数据是8个字节，还有别的类型的变量数据占据多少字节

百度一下都可以查到，然后就可以计算出每个支付订单对象大致占据多少字节。

![](../../pic/2019-08-04-10-21-02.png)



一般来说，比如支付订单这种核心类，你就按20个实例变量来计算，然后一般大概一个对象也就在几百字节的样子

我们算他大一点好了，就算一个支付订单对象占据500字节的内存空间，不到1kb。



> 8、每秒发起的支付请求对内存的占用

之前说过，假设有3台机器，每秒钟处理30笔支付订单的请求，那么在这1秒内，大家都知道，肯定是有方法里的局部变量在引用这些支付订单的，如下图：

![](../../pic/2019-08-04-10-22-08.png)

那么30个支付订单，大概占据的内存空间是30 * 500字节 = 15000字节，大概其实也就15kb而已。其实是非常非常小的。



> 9、让支付系统运行起来分析一下

现在我们已经把整个系统运行的关键环节的数据都分析清楚了，大家可以大致脑子里思考一下，每秒30个支付请求，创建30个支付订单对象，也就占据kb级别的内存空间而已

然后接着1秒过后，这30个对象就没有人引用了，就成了新生代里的垃圾了。

下一秒请求过来，我们的系统持续的创建支付订单对象，不停在新生代里放入30个支付订单，然后新生代里的对象会持续的累积和增加。

直到有一刻，发现可能新生代里都有几十万个对象了，此时占据了几百MB的空间了，可能新生代空间就快满了。

然后就会触发Minor GC，就把新生代里的垃圾对象都给回收掉了，腾出内存空间，然后继续来在内存里分配新的对象。

这就是这个业务系统的运行模型。



> 10、对完整的支付系统内存占用需要进行预估

之前的分析，全部都是基于一个核心业务流程中的一个支付订单对象来分析的，其实那只是一小部分而已。

真实的支付系统线上运行，肯定每秒会创建大量其他的对象，但是我们结合这个访问压力以及核心对象的内存占据，大致可以来估算一下整个支付系统每秒钟大致会占据多少内存空间。

其实如果你要估算的话，可以把之前的计算结果扩大10倍~20倍。也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。

那么每秒钟创建出来的被栈内存的局部变量引用的对象大致占据的内存空间就在几百KB~1MB之间。

然后下一秒继续来新的请求创建大概1MB的对象放在新生代里，接着变成垃圾，再来下一秒。

循环多次之后，新生代里垃圾太多，就会触发Minor GC回收掉这些垃圾。这就是一个完整系统的大致JVM层面的内存使用模型。



> 11、支付系统的JVM堆内存应该怎么设置？

其实结合支付系统的核心业务流程分析清楚了之后，大家就完全知道这么一个线上系统，每个机器上部署上线的时候，JVM的堆内存应该如何设置了。

其实一般来说这种线上业务系统，常见的机器配置是2核4G，或者是4核8G。

如果我们用2核4G的机器来部署，那么还是有点紧凑的，因为机器有4G内存，但是机器本身也要用一些内存空间，最后你的JVM进程最多就是2G内存

然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是个1G多的内存空间。

然后堆内存还分为新生代和老年代，你的老年代总需要放置系统的一些长期存活的对象吧，怎么也得给几百MB的内存空间，那么新生代可能也就几百MB的内存了。

这样的话，大家可以看到，我们上述的核心业务流程，只不过仅仅是针对一个支付订单对象来分析的，但是实际上如果扩大10倍~20倍换成对完整系统的预估之后，我们看到，大致每秒会占据1MB左右的内存空间。

那么如果你新生代就几百MB的内存空间，是不是会导致运行几百秒之后，新生代内存空间就满了？此时是不是就得触发Minor GC了？

其实如果这么频繁的触发Minor GC，会影响线上系统的性能稳定性，具体原因后续再说。

这里大家首先要明白的一点，就是频繁触发GC一定不是什么好事儿。

因此你可以考虑采用4核8G的机器来部署支付系统，那么你的JVM进程至少可以给4G以上内存，新生代在里面至少可以分配到2G内存空间

这样子就可以做到可能新生代每秒多1MB左右的内存，但是需要将近半小时到1小时才会让新生代触发Minor GC，这就大大降低了GC的频率。

举个例子：机器采用4核8G，然后-Xms和-Xmx设置为3G，给整个堆内存3G内存空间，-Xmn设置为2G，给新生代2G内存空间。

而且假设你的业务量如果更大，你可以考虑不只部署3台机器，可以横向扩展部署5台机器，或者10台机器，这样每台机器处理的请求更少，对JVM的压力更小。



> 12、本文总结

本文从一个支付系统案例出发，带着大家一点点计算了这个系统在日百万交易的压力下，部署3台机器的场景下，每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理，每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个系统每秒需要占据多大内存空间。

接着根据上述数据模型推算出，在不同的机器配置之下，你的新生代大致会有多大的内存空间，然后在不同的新生代大小之下，多久会触发一次Minor GC

为了避免频繁的GC，那么应该选用什么样的机器配置，部署多少台机器，给JVM堆内存多大的内存空间，新生代多大的内存空间。

根据这套配置，就可以推算出来整个系统的运行模型了，每秒钟创建多少对象在新生代，然后1秒之后成为垃圾，大概系统运行多久，新生代会触发一次GC，频率有多高 。



> 13、昨日思考题解答

昨天让大家思考Spring Boot和Tomcat部署系统怎么设置JVM参数

很多同学都找到了，Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入JVM参数

这个题目不难，主要是让大家建立起来一个意识，就是你得关注你部署的系统的JVM参数是怎么来设置的。



> 14、今日思考题

今天开始案例分析环节了，那思考题很简单，大家当然是应该去思考一下自己平时开发的系统：

你会去按照本文类似的思路估算系统压力吗？

你会去估算系统的JVM内存压力吗？

然后会去有针对性的合理设置JVM参数吗？

你们之前是这么做的吗？为什么？



上述几个问题，就是今天的思考题。


> 自己总结

本节重要的是，在服务上线前需要按照具体的服务，来分析系统每秒钟承受的并发请求，然后分析这个请求需要处理的时间，这个请求处理过程对象占用的内存多少，请求处理完毕会产生多少垃圾对象，多久会触发一次GC。然后根据这个来设置jvm的堆内存

并发量的预估：

假如每日百万的订单请求，根据28下单，也就集中在相应的两三个小时。

- 按照每秒100并发[如果预估每秒并发高可以多部署几台，分布式分散请求]
- 每分钟6000
- 每小时360000



# 012、案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？


目录：

前文回顾

基于案例，说说不合理设置内存的反面示例

大促期间，瞬时访问量增加十倍

少数请求需要几十秒处理，导致老年代内存占用变大

老年代对象越来越多导致频繁垃圾回收

反面案例总结

如何合理设置永久代大小？

如何合理设置栈内存大小

昨日思考题分析

今日思考题



> 1、前文回顾

昨天的文章给大家基于案例分析了一下，如果我们准备上线一个新的系统，如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。

然后基于这个推算出来的JVM内存运转模型，再接着去在系统上线前就选择一个合理的机器配置，要多大内存的机器，另外给JVM堆内存空间一个合理的大小。

其实这是一项非常基础的技能，因为对于大厂工程师，每次上线一个新的系统，他可能上线就会面临很大的访问压力

所以必须要学会合理预估内存压力，然后选择对应的机器配置，并且给出合理的内存大小，希望大家好好掌握。



> 2、基于案例，说说不合理设置内存的反面示例

昨天说的是一个正面的例子，即如何合理的设置内存大小。

今天来说一个反面的不合理设置内存大小导致的问题，也是我们之前线上生产系统真实经历过的一次故障，但是当时不是发生在支付系统中的，是另外一个系统。

不过为了便于大家理解，咱们还是以支付系统作为案例来说明好了，其实思路是一样的。

比如现在我们假设一个前提，就是支付系统因为没有经过合理的内存预估，所以直接选用了1台2核4G的虚拟机来部署了线上系统，而且就只用了一台机器

然后线上JVM给的堆内存大小，仅仅就只有1G，扣除老年代之后，新生代其实就几百MB的内存空间，大家看下图。

![](../../pic/2019-08-04-11-00-18.png)

好了，接着我们还是用昨天的那个业务压力，就是每天100万交易，高峰期每秒大概100笔支付交易，对应核心的支付订单对象有100个创建出来，每个支付订单对象占据500左右的字节大小，总共就是50kb左右。

然后一笔交易要1秒来处理，所以这100个对象在新生代中存在1秒的期间会被人引用，是无法被回收的。

而且我们之前说过一个全局预估的思路，从核心的支付订单对象扩展开来，拓展到系统里其他的对象中去，起码可以把内存占用扩大了10倍~20倍

比如我们就扩大个20倍好了，那么说明1秒之内，总共会创建出来大概1MB左右的对象，无法被回收。



> 3、大促期间，瞬时访问量增加十倍

其实按照估算出来的内存压力，你这么小的新生代在系统正常运行的情况下，其实还不算什么大问题

因为每秒新增1MB对象，然后几百秒过后，新生代快满了，自然就会触发Minor GC，回收掉里面99%的垃圾对象。

你要是内存那么小，最多就是发现系统每隔几分钟略微卡顿一下，因为这个时候在进行垃圾回收，会影响系统性能

至于为什么影响系统性能，下周垃圾回收的主题里会分析的。

但是现在我们假设，如果你的电商系统搞大促活动呢？

一般搞大促活动，很可能导致你的压力瞬间增大10倍，因为平时不来你网站的人，今天都来了。

此时可能会发现，每秒钟你的支付系统不是100笔订单了，可能是每秒钟上千笔订单。

这个时候你的系统压力本身就会很大了，不光是内存，尤其是线程资源、CPU资源，都会几乎打满。内存就更是岌岌可危了。



> 4、少数请求需要几十秒处理，导致老年代内存占用变大

咱们就针对内存来分析一下。

现在假设你每秒1000笔交易，那么每秒钟系统对内存的占用增加到10MB以上

我们甚至可以再大胆一点，预估每秒对内存占用达到几十MB，甚至上百MB也可以，因为毕竟大促时流量激增，就一切围绕这来预估。

而且最可怕的一点是，可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟，甚至几十秒的时间。

此时我们看下图可能出现什么问题，假设你的新生代里已经积压了很多的数据，都快满了。

![](../../pic/2019-08-04-11-02-30.png)

然后呢，此时内存里有比如几十MB的对象都被人引用着，因为少数请求突然处理的特别慢。

为什么会处理特别慢？因为压力太大，导致系统性能太差了，如下图。

![](../../pic/2019-08-04-11-02-50.png)

这个时候，如果你要再次在新生代里分配对象，那么是不是会导致一次Minor GC去回收新生代？

没错，但是可能回收掉大量的对象之后，那少数几十MB的对象还在，因为少数请求特别的慢。

然后很快新生代继续被填满，再次触发Minor GC，然后少数几十MB的对象还在，此时多次之后后，就会被转移到老年代去，如下图。

![](../../pic/2019-08-04-11-03-12.png)



> 5、老年代对象越来越多导致频繁垃圾回收

那么大家思考一下，上述流程如果反复来多次，就是时不时有少数请求特别慢，创建的对象在新生代反复多次没法被回收，然后就会被弄到老年代去

然后后续处理完之后，老年代里的对象就没人引用了，成为了垃圾对象。

经常重复这个流程，老年代里的垃圾对象，是不是就会越来越多？

一旦老年代的垃圾对象越来越多，迟早会满，然后就会触发老年代的垃圾回收，而且这个老年代被占满的频率还很快，可能就会频繁触发老年代的垃圾回收。

大家要知道，老年代的垃圾回收速度是很慢的，这个为什么慢，下周会给大家讲

但是在上述场景下，我们基本可以分析出来，如果你不合理的设置内存，就会导致新生代内存不充足，然后导致很多对象不停的迁移到老年代去，最后导致老年代也要不停的进行垃圾回收。

最后这频繁的垃圾回收，就会极大的影响系统的性能。



> 6、反面案例总结

本文就通过一个支付系统内存设置过小，然后突发巨大的流量压力，突发的性能抖动，最后导致很多对象长期在新生代被人引用，无法被回收，最后持续进入老年代，最后触发老年代内存都频繁占满，然后老年代都频繁被垃圾回收。

这是我们之前另外一个线上系统真实发生的场景，只不过用支付系统作为案例给大家解释了一遍，所以大家更能从反面体会到，不合理的预估 业务系统压力，不合理的设置内存大小，就可能会导致很大的问题。



> 7、如何合理设置永久代大小？

话说回来，如何合理设置永久代大小呢？

其实一般永久代刚开始上线一个系统，没太多可以参考的规范，但是一般你设置个几百MB，大体上都是够用的

因为里面主要就是存放一些类的信息，后面也会用专门的案例给大家分析，什么样的系统容易出现永久代内存溢出。



> 8、如何合理设置栈内存大小

其实这个栈内存大小设置，一般也不会特别的去预估和设置的，一般默认就是比如512KB到1MB，就差不多够了。

这就是每个线程自己的栈内存空间，用来存放线程执行方法期间的各种局部变量的。后面也会用专门的案例演示，栈内存什么时候会发生内存溢出。



> 9、昨日思考题分析

昨天让大家去思考自己平时负责的系统，有没有按照这个思路去预估业务系统压力，然后给一个合理的内存设置

其实就是希望大家以后建立起来一个全面的工程素养，每个合格的工程师，都应该在上线系统的时候，对系统压力做出预估，然后对JVM内存、磁盘空间大小、网络带宽、数据库压力做出预估，然后各方面都给出合理的配置。



> 10、今日思考题

看完今天的文章，我想给大家一个思考题，假设大家手头负责的系统业务量暴增100倍，甚至1000倍，按照我们文章的思路，自己去分析一下，有没有可能出现JVM上的问题？

要是业务真的增长这么多，你应该怎么调整机器配置和JVM内存大小？

> 自己总结

主要通过一个案例分析，不合理的内存设置会导致频繁的发生GC，当系统正常的情况下一个请求1秒钟处理完毕，释放对象。当系统因为某种原因，如并发量暴增，会导致系统处理变慢，处理一个请求可能会用几秒或者更多，这样就会导致，请求使用的对象得不到释放，新生代内存很快被占满，这一部分处理慢的请求使用的对象可能多次monitor GC过后到了老年代，这样过一段时间老年代也会满，然后触发full GC。

jvm调优的本质就是尽量避免GC，以及避免频繁的GC，让对象尽量在进入老年代以前就已经被回收了，减少进入老年代的对象，从而避免FULL GC。





# 013、第2周作业：看看你们的线上系统是如何设置JVM内存大小的？

第2周作业：

看看你们的线上系统是如何设置JVM内存大小的？



本周咱们已经把JVM的工作原理进一步的加深了理解，现在相信大家都知道咱们写好的系统平时运行的时候，都是优先把对象放新生代里，然后新生代满了就垃圾回收

如果有的长期存活的对象，躲过十多次垃圾回收，就进入老年代。

而且我们还结合案例分析了，一个新的系统上线之前，应该怎么去根据系统的线上负载，预估内存使用的压力，然后结合内存使用压力选择合理的机器配置以及JVM堆内存大小。

同时还给了一个反例，如果不合理设置内存，会导致什么样的问题。

那么本周的作业是什么呢？

非常简单，希望每个人按照案例里分析的那个过程，把你手头负责的系统的核心业务流程简化、抽象以及梳理出来，看看你们线上的真实负载情况，每秒钟多少请求？

然后根据你们的核心业务流程，看看每秒钟你负责的系统对内存使用的压力有多大？

假如你发现自己负责的系统很Low，没什么压力，那你可以尝试思考一下，如果你系统负载扩大100倍呢？此时对你内存使用压力有多大？

接着你再思考一下，就你的系统内存使用压力之下，目前你们线上机器是多大的堆内存？新生代多大？老年代多大？

如果没设置，可以自行百度默认的内存大小。然后分析一下，目前的这个内存配置，你们的垃圾回收有多频繁？

希望大家对自己手头的系统，严格的去分析一下，这个流程做下来，相信你对JVM的理解，对你负责的系统的理解，对线上系统的内存分配，都会提升一个理解的层次。


# 014、第2周答疑：本周问题答疑，上周作业点评


第2周问题答疑



- 问题一：

既然栈帧存放了方法对应的局部变量的数据也包括了方法执行的其它相关信息，那为什么不把程序计算器那块记录执行的情况，也放在各个方法自己的栈帧里，而是要单独列一个程序计数区去存储呢？请教，谢谢



答：

这就是JVM设计者的设计思想了，因为程序计数器针对的是代码指令的执行，Java虚拟栈针对的是放方法的数据，一个是指令，一个是数据，分开设计



- 问题二

对于第二点问题，我理解是在初始化的阶段执行该段代码的，对么？那在执行的时候也是按照jvm执行代码的这套流程来执行的么？ || 老师 1.静态变量是放在什么内存区域呢? 2.然后静态代码块也是会生成一个栈帧然后压栈到当前虚拟机栈中吗,是不是只压栈一次?



答：

是在类初始化的时候来执行，但是不是JVM执行代码的流程来执行，他是类初始化，自成一套体系


- 问题四[这个问题没有回答，同包同类名覆盖的问题]

怎么判断离代码的远近？如果是一个mavne聚合工程，两个子工程都定义了这个类，这个时候会加载哪一个？按照classpath的声明顺序吗，先声明先加载？ || 我在使用mybatis时发现有个类不满足要求，于是在项目中新建同包同名类，复制源码然后加上我自己的逻辑，这个时候就会加载我自己写的那个类，而不是mybatis中的类，这是为什么呢？



答：

没错，他有一个顺序，你自己的那个代码是最近的，他会优先加载你代码里的那个类

问题：
为什么会优先加载？？？



- 问题五

文章很详细，但是对于新手而言还是很抽象。我在学这块的时候都是画了很多内存开辟的流程图。希望老师抽空写一些简单的代码，把内存开辟和初始化，赋值的步骤一步一步画出来。



答：

思路很好，同学，但是你是已经有一定了解的，都提到了内存开辟和赋值流程了，其实对新手而言，了解到文章目前的程度就可以了，不能一口气太深，要慢慢来，刚开始浅显易懂一些，接下来逐步深入。



- 问题六

感觉也可以按照回收堆内存对象的思路来思考。方法区的class可以回收，只需要满足任何地方都没有用到该class，即：没有任何实例，没有调用class的静态变量或静态方法，没有利用反射访问class。暂时想到的只有这些，不知道对不对



答：

推测基本正确



- 问题七

方法执行完后, 栈帧立马被出栈, 那该栈帧中的变量等数据是立马就被回收掉吗?还是需要等垃圾回收线程扫描到再回收掉?



答：

出栈就没了



- 问题八

那如果把public static int flushInterval = Configuration.getInt("xxx");中的static去掉, 那后面的getInt是在什么时候执行的呢 ,我自己测试了一下,好像是在构造方法之前执行的, 不明白这个到底属于什么阶段?



答：

这是属于类的对象实例初始化的阶段



- 问题九

双亲委派模型设计的出发点很重要，文章漏了 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

也就是说，，判断2个类是否“相等”，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这2个类必定不相等。

 基于双亲委派模型设计，那么Java中基础的类，Object类似Object类重复多次的问题就不会存在了，因为经过层层传递，加载请求最终都会被Bootstrap ClassLoader所响应。加载的Object类也会只有一个，否则如果用户自己编写了一个java.lang.Object类，并把它放到了ClassPath中，会出现很多个Object类，这样Java类型体系中最最基础的行为都无法保证，应用程序也将一片混乱



答：

这位同学非常不错，对jvm有一定的研究，不过我们第一周的文章，并不是说漏掉你说的这些点，而是我们的写作思路，是循序渐进，这点很重要。

如果在刚开始就给出大段这种说明，那么只有少数人会看懂，回到普通的那种学院派纯理论的知识传递方法了。你说的很好，不过希望耐心跟着继续看，我们会有意把很多细节放在后面讲，循序渐进，保证很多小白同学都轻松学习，这点很重要。



- 问题十[没理解]

tomcat需要破坏双亲委派模型的原因：

 (1)tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；

 (2)同一个第三方类库的相同版本在不同web应用可以共享

 (3)tomcat自身依赖的类库需要与应用依赖的类库隔离 
 
 (4)jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器



答：

解答很详细，我们给的一些思考题，其实第二天只会给一些思路，鼓励大家自己查阅资料去思考，给出答案，给一些指引



- 问题十一

老师您好，我想问一下，我们的应用如果关掉，创建在堆中的对象，还有方法区的数据都还在吗



答：

应用关了，那么系统对应的JVM进程就没了，那JVM内存区域的数据就全没了



- 问题十二

请问老师：

1、“实例对象都已经从Java堆内存里被回收”和“Class对象没有任何引用”是一个概念么？

2、 “ClassLoader已经被回收”，什么时候会回收？



答：

1、不是，Class对象代表类，如果你有变量引用了类的Class对象，那么就是有引用 

2、比如你自定义的ClassLoader，本身就是个对象，一旦他没人再使用了，就会被垃圾回收

[这里会不会出现这个问题：因为一般我们不自己定义类加载器，就让应用类加载器去加载，是不关闭服务的情况下，这个类加载器就不会被销毁，然后就会造成这个类一直不会被卸载？？？]



- 问题十三

引用Class对象的是该类的实例对象？还是其他什么？



答：

比如用反射，可以获取一个对象的类的Class对象实例，比如Class clazz = replicaManager.getClass()，就可以通过replicaManager引用的对象，获取到ReplicaManager类的Class对象，那个clazz变量，就可以引用这个Class对象



- 问题十四

栈帧里的数据出栈就没有了，怎么理解？不是垃圾回收线程来回收，那是main线程执行完这个方法就直接将其栈帧里面的数据销毁了吗？



答：

没错



- 问题十五

第二周打卡，跟上节奏。今日思考题：项目中托管给Spring管理的对象，带@Configration的配置对象，都是长期存在老年代。自己定义那些pojo对象，如果不被定义为类对象就是朝生夕灭的，所以分配在年轻代里面。



答：

非常好，同学



- 问题十六

大多数情况下，方法中的对象都是短生存周期的对象，而实例对象和类对象都是长生存周期的对象。 

猜测一下：spring容器中管理的sington的bean是相对长生存周期的对象，而prototype是短生存周期对象



答：

可以多看看你手头负责的系统代码，去分析一下



- 问题十八

public void load(){ A a = new A(); a这个保存地址的变量是存在虚拟机栈的,这个方法执行完成后就销毁了, 那new A()这个对象是需要等待垃圾回收线程扫描后才回收吗?还是和a这个变量同时回收?



答：

对象要等待垃圾回收才销毁



- 问题二十

可以自己通过参数设置多大的对象直接放到老年代。 || 对于超大对象直接进入老年代这句话、老师可以给举个栗子吗



答：

是的



- 问题二十一

内存不够才会回收软引用对象，内存空间足够的话，不会回收软引用对象。弱引用不管内存空间够不够，只能撑到下次垃圾回收之前，就被会回收。 || gc回收的是软引用，弱应用和虚引用，关于软引用和弱引用傻傻分不清，这两者有何异同，请指教



答：

没错



- 问题二十二

大部分是spring容器的对象，spring默认单实例方式加载，这些对象可能会存在老年代中。但是方法内部new出来 对象不会存货太长时间，方法结束，引用消息，对象也会在下一次gc被回收。



答：

没错



- 问题二十三

类初始化时，变量引用的是new出来的对象，此时变量引用的对象会被实例化到堆内存吗？[这个变量时类变量吧？]



答：

会实例化放到堆内存



- 问题二十四

老师好。我今天使用Java VisualVm看了一下，发现了一个问题，我配置的是-Xms4M -Xmx4M -Xmn2M。应该是年轻代2M 老年代2M。

写了一个while循环不断的在方法里创建临时变量对象，但是我发现当内存堆达到3m左右的时候，就发生了Minor GC，堆内存回到了2M，而不是4M的时候，理论上不应该是堆内存满了再Minor GC吗？

然后我老年代里的对象是一个静态的简单对象，这个对象会直接把2M占满嘛？因为每次堆内存都回到2M左右。是我理解的有问题吗？谢谢老师



答：

这个很正常的，因为后续第三周会讲新生代的内存结构，就是其实不是新生代全部占满才minor gc，是里面一块主要的内存区域满了，就minor gc



- 问题二十五

堆内存3G,给新生代2G,剩下老年代1G,一般是不是新生代设置得比老年代大？一般比例是多少？如果机器16G,还是这个支付环境，那么老年代还是1G，新生代7G好。还是老年代2G,新生代5G更好？



答：

明天会说这个老年代的事儿，别着急



- 问题二十六

打卡。做项目时候没有关注系统压力，主要是考虑功能怎么现实，然后按时交付测试。以后可以按老师今天这个思路去估算一下系统压力了。



答：

是的，如果没合理估算内存压力，没合理设置jvm内存大小，那么上线之后，可能会发现频繁gc问题，导致系统卡顿，这是jvm优化的第一步，合理估算业务压力，合理设置内存大小



- 问题二十七

总结: 

1. 分析系统压力点在哪里？ 

2. 压力点的每秒请求数？ 

3. 每个请求耗时？ 

4. 每个请求消耗的内存？ 

5. 整个系统的所有请求重复1-4。 

6. 算出部署多少台机器？每个机器多少内存？ 

思考题: 平时工作中很少这样预估系统压力，一般我的做法都是部署上去后分配一个堆内存，然后测试时再去监控GC的频率做适当调整。这样做确实很被动，很多时候上线后发现和测试的GC频率差太多，以后试试老师这种估算方法。 

这个案例分析的方法很好，虽然很浅，但也能学到东西。希望以后能多多发一些更加全面的案例分析。



答：

案例是一步一步来的，每个案例都针对不同的方面和问题，慢慢来，学完几十个案例，你对jvm的内部原理，参数优化，故障解决，就有全面的掌握了



- 问题二十八

上次发生内存溢出，我们搞到凌晨5点多，最后我们老大调大了堆内存解决的，说是由于使用过多的静态内部类，有地方引用到无法释放导致的，不过我现在还没有明白为啥??



答：

以后慢慢学习，你也能掌握这种能力



- 问题二十九

这篇文字最重要的收获是分析处理问题的思路，分解然后一步一步分析处理。赞。

答：

是的，思路非常的重要，按照这个思路来，你们自己也能做jvm内存压力预估，系统上线前，合理设置一个内存大小



- 问题三十

是不是不应该在高峰期的时候让系统进行垃圾回收，这样会造成STW。老师你们线上系统会考虑在低峰期手动触发垃圾回收么?



答：

建议不要手动触发，依托合理的内存设置以及参数优化，让系统自行运转



- 问题三十一

是不是应该通过老师说的估算方式，尽量设大新生代 ，让系统在高峰期不产生gc？



答：

是的，尽量是这样



- 问题三十二

老师，那不管三七二十一，在内存大的条件下，多分配给新生代就好了，如果不行就加内存??



答：

那你就浪费机器资源，要合理评估，不需要大内存，就用小内存就可以了



- 问题三十三

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

 2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



答：

没错的，这是大致估算的方法



- 问题三十四

老师 您这儿的案例中提到，一个支付请求需要1s中，30个请求也是1s钟，那是不是可以理解为开了30个线程同时并发处理支付请求入库？



答：

没错，就是这个意思



- 问题三十五

支付订单对象，还创建其他数十种对象。那么计算的方式是不是：30 * 500字节/个 * 放大20倍≈300000字节≈300KB ？ || 

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



答

是的，你学会大致估算系统内存压力的办法了



- 问题三十六

“可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟”:老师，这里说的压力骤增是磁盘读写压力吗还是内存CPU压力，出行每个请求处理完毕需要几秒这里是写入压力吗?与网络有关吗?谢谢



答

都有可能，主要是CPU负载过高，会导致高并发下每个请求的处理性能直线下降，还有网络问题也会有



- 问题三十七

我们订单一天二百多万，线上正常每秒产生也应该在1M以上，xmn2048，xmx8192,本来半个多小时一次minor gc,扩大一百倍，不到一分钟一次，应该会出现案例中的问题，老年代会频繁gc,不过我们有6g老年代，达到full gc应该时间会稍微长点



答

对的，自己分析的非常好，掌握这个方法了



- 问题三十八

我现在的业务遇到的瓶颈是带宽，压测的时候，请求量暴增百倍，上下行带宽瞬间被打满，导致部分业务直接不能用了。。直到慢慢恢复过来



答

是的，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈



- 问题三十九

老师, 可以说下, 为什么并发上来了, 压力就会剧增嘛? 哪些方面的压力.



答

并发上来之后，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈，比如网络带宽打满，你的请求就会排队卡住，磁盘IO变满，数据库性能下降，都会导致请求处理慢几十倍



- 问题四十

您好，我有一个问题，就是main函数中创建了对象，这个对象在堆中开启空间，那么如果这个对象中有成员变量，这个成员变量是存在哪里？成员变量的引用存在哪里



答

成员变量也是在堆内存里的



- 问题四十一

看了老师的专栏我觉得讲的非常清晰易懂，学到很多。但是，我这也有一个建议。学习的过程离不开实践，我在想老师能不能提供一个让我们能够模拟出一些问题的方式，然后通过设置jvm的内存分布来解决这个问题，这样会不会更好一些？



答

放心，现在你们还学的不够深入，后续大量的案例环节，会给很多示范代码，模拟故障，让你们动手去操作的



- 问题四十二[类加载不一定进行初始化？？？]

老师我上网查了一下资料，把问题弄明白了。Test.class是被加载了，但是并没有 执行初始化步骤。 

课程中提到了类加载的时机，但是没有提到类初始化的时机，我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定 会立即初始化。

补充类初始化的时机如下：

 1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

 2.当调用某个类的静态方法时

 3.当使用某个类或接口的静态字段时

 4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

 5.当初始化某个子类时

 6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情况，也就没有做初始化



答

对的，就是这样



- 问题四十三

老师 假如Kafka类里面 声明一个实例变量 private ReplicaFetcher = new ... 这个实例变量放在哪个区



答

实例变量就在堆内存里


- 问题四十五

老师 根据示例代码， 我做了以下jvm参数配置：-Xms10m -Xmx10m， 然后在visualVM里跟踪堆栈使用情况。 十分诧异的现象是： 在while true循环中，也就是执行fetchFromRemote的时候， 新生代大小一直在有规律的增长，然后不停的minor GC， 每次GC(而不是等到15次以后)，老年代都会相应的增长一点。 



我的问题是，使新生代增长的到底是什么对象？GC时又是什么对象跑到老年代里去了？ 按我的理解，fetcher对象应该有且只有一份实例，而且while循环中，不会生成新的对象， 最初，新生代里有一份fetcher，然后第16次minor GC的时候，fetcher被转移到老年代， 无论如何，新生代和老年代都不会不断增长。 所以，是不是有什么我不知道的对象混了进去，导致新生代不断增长？



答

新生代到老年代转移的机制不只是年龄一种，还有别的，下周会详细说的



- 问题四十六

老师，多谢回复，每个订单处理时间是1秒和10秒，10秒的就要比1秒的要多加内存吗？请问是怎样的逻辑？能否量化？



答

那你得计算一下，你的内存每秒被使用的速度，根据这个来规划内存大小，还有你要是10秒一个请求，可能内存里累计起来会有大量对象没法释放，会导致瞬间新生代被打满，而且大量对象没法回收，然后全部去老年代，然后老年代也很快就满了，最后内存不够，很快就内存溢出了




# 015、大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？

目录：

什么时候会触发垃圾回收？

被哪些变量引用的对象是不能回收的？

Java中对象不同的引用类型

finalize()方法的作用

昨日思考题

今日思考题





> 1、什么时候会触发垃圾回收？

通过之前的学习，相信大家都知道一点，平时我们系统运行创建的对象都是优先分配在新生代里的，如下图所示。

![](../../pic/2019-08-04-12-52-42.png)



然后如果新生代里的对象越来越多，都快满了，此时就会触发垃圾回收，把新生代没有人引用的对象给回收掉，释放内存空间



大家务必注意，这就是新生代一个核心的垃圾回收触发时机，如下图。

![](../../pic/2019-08-04-12-53-15.png)



那么本文就来针对这个过程，再次梳理其中的一些细节，看看触发垃圾回收的时候，到底是按照一个什么样的规则来回收垃圾对象的。



> 2、被哪些变量引用的对象是不能回收的？



首先第一个问题，一旦新生代快满了，那么垃圾回收的时候，到底哪些对象是能回收的，哪些对象是不能回收的呢？



这个问题非常好解释，JVM中使用了一种可达性分析算法来判定哪些对象是可以被回收的，哪些对象是不可以被回收的。



这个算法的意思，就是说对每个对象，都分析一下有谁在引用他，然后一层一层往上去判断，看是否有一个GC Roots。



这句话相当的抽象，是不是？



没关系，我们的特点就是一步一图，保证你看明白。



比如最常见的，就是下面的一种情况。


![](../../pic/2019-08-04-12-54-05.png)



上面的代码其实就是在一个方法中创建了一个对象，然后有一个局部变量引用了这个对象，这种情况是最常见的



此时如下图所示。“main()”方法的栈帧入栈，然后调用“loadReplicasFromDisk()”方法，栈帧入栈，接着让局部变量“replicaManager”引用堆内存里的“ReplicaManager”实例对象。

![](../../pic/2019-08-04-12-54-39.png)



假设现在上图中“ReplicaManager”对象被局部变量给引用了，那么此时一旦新生代快满了，发生垃圾回收，会去分析这个“ReplicaManager”对象的可达性



这时，发现他是不能被回收的，因为他被人引用了，而且是被局部变量“replicaManager”引用的。



在JVM规范中，局部变量就是可以作为GC Roots的



只要一个对象被局部变量引用了，那么就说明他有一个GC Roots，此时就不能被回收了。



另外比较常见的一个情况，其实就是类似下面的代码。

![](../../pic/2019-08-04-12-55-18.png)



大家可以分析一下上面的代码，如下图所示。


![](../../pic/2019-08-04-12-55-31.png)


大家按照上图思考一下，此时垃圾回收的时候一分析，发现这个“ReplicaManager”对象被Kafka类的一个静态变量“replicaManager”给引用了



此时在JVM的规范里，静态变量也可以看做是一种GC Roots，此时只要一个对象被GC Roots引用了，就不会去回收他。



所以说，一句话总结：只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。



> 3、Java中对象不同的引用类型



关于引用和垃圾回收的关系，大家在这里务必有脑子里要引入一个新的概念，那就是Java里有不同的引用类型。



分别是强引用、软引用、弱引用和虚引用。下面分别用代码来示范一下。



强引用，就是类似下面的代码：

![](../../pic/2019-08-04-13-01-56.png)



这个就是最普通的代码，一个变量引用一个对象，只要是强引用的类型，那么垃圾回收的时候绝对不会去回收这个对象的。



接着是软引用，类似下面的代码。

![](../../pic/2019-08-04-13-02-16.png)



就是把“ReplicaManager”实例对象用一个“SoftReference”软引用类型的对象给包裹起来了，此时这个“replicaManager”变量对“ReplicaManager”对象的引用就是软引用了。



正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了



此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。



接着是弱引用，类似下面的代码。

![](../../pic/2019-08-04-13-03-02.png)



这个其实非常好解释，你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。



虚引用，这个大家其实暂时忽略他也行，因为很少用。



其实这里比较常用的，就是强引用和软引用，强引用就是代表绝对不能回收的对象，软引用就是说有的对象可有可无，如果内存实在不够了，可以回收他。



> 4、finalize()方法的作用



现在大家理解完了GC Roots和引用类型的概念，基本都知道了，哪些对象可以回收，哪些对象不能回收。



有GC Roots引用的对象不能回收，没有GC Roots引用的对象可以回收，如果有GC Roots引用，但是如果是软引用或者弱引用的，也有可能被回收掉。



接着就是到回收的环节了，假设没有GC Roots引用的对象，是一定立马被回收吗？



其实不是的，这里有一个finalize()方法可以拯救他自己，看下面的代码。



![](../../pic/2019-08-04-13-08-43.png)



假设有一个ReplicaManager对象要被垃圾回收了，那么假如这个对象重写了Object类中的finialize()方法



此时会先尝试调用一下他的finalize()方法，看是否把自己这个实例对象给了某个GC Roots变量，比如说代码中就给了ReplicaManager类的静态变量。

如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了。

不过说实话，这个东西没必要过多解读，因为其实平时很少用，就是给大家梳理出来这些细节，让大家清楚而已。



> 5、昨日思考题

上周的思考题和作业是一个意思，就是让大家去思考，自己负责的系统的内存压力，然后就是JVM内存大小是否合理，如果业务暴增100倍，是否会有内存问题。



作业更加详细的提示大家，自己画出核心业务流程图，然后一点点去分析，这是一个非常重要的技能。



其实JVM实战技能里的第一步，就是合理预估系统内存压力，合理设置JVM内存大小。



> 6、今日思考题

思考下面的代码。

![](../../pic/2019-08-04-13-10-26.png)

上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？

> 自己总结

1、GC roots对象

一句话总结：只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。


2、java对象的几种引用

- 强引用：代表绝对不能回收的对象；

- 软引用：SoftReference包裹的对象，正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。

- 弱引用：WeakReference包裹的对象,你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉;

- 虚引用：使用的情况比较少；

有GC Roots引用的对象不能回收，没有GC Roots引用的对象可以回收，如果有GC Roots引用，但是如果是软引用或者弱引用的，也有可能被回收掉。

3、finalize()

在对象回收的时候会调用对象finalize()这个函数，这个时候，对象有一次拯救自己的时候，不常用。





# 016、大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？


目录：


1、前文回顾

2、复制算法的背景引入

3、一种不太好的垃圾回收思路

4、一个合理的垃圾回收思路

5、复制算法有什么缺点？

6、复制算法的优化：Eden区和Survivor区

7、新生代垃圾回收的各种“万一”怎么处理？

8、昨日思考题解答

9、今日思考题





> 1、前文回顾

上一篇文章我们重新梳理了一下什么时候触发垃圾回收，以及到底哪些对象可以垃圾回收



另外，对新生代填满，GC Roots对象，软引用、弱引用，还有finalize()等概念进行了比较细致的梳理。



那么这篇文章，我们就来看看在对新生代进行垃圾回收的时候，到底是采取一种什么样的算法进行的呢？



> 2、复制算法的背景引入

针对新生代的垃圾回收算法，他叫做复制算法



简单来说，就是如下图所示，首先把新生代的内存分为两块。

![](../../pic/2019-08-04-17-03-36.png)


接着假设有如下代码，在“loadReplicasFromDisk()”方法中创建了对象，此时对象就就会分配在新生代其中一块内存空间里


而且是由“main线程”的栈内存中的“loadReplicasFromDisk()”方法的栈帧内的局部变量来引用的，如下图所示。


![](../../pic/2019-08-04-17-04-17.png)


接着大家想象一下，假设与此同时，代码在不停的运行，然后大量的对象都分配在了新生代内存的其中一块内存区域里，也只会分配在那块区域里


而且分配过后，很快就失去了局部变量或者类静态变量的引用，成为了垃圾对象

此时如下图所示。

![](../../pic/2019-08-04-17-05-04.png)



接着这个时候，新生代内存那块被分配对象的内存区域基本都快满了，再次要分配对象的时候，发现里面内存空间不足了。


那么此时就会触发Minor GC去回收掉新生代那块被使用的内存空间的垃圾对象。


那么回收的时候是怎么做的呢？



> 3、一种不太好的垃圾回收思路

假设现在采用的垃圾回收思路，就是直接对上图中被使用的那块内存区域中的垃圾对象进行标记



也就是根据上篇文章讲的那套思路，标记出哪些对象是可以被垃圾回收的，然后就直接对那块内存区域中的对象进行垃圾回收，把内存空出来。



大家想想，这种思路好吗？



这种思路去垃圾回收，可能会在回收完毕之后造成那块内存区域看起来跟下图一样。

![](../../pic/2019-08-04-17-08-03.png)

看上面的图，不知道大家发现什么没有，在那块被使用的内存区域里，回收掉了大量的垃圾对象，但是保留了一些被人引用的存活对象



但是呢，存活对象在内存区域里东一个西一个，非常的凌乱，而且造成了大量的内存碎片。



那么什么是内存碎片呢？



我们再看下面的图我用红线标记出来的区域，那些就是所谓的内存碎片。

![](../../pic/2019-08-04-17-08-41.png)

看到了吗？在各种凌乱的存活对象的中间，出现了大量的红圈圈出来的内存碎片



这些内存碎片的大小不一样，有的可能很大，有的可能很小。



那么内存碎片太多会造成什么问题呢？



内存浪费



啥意思？比如现在打算分配一个新的对象，尝试在上图那块被使用的内存区域里去分配



此时如下图所示，可能因为内存碎片太多的缘故，虽然所有的内存碎片加起来其实有很大的一块内存，但是因为这些内存都是碎片式分散的，所以导致没有一块完整的足够的内存空间来分配新的对象。

![](../../pic/2019-08-04-17-09-24.png)



所以这种直接对一块内存空间回收掉垃圾对象，保留存活对象的方法，绝对是不可取的



因为内存碎片太多，就是他最大的问题，会造成大量的内存浪费，很多内存碎片压根儿是没法使用的。



> 4、一个合理的垃圾回收思路

那么能不能用一种合理的思路来进行垃圾回收呢？



可以！这个时候上图中一直没派上用场的另外一块空白的内存区域就出场了。



首先，并不是按照上述思路直接对已经使用的那块内存把垃圾对象全部回收掉，然后保留全部存活对象。



而是先对那块在使用的内存空间标记出里面哪些对象是不能进行垃圾回收的，就是要存活的对象



然后先把那些存活的对象转移到另外一块空白的内存中，如下图。

![](../../pic/2019-08-04-17-10-22.png)





不知道大家发现这里的玄机没有？



没错，通过把存活对象先转移到另外一块空白内存区域，我们可以把这些对象都比较紧凑的排列在内存里



这样就可以让被转移的那块内存区域几乎没有什么内存碎片，对象都是按顺序排列在这块内存里的。



然后那块被转移的内存区域，是不是多出来一大块连续的可用的内存空间？



此时就可以将新对象分配在那块连续内存空间里了，如下图。

![](../../pic/2019-08-04-17-11-16.png)

这个时候，再一次性把原来使用的那块内存区域中的垃圾对象全部一扫而空，全部给回收掉，空出来一块内存区域，如下图。

![](../../pic/2019-08-04-17-11-44.png)



这就是所谓的“复制算法“，把新生代内存划分为两块内存区域，然后只使用其中一块内存



待那块内存快满的时候，就把里面的存活对象一次性转移到另外一块内存区域，保证没有内存碎片



接着一次性回收原来那块内存区域的垃圾对象，再次空出来一块内存区域。两块内存区域就这么重复着循环使用。



> 5、复制算法有什么缺点？

复制算法的缺点其实非常的明显，如果按照上述的思路，大家会发现，假设我们给新生代1G的内存空间，那么只有512MB的内存空间是可以用的



另外512MB的内存空间是一直要放在那里空着的，然后512MB内存空间满了，就把存活对象转移到另外一块512MB的内存空间去



从始至终，就只有一半的内存可以用，这样的算法显然对内存的使用效率太低了。



> 6、复制算法的优化：Eden区和Survivor区

之前我给大家分析过，系统运行时，对JVM内存的使用模型，大体上就是我们的代码不停的创建对象然后分配在新生代里，但是一般很快那个对象就没人引用了，成了垃圾对象。



接着一段时间过后，新生代就满了，此时就会回收掉那些垃圾对象，空出来内存空间，给后续其他的对象来使用。



但是我们之前分析过，其实绝大多数的对象都是存活周期非常短的对象，可能被创建出来1毫秒之后就没人引用了，他就是垃圾对象了。



所以大家可以想象一下，可能一次新生代垃圾回收过后，99%的对象其实都被垃圾回收了，就1%的对象存活了下来，可能就是一些长期存活的对象，或者还没使用完的对象。



所以实际上真正的复制算法会做出如下优化，把新生代内存区域划分为三块：



1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间，比如说Eden区有800MB内存，每一块Survivor区就100MB内存，如下图。

![](../../pic/2019-08-04-17-13-04.png)


平时可以使用的，就是Eden区和其中一块Survivor区，那么相当于就是有900MB的内存是可以使用的，如下图所示。

![](../../pic/2019-08-04-17-13-23.png)


但是刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收


此时就会把Eden区中的存活对象都一次性转移到一块空着的Survivor区。接着Eden区就会被清空，然后再次分配新对象到Eden区里，然后就会如上图所示，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。



如果下次再次Eden区满，那么再次触发Minor GC，就会把Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。



所以这里大家就能体会到，为啥是这么分配内存空间了。



因为之前分析了，每次垃圾回收可能存活下来的对象就1%，所以在设计的时候就留了一块100MB的内存空间来存放垃圾回收后转移过来的存活对象[百分之10吧？？？]



比如Eden区+一块Survivor区有900MB的内存空间都占满了，但是垃圾回收之后，可能就10MB的对象是存活的。



此时就把那10MB的存活对象转移到另外一块Survivor区域就可以，然后再一次性把Eden区和之前使用的Survivor区里的垃圾对象全部回收掉，如下图。


![](../../pic/2019-08-04-17-15-15.png)


接着新对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空着的，就这样一直循环使用这三块内存区域。



这么做最大的好处，就是只有10%的内存空间是被闲置的，90%的内存都被使用上了



无论是垃圾回收的性能，内存碎片的控制，还是说内存使用的效率，都非常的好。



> 7、新生代垃圾回收的各种“万一”怎么处理？

这个时候很多人看完了本文之后，一定对这里有可能发生的各种“万一”情况有疑惑了



比如：

万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？





万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？

到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？



别着急，明天就会来分析这些新生代的各种“万一”情况，以及新生代的对象是如何转移到老年代的，然后老年代是如何触发垃圾回收的，垃圾回收的算法又是什么样的。



看完这两篇文章，大家就会对新生代和老年代的对象分配、垃圾回收、对象转移等各种原理，都非常的熟悉了。



> 8、昨日思考题解答

思考下面的代码。

![](../../pic/2019-08-04-17-17-03.png)



上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



明显是不会的，因为ReplicaFetcher对象被ReplicaManager对象中的实例变量引用了，然后ReplicaManager对象被Kafka类的静态变量给引用了



所以垃圾回收的时候，是不会回收掉ReplciaFetcher对象的，否则让存活下来的ReplicaManager对象情何以堪？



> 9、今日思考题

各位还记得之前教给过大家的那个系统对内存使用压力的估算方法么？



可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收？



垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？



然后都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



随着不停的跟着专栏学习，希望大家多结合自己负责的系统来思考，你会养成一个核心能力，能够从JVM的角度去考虑系统运行时的模型



这样在真正发生JVM内存问题的时候，就能有一个非常深入的思考能力去解决问题。

> 自己总结

主要描述了新生代的垃圾回收算法。新生代采用复制算法，然后把内存区域划分为3个部分，E区和2个S区，E：S=8:1，[开始的时候E,S区都是空着的]新创建的对象一般先放在E区，当E区满的时候，触发monitor GC，标记E区中的存活对象，然后把标记的存活对象移动到一个S区，然后清空E区，此后新创建的对象不停的放在E区，当E区又满的时候，会再次触发垃圾回收，此时标记的是E区和那个存放对象的S区的对象，把存活的对象放到另外一个S区，然后清空E区和S区，之后重复这个流程。




# 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？


目录：

前文回顾

躲过15次GC之后进入老年代

动态对象年龄判断

大对象直接进入老年代

Minor GC后的对象太多，无法放入Survivor区怎么办？

老年代空间分配担保规则

老年代垃圾回收算法

昨日思考题解答

今日思考题





> 1、前文回顾

上篇文章已经给大家讲清楚了新生代的垃圾回收算法，包括跟这个垃圾回收算法搭配的新生代内存区域的划分，大家也都清楚了为什么有一块Eden区域和两块Survivor区域



那么本文就要给大家说说，新生代里的对象一般在什么场景下会进入老年代。



首先我们来看下面的图，我们写好的代码在运行的过程中，就会不断的创建各种各样的对象，这些对象都会优先放到新生代的Eden区和Survivor1区。

![](../../pic/2019-08-04-17-26-23.png)





接着假如新生代的Eden区和Survivor1区都快满了，此时就会触发Minor GC，把存活对象转移到Survivor2区去



如下图所示

![](../../pic/2019-08-04-17-26-51.png)



然后接着就会使用Eden区和Survivor2区，来分配新的对象，如下图所示。


![](../../pic/2019-08-04-17-27-09.png)


这个过程上篇文章已经讲的非常的清楚了。那么这篇文章我们就来依次看看各种情况下，对象是如何进入老年代的，以及老年代的垃圾回收算法是什么样的？



> 2、躲过15次GC之后进入老年代



按照上面的图示的那个过程，其实大家可以理解为我们写的系统刚启动的时候，创建的各种各样的对象，都是分配在新生代里的。



然后慢慢系统跑着跑着，新生代就满了，此时就会触发Minor GC，可能就1%的少量存活对象转移到空着的Survivor区中。



然后系统继续运行，继续在Eden区里分配各种对象，大概就是这个过程。



那么之前给大家讲过，我们写的系统中有些对象是长期存在的对象，他是不会轻易的被回收掉的，比如下面的代码。

![](../../pic/2019-08-04-17-28-18.png)



只要这个“Kafka”类还存在，那么他的静态变量“replicaManager”就会长期引用“ReplicaManager”对象，所以你无论新生代怎么垃圾回收，类似这种对象都不会被回收掉的。



此时这类对象每次在新生代里躲过一次GC被转移到一块Survivor区域中，此时他的年龄就会增长一岁



默认的设置下，当对象的年龄达到15岁的时候，也就是躲过15次GC的时候，他就会转移到老年代里去。



这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁，大家看下图。

![](../../pic/2019-08-04-17-29-21.png)





> 3、动态对象年龄判断



这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。



他的大致规则就是，假如说当前放对象的Survivor区域里，相同年龄的一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。



说着有点抽象，具体还是看图。

![](../../pic/2019-08-04-17-34-09.png)

假设这个图里的Survivor2区有两个对象，这俩对象的年龄一样，都是2岁



然后俩对象加起来对象超过了50MB，超过了Survivor2区的100MB内存大小的一半了，这个时候，Survivor2区里的大于等于2岁的对象，就要全部进入老年代里去。



这就是所谓的动态年龄判断的规则，这条规则也会让一些新生代的对象进入老年代。



其实说白了，无论是15岁的那个规则，还是动态年龄判断的规则，都是希望那些可能是长期存活的对象，尽早进入老年代



既然你是长期存活的，那么老年代才是属于你的地盘，别赖在新生代里占地方了。





> 4、大对象直接进入老年代



有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。



他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去。压根儿不会经过新生代。



之所以这么做，就是要避免新生代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代，



那么大的一个对象在内存里来回复制，不是很耗费时间吗？



所以说，这也是一个对象进入老年代的规则。





> 5、Minor GC后的对象太多无法放入Survivor区怎么办？



现在有一个比较大的问题，就是如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区怎么办？如下图。

![](../../pic/2019-08-04-17-36-49.png)


比如上面这个图，假设在发生GC的时候，发现Eden区里超过150MB的存活对象，此时没办法放入Survivor区中，此时该怎么办呢？



这个时候就必须得把这些对象直接转移到老年代去，如下图所示。

![](../../pic/2019-08-04-17-38-04.png)







> 6、老年代空间分配担保规则



这个时候大家又想提一个问题了，如果新生代里有大量对象存活下来，确实是自己的Survivor区放不下了，必须转移到老年代去



那么如果老年代里空间也不够放这些对象呢？这该咋整呢？



别急，一步一图，跟着下面的图来看。



首先，在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。



为啥检查这个呢？因为最极端的情况下，可能新生代Minor GC过后，所有对象都存活下来了，那岂不是新生代所有对象全部要进入老年代？如下图。


![](../../pic/2019-08-04-17-41-45.png)




如果说发现老年代的内存大小是大于新生代所有对象的，此时就可以放心大胆的对新生代发起一次Minor GC了，因为即使Minor GC之后所有对象都存活，Survivor区放不下了，也可以转移到老年代去。



但是假如执行Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了



那么这个时候是不是有可能在Minor GC之后新生代的对象全部存活下来，然后全部需要转移到老年代去，但是老年代空间又不够？



理论上，是有这种可能的。



所以假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了



如果有这个参数，那么就会继续尝试进行下一步判断。



下一步判断，就是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。



举个例子，之前每次Minor GC后，平均都有10MB左右的对象会进入老年代，那么此时老年代可用内存大于10MB。



这就说明，很可能这次Minor GC过后也是差不多10MB左右的对象会进入老年代，此时老年代空间是够的，看下图。


![](../../pic/2019-08-04-17-44-29.png)




如果上面那个步骤判断失败了，或者是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Full GC”，就是对老年代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC。



如果上面两个步骤都判断成功了，那么就是说可以冒点风险尝试一下Minor GC。此时进行Minor GC有几种可能。



第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor区域即可。



第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小的，此时就直接进入老年代即可。



第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触发一次“Full GC”。



Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。



因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代里面。



如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了



因为内存实在是不够了，你还是要不停的往里面放对象，当然就崩溃了。



这段规则有点烧脑，但是我觉得如果大家仔细对这段文字多看两遍，然后结合我们的图，脑子里想一想，基本都能看懂这个规则。





> 7、老年代垃圾回收算法



其实把上面的内容都看懂之后，大家现在基本就知道了Minor GC的触发时机，然后就是Minor GC之前要对老年代空间大小做的检查



包括检查失败的时候要提前触发Full GC给老年代腾一些空间出来，或者是Minor GC过后剩余对象太多放入老年代内存都不够，也要触发Full GC。包括这套规则，还有触发老年代垃圾回收的Full GC时机，都给大家讲清楚了。



简单来说，一句话总结，对老年代触发垃圾回收的时机，一般就是两个：



要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；



要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。



那么对老年代进行垃圾回收采用的是什么算法呢？



简单来说，老年代采取的是标记整理算法，这个过程说起来比较简单



大家看下图，首先标记出来老年代当前存活的对象，这些对象可能是东一个西一个的。

![](../../pic/2019-08-04-18-01-42.png)



接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片



然后再一次性把垃圾对象都回收掉，大家看下图。

![](../../pic/2019-08-04-18-02-52.png)





大家一定要注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。



如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。



所以后面用各种案例给大家展现出来的，就是在各种业务系统的生产故障下，怎么去一步一步分析到底为什么频繁的Full GC，然后怎么来调整JVM的各种参数进行优化。



其实大家如果透彻理解了最近的几篇文章涵盖的JVM的运行原理，就会知道，所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。



关于如何优化JVM，后续会有大量的案例带着大家去实战，而且会给出模拟生产的代码，让大家运行起来看到模拟出来的案发现场是如何导致JVM频繁GC的，对性能是如何影响的，然后再一步一步来优化JVM参数解决性能问题。





> 8、昨日思考题



各位同学还记得之前教给过大家的那个系统对内存使用压力的估算方法么？可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收，垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



昨天留了这个思考题，希望大家跟着文章的思路去好好分析自己手头写的代码，从JVM角度去理解你的代码是如何运行的。



> 9、今日思考题

今天的思考题算是一个小作业，今天的文章稍微有点难，有点烧脑，但是我觉得顺着文章思路和大量的图示，每个人是可以看懂的。



只不过消化起来需要点时间，希望大家今天能够花点时间，梳理出来GC的全流程。



到底什么时候会尝试触发Minor GC？

触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？

什么时候在Minor GC之前就会提前触发一次Full GC？

Full GC的算法是什么？

Minor GC过后可能对应哪几种情况？

哪些情况下Minor GC后的对象会进入老年代？



希望大家自己通过画图的形式，把这个过程完整的梳理出来，对这个过程的透彻理解，会成为我们后续进行JVM优化实战的核心基石。


> 自己总结

1、新生代里的对象一般在什么场景下会进入老年代

- 1、对象达到指定的年龄。通过-XX:MaxTenuringThreshold来设置，默认是15次，躲过了15次垃圾回收。
- 2、动态对象年龄判断。规则，假如说当前放对象的Survivor区域里，相同年龄的一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。
- 3、大对象直接进入老年代。-XX:PretenureSizeThreshold设置对象大小的门限。[对象不会经过新生代]
- 4、Minor GC后的对象太多无法放入Survivor区，此时会把这些对象直接放到老年代中。[S区存放的部分数据怎么处理？]



2、老年代空间分配担保规则

在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小[直接是按照新生代分配的内存大小？还是E+一个S区的大小？还是标记的存活对象？]。如果说发现老年代的内存大小是大于新生代所有对象的，此时就可以放心大胆的对新生代发起一次Minor GC了，因为即使Minor GC之后所有对象都存活，Survivor区放不下了，也可以转移到老年代去。

所以假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了


- 1、设置了
	1.1、看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。
		1.1.1、成功，两个步骤都判断成功了，那么就是说可以冒点风险尝试一下Minor GC。可能出现以下三种情况：
			1.1.1.1、第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor区域即可。
			1.1.1.2、第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小的，此时就直接进入老年代即可。
			1.1.1.3、第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触发一次“Full GC”。[Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。]
		1.1.2、执行full FC
- 2、没设置：执行full FC

如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了


3、什么时候会尝试触发Minor GC？

E区没有地方可以存放对象了


4、老年代触发垃圾回收的时机

- 1、要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；
- 2、要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。


所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。




# 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？


> 1、前文回顾



上一篇文章我们给大家分析了一下到底什么时候会触发Minor GC，什么时候会让对象从新生代转移到老年代，包括为了新生代转移到老年代的内存足够安全，Minor GC之前要如何检查老年代的内存空间，在什么情况下会触发老年代的Full GC，老年代的垃圾回收算法是什么，这些问题都已经给大家分析清楚了。



这篇文章，我们先接着上篇文章，给大家来一个真实的我们之前一个生产系统的老年代频繁Full GC的案例，让大家更加透彻的理解整个对象分配以及转移到老年代，以及Minor GC和Full GC的全过程。





> 2、一个日处理上亿数据的计算系统



先给大家说一下这个系统的案例背景，大概来说是当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。



为了方便大家集中注意力理解这个系统的生产环境的JVM相关的东西，所以对系统本身就简化说明了。



简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据，加载到自己的JVM内存里来进行计算处理，如下图所示。





这个数据计算系统会不停的通过SQL语句和其他方式从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。



但是这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。



每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间



然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。







> 3、这个系统到底多块会塞满新生代？



现在明确了一些核心数据，接着我们来看看这个系统到底多快会塞满新生代的内存空间？



既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？



这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。那么每次计算任务的1万条数据就对应了10MB的大小。



所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。







基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象，那么一分钟大概对应100次计算任务



其实基本上一分钟过后，Eden区里就全是对象，基本就全满了。



所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。



> 4、触发Minor GC的时候会有多少对象进入老年代？



此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。



那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。



首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？



看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。







此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。



那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？



大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据还在计算中，此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的



大家看下图。







此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？



不能！因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了



大家看下图。







> 5、系统运行多久，老年代大概就会填满？



那么大家想一下，这个系统大概运行多久，老年代会填满呢？



按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。



那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC，会做什么检查呢？如下图。







此时会先检查老年代可用空间是否大于新生代全部对象？



此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。



如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。



我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。



那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的



所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。



所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。



转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了



如下图：







> 6、这个系统运行多久，老年代会触发1次Full GC？



大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。



Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。







然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。







按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。因为每次Full GC速度都是很慢的，性能很差，而且明天的文章会告诉大家，为什么Full GC的时候会严重影响系统性能。





> 7、该案例应该如何进行JVM优化？



相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。



对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕



但是按照现有的内存模型，最大的问题，其实就是每次Survivor区域放不下存活对象。



所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代



这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。







只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的了



此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。







然后此时执行Minor GC，就会把Eden区里1.6GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。







以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。



通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。



但是大家在这里肯定注意到一点，就是之前说过一个动态年龄判定升入老年代的规则，就是如果Survivor区中的同龄对象大小超过Survivor区内存的一半，就要直接升入老年代。所以这里优化的方式仅仅是做一个示例说明，意思是要增加Survivor区的大小，让Minor GC后的对象进入Survivor区中，避免进入老年代。



实际上为了避免动态年龄判定规则把Survivor区中的对象直接升入老年代，在这里如果新生代内存有限，那么可以调整"-XX:SurvivorRatio=8"这个参数，默认是说Eden区比例为80%，也可以降低Eden区的比例，给两块Survivor区更多的内存空间，然后让每次Minor GC后的对象进入Survivor区中，还可以避免动态年龄判定规则直接把他们升入老年代。



> 8、垃圾回收器简介



在新生代和老年代进行垃圾回收的时候，都是要用垃圾回收器进行回收的，不同的区域用不同的垃圾回收器。



垃圾回收器是下周和下下周的重点内容，到时候会深入分析我们常用的ParNew、CMS和G1三种垃圾回收器的工作原理和优缺点。



这篇文章先简单给大家介绍一下：



Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象



工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。



ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。



G1垃圾回收器：统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，是下下周的重点，一周都会来分析G1垃圾回收器的工作原理和优缺点。



大家本周的重点，就是透彻理解新生代和老年代的对象分配以及垃圾回收的触发时机和运行机制，然后简单了解有哪些垃圾回收器即可。



明天会给大家讲垃圾回收最让人讨厌的Stop The World是怎么回事。



经过本周的学习，相信大家从原理层面对JVM有一个更加深入的认识。



> 9、昨日思考题



到底什么时候会尝试触发Minor GC？

触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？

什么时候在Minor GC之前就会提前触发一次Full GC？

Full GC的算法是什么？

Minor GC过后可能对应哪几种情况？

哪些情况下Minor GC后的对象会进入老年代？



昨天让大家把这个过程自己详细的梳理出来，相信看了今天的文章，理解的就更加透彻了。



> 10、今日小作业



本文是一个非常经典的真实生产案例和优化实践经验，建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用。

End


# 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

1、前文回顾



上一篇文章已经通过一个真实的案例分析了新生代的对象分配以及如何转移到老年代，如何频繁触发Full GC的一个场景，同时给出了优化的说明



相信大家通过上一篇文章就已经非常深刻的理解了JVM的核心运行原理了。



这篇文章我们就来讨论一下基于JVM运行的Java系统，最让我们Java工程师内心痛苦的到底是个什么问题？





2、先来回顾一个新生代GC的场景



大家先来看下面的图，新生代的内存大家都知道是分为Eden和两个Survivor的。





那么此时如果系统不停的运行，然后把Eden给塞满了呢？如下图所示。





这个时候势必就会触发Minor GC了，好，那么之前给大家说过，进行垃圾回收是有专门的垃圾回收线程的，而且对不同的内存区域会有不同的垃圾回收器，大家还记得这个事儿吗？



相当于垃圾回收线程和垃圾回收器配合起来，使用自己的垃圾回收算法，对指定的内存区域进行垃圾回收，大家看看下图。





通过上面这个图，大家对垃圾回收线程、垃圾回收器以及垃圾回收算法，是不是就有了一个非常清晰的关系的认识了？



没错，垃圾回收一定会通过一个后台运行的垃圾回收线程来执行他具体的一个逻辑



比如针对新生代我们会用ParNew垃圾回收器来进行回收，然后ParNew垃圾回收器针对新生代采用的就是复制算法来垃圾回收。



这个时候垃圾回收器，就会把Eden区中的存活对象都标记出来，然后全部转移到Survivor1去，接着一次性清空掉Eden中的垃圾对象，如下图。







接着系统继续运行，新的对象继续分配在Eden中，如下图所示。







当Eden再次塞满的时候，就又要触发Minor GC了，此时已然是垃圾回收线程运行垃圾回收器中的算法逻辑，也就是采用复制算法逻辑，去标记出来Eden和Survivor1中的存活对象



然后一次性把存活对象转移到Survivor2中去，接着把Eden和Survivor1中的垃圾对象都回收掉，如下图。





3、GC的时候还能继续创建新的对象吗？



不知道大家有没有考虑过一个问题，之前我们一直都是说GC的原理和JVM整体运行的机制



但是从来没说过在GC的时候，到底我们写好的Java系统在运行期间还能不能继续在新生代里创建新的对象了？



大家可以自己思考一下，假设允许在GC期间，然后还可以继续让系统在新生代的Eden区里创建新的对象，会是一个什么样的场景？



大家看下图。







根据上图所示，如果一边垃圾回收器在想办法把Eden和Survivor2里的存活对象标记出来转移到Survivor1去，然后还在想办法把Eden和Survivor2里的垃圾对象都清理掉，结果这个时候系统程序还在不停的在Eden里创建新的对象。



这些新的对象有的很快就成了垃圾对象，有的还有人引用是存活对象，那现在咋办？



全部乱套了，对于程序新创建的这些对象，你怎么让垃圾回收器去持续追踪这些新对象的状态？



怎么想办法在这次垃圾回收的过程中把新对象中的那些存活对象转移到Survivor2中去？



怎么想办法把新创建的对象中的垃圾都给回收了？



有的同学可能会想当然的说，那就想办法让垃圾回收器来做到啊！



我只能说，大家可以去搞清楚JVM的运行原理，但是不要随意去质疑人家JVM的垃圾回收机制为什么不去那么设计。



因为有些事情想着很简单，但是一旦你要在JVM中去实现的时候，会发现务必的复杂，成本极高，而且很难做到。



所以说，在垃圾回收的过程中，同时还允许我们写的Java系统继续不停的运行在Eden里持续创建新的对象，目前来看是非常不合适的一个事情。



4、JVM的痛点：Stop the World



所以现在大家就好理解了，我们平时使用JVM最大的痛点，其实就是在垃圾回收的这个过程



因为在垃圾回收的时候，尽可能要让垃圾回收器专心致志的干工作，不能随便让我们写的Java系统继续对象了，所以此时JVM会在后台直接进入“Stop the World”状态。



也就是说，他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！



然后让垃圾回收线程可以专心致志的进行垃圾回收的工作，如下图所示。





这样的话，就可以让我们的系统暂停运行，然后不再创建新的对象，同时让垃圾回收线程尽快完成垃圾回收的工作，就是标记和转移Eden以及Survivor2的存活对象到Survivor1中去，然后尽快一次性回收掉Eden和Survivor2中的垃圾对象，如下图。







接着一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象，如下图。







5、Stop the World造成的系统停顿



现在大家就很清晰“Stop the World”会对系统造成的影响了， 假设我们的Minor GC要运行100ms，那么可能就会导致我们的系统直接停顿100ms不能处理任何请求



在这100ms期间用户发起的所有请求都会出现短暂的卡顿，因为系统的工作线程不在运行，不能处理请求。



假设你开发的是一个Web系统，那么可能导致你的用户从网页或者APP上点击一个按钮，然后平时只要几十ms就可以返回响应了



现在因为你的Web系统的JVM正在执行Minor GC，暂停了所有的工作线程，导致你的请求过来到响应返回，这次需要等待几百毫秒。



那么大家可以思考一下，回忆一下上篇文章讲到的案例，因为内存分配不合理，导致对象频繁进入老年代，平均七八分钟一次Full GC，而Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。



那么此时一旦你频繁的Full GC，难道你希望你的系统每隔七八分钟就卡死个30秒吗？



在30秒内任何用户的请求全部卡死无法处理，然后用户看到的都是系统超时之类的提示，这会让用户体验极差



所以说，无论是新生代GC还是老年代GC，都尽量不要让频率过高，也避免持续时间过长，避免影响系统正常运行，这也是使用JVM过程中一个最需要优化的地方，也是最大的一个痛点。



6、不同的垃圾回收器的不同的影响



接着今天的话题，再来延伸说一下昨天提到的那些垃圾回收器



比如对新生代的回收，Serial垃圾回收器就是用一个线程进行垃圾回收，然后此时暂停系统工作线程，所以一般我们在服务器程序中很少用这种方式。



但是我们平时常用的新生代垃圾回收器是ParNew，他针对服务器一般都是多核CPU做了优化，他是支持多线程个垃圾回收的，可以大幅度提升回收的性能，缩短回收的时间



所以下周我们深入分析这块的时候，会告诉大家他的很多参数该如何优化



大致原理图如下





大家可以看到，不同的垃圾回收器他会有不同的机制和原理，使用多线程或者单线程，都是有区别的。



然后包括之前给大家提到的CMS垃圾回收器，专门负责老年代的垃圾回收，他也有自己特殊的一套机制和原理，非常的复杂



下周会深入讲CMS垃圾回收器的原理和参数优化，他也是基于多线程的，而且可以使用一套独特的机制尽可能的在垃圾回收的过程中减少“Stop the World”的时间，避免长时间卡死我们的系统。



包括下下周要深入剖析的现在很多公司都在使用的最新的G1垃圾回收器，他更是将采用复杂的回收机制将回收性能优化到机制，尽可能更多的降低“Stop the World”的时间。



其实JVM本身的迭代演进，就是不断的在优化垃圾回收器的机制和算法，尽可能的降低垃圾回收的过程对我们的系统运行的影响。



而我们作为一个合格的Java工程师，我们的责任就是尽可能搞懂这些垃圾回收器的运行机制和算法



然后合理的对线程系统优化内存分配和垃圾回收，尽可能减少垃圾回收的频率，降低垃圾回收的时间，减少垃圾回收对系统运行的影响。



所谓的JVM优化，其实指的就是这个。后续我们会结合大量的案例展开



相信大家一旦坚持3个多月学习完这个专栏，一定会从此脱胎换骨，对JVM的运行原理，垃圾回收机制，然后各种生产故障的监控、排查、定位、分析和解决，都有一个本质的能力提升，在公司里绝对可以搞定自己负责的生产系统的JVM故障。



7、昨日思考题

昨天给大家分析了一个经典的案例，是一个非常经典的真实生产案例和优化实践经验



建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用。



8、今日思考题

给大家一个小小思考题：到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？



大家想想，明天给出答案。

End


# 020、第3周作业：自己动手画出各种垃圾回收算法和垃圾回收器的原理图


第3周作业：

自己动手画出各种垃圾回收算法和垃圾回收器的原理图



本周的作业非常重要，大家务必认真去做，因为这决定了大家是否吃透本周的内容，也决定了大家是否有足够扎实的基础去研究后续大量的优化案例。



本周希望大家自己画一幅非常完整的图，把以下流程全部画清楚：



对象在新生代的分配

什么时候会触发Minor GC

触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小

如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小

什么情况下Minor GC之前会提前触发Full GC

什么情况下会直接触发Minor GC

Minor GC之后有哪几种情况对象会进入老年代



大家可以画一幅完整的图，然后配合大量的文字说明，一点一点条理清晰的把JVM的核心运行流程全部梳理清晰，这将成为后续研究JVM优化的坚实基础。



# 021、第3周答疑：本周问题答疑，上周作业点评

第3周答疑问题汇总




问题

一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答: 

1)加大分代年龄，比如默认15加到30; 



2)修改新生代老年代比例，比如新生代老年代比例改成2:1 



3)修改e区和s区比例，比如改成6:2:2 面试官说他们内部服务已经做到fullgc次数为0，只做ygc



想听听老师的意见



答：其实对这个面试题，非常的简单，需要深度结合线上系统的实际运行来看，你如果把本周文章全部看懂了，那么可以轻易回答这个问题。



首先上线系统之后，要借助一些工具（后面会讲）观察每秒钟会新增多少对象在新生代里，然后多长时间触发一次Minor GC，平均每次MInor GC之后会有多少对象存活，Survivor区是否可以放的下。



这里的关键点就是必须让Survivor区放下，而且不能因为动态年龄判定规则直接升入老年代。然后只要Survivor区可以放下，那么下次Minor GC后还是存活这么多对象，依然可以在另外一块Survivor区放下，基本就不会有对象升入老年代里去。



我们的案例其实也是做了类似的优化，几乎消灭了Full GC。包括一些检查参数如何设置





问题：

老师，我们公司的项目是一个数据采集解析的系统。对于每一条采集的数据都会封装成一个对象放到缓存中，然后继续走后续的流程。



假设一个对象（包含原始日志，扩展信息）有1kb大小。一秒一万数据量的话就是一秒将近10mb。然后如果一台给的4g内存给新生代内存。



那么400秒就会触发gc。请问这样算对吗？有什么优化的手段吗？之前开发重来没有考虑过gc问题



答：是的，还得考虑你每条消息需要处理多长时间，如果发生GC，最多可能有多少数据是被引用的，无法回收





问题

我总结了本周所学的知识，得出一套演算过程和公式，请看一下是这样吗？



每台机器可以提供给JVM的最大内存： each_m，比如2核4G机器，可提供JVM最大内存2G 栈占用：stack_m = QPS估值 * 1M * 20倍数，估值30QPS，栈约为600M 



新生代以30分钟一次GC计算总内存：30(Monitor GC间隔) * 60 * QPS估值 * 接口内存估值,young_m 所需机器数量，假设等于N 



方法区：200M，一般够用，method_m 老年代：500M，一般不大，300M也行，像我们结算服务，100M都够用



old_m 演算公式: JVM最大内存*N = stack_m + young_m + old_m + method_m * N 机器数N，也同时估算出来，是这样吗



答：是这样，总结的非常好





问题

老师，在上面看到一句，gc回收的是软引用，弱应用和虚引用，对吗？



还有我记得jvm是自动去垃圾回收的，程序员没法指定，现在加上弱引用，是去指定回收吗



答：不是的，软引用，弱引用之类的，只不过是指定哪些对象可以回收而已





问题

当初始化静态变量replicaManager的时候，replicaManager成员变量也会初始化，按今天课程的理解，有静态变量引用，所以不会回收。不知道我的理解是否正确。



答：理解正确





学员思考题回答：

思考题：

blob.png


上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



学员回答：不会回收，ReplicaFecher对象被replicaFetcher强引用，而ReplicaManager对象又被可作为GC ROOT的replicaManager强引用



所以ReplicaFetcher对象可以向上找到GCROOT，因此不会回收





学员思考题回答：

对于新生代内存清理，首先是栈桢出栈，新生代的引用对象消失，然后就是minoc gc 垃圾回收



问题

老师您好！有个问题想不明白！



比如在方法里有个局部变量A a= new A()，变量a存储在当前方法的栈帧的局部变量表，实例对象存储在堆里！ 在执行到该方法时创建了实例对象



当方法结束后，虚拟机栈都会清空，刚刚执行方法时创建的对象在gc时不会清除？为啥呢，留着还有用吗！那下次再调用这个方法时还会new新的对象啊！想不太明白！



答：此时不会，此时仅仅是对象没人引用而已，要等待垃圾回收的时候给回收掉



问题

打卡。今天内容很简单，不过有一个疑问，就是存活对象在移动的时候内存地址不会发生改变吗？句柄引用的内存地址到底是不是一个固定的值？



答：内存地址会改变



问题

在给新建对象分配内存的时候，被利用的survivor区和Eden区这90%可以看做一个整体，新建对象可以分配到被利用的survivor区，也可以分配到Eden区，只有垃圾回收进行复制的时候才会明显区分出survivor区的作用，这样理解对吗？



答：

对的，理解正确





问题

您好，关于内存大小估算这块，您说可以把之前的计算结果扩大10倍~20倍。



也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。



为什么是10倍~20倍，为什么您不估算5倍，不估算50倍，每秒中除了在内存里创建支付订单对象，还会创建其他数十种对象这个思路是怎么来的?



望回复，谢谢，如果我们出去面试的话，可能有些面试官会这么问的



答：这是一个经验值，是根据那个支付案例来说的，其实核心含义不是让大家记住这个10~20倍的数字，而是应该你自己根据自己的系统来考虑



不同的系统都是不一样的，你只要把你负责的系统大致看看，就知道他每秒请求过来，会连带创建多少种对象，大致其实就估算出来了



问题

老师讲的思路很清晰，从优缺点分析，有浅入深，能否解答一下：eden区和survivor区 对象是通过什么规则被分配到这两个区的呢？还是说是随机分配



答：优先分配到Eden区，Survivor区是用来放每次GC过后的那些存活对象的



问题

有个地方描述不够严谨吧。比如：接着新对象继续分配在Eden区和另外那块开始被使用的survivor区，然后始终始终保持一块survivor区是空着的。



这个应该没有survivor区是空的吧，之前垃圾回收后不是剩余的存活的对象已经被移动到另一块survivor区了吗？它里面并不是空的啊?是不是这样呢老师



答：假设Eden区和Survivor1区里有对象，一次Minor GC过后，存活对象全部进入Survivor2区域



接着新对象继续在Eden区里分配，Survivor2里放之前Minor GC后存活的对象，然后Survivor1区是空的。



下一次Minor GC过后，剩余存活对象进入Survivor1区里，然后Survivor2区就是空的了。





问题

"接着新的对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空的"



那么老师，程序在刚刚启动的时候，第一次创建对象时也会分配到Eden区和其中一个Survivror区吗？ 



还是说只分配到Eden区，此时发现Eden区满了，其他两个survivor区还是空的情况下，触发第一次小GC？



答：只分配到Eden区的，然后第一次Minor GC后会转移存活对象到一块Survivor去





问题

问个问题，为什么老年代不采用复制算法，像新生代那样一个E两个S呢，或者说为什么新生代不采用标记整理算法呢？还有就是标记清除算法会产生内存碎片，那jvm中是在哪里用到了



答：老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





问题

今天的内容比起之前的逻辑性强很多，需要好好思考和梳理一下，感谢老师一步一步带着我们由浅入深。



答：加油，继续坚持



问题

两个问题：

假设MinorGC之前老年代空间担保成功，但是实际不幸的是MinorGC之后老年代放不下而触发了FullGC，之后马上又会伴随一次MinorGC是吗，相当于短时间内进行了两次MinorGC，有这个必要吗？ 




老年代为什么用标记整理算法？优势在哪里



答：

1、多一次Minor GC没什么，他速度很快 



2、老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





问题

大神，默认情况下，新生代占整个堆的3/8，实际情况我们新生代大小占多少合适，我看你在这个支付系统给的是2/3，我们系统在压测的时候，yong gc明显，我把新生代调整为一半了



答：这个新生代设置为多少，其实没有固定的大小，需要自己根据实际系统运行情况来调节





学员的思考题作答：

1、到底什么时候会尝试触发Minor GC？

 新生代剩余内存空间放不下新对象，此时需要触发GC。



触发MinorGC情况有: 

1- 新生代现有存活对象小于老年代剩余内存 ，即老年空间代足以支撑可能晋升的对象 

2- 情况1不成立，查看设置了空间担保且可以担保成功 



2、触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？ 

1、判断新生代存活是否大于老年代剩余 

2、条件1成立且设置空间担保的情况下，判断老年代剩余是否大于之前进入老年代平均存活大小 



3、什么时候在Minor GC之前就会提前触发一次Full GC？ 

新生代现有存活对象>老年代剩余内存情况下，未设置空间担保 或 空间担保失败



4、Full GC的算法是什么？ 

标记整理算法，速度很慢 



5、Minor GC过后可能对应哪几种情况？ 

放入新对象前进行判断，新对象大小+存活对象是否可以分配在新生代。可以则放入，否则判断是否可以放入老年代。可以则放入，否则 OOM



6、哪些情况下Minor GC后的对象会进入老年代？ 

新生代放不下，老年代可以放下的情况下





问题

先说一下问题： 

1、MinorGC后，存活对象大于survivor区域，小于老年代可用空间，是所有对象都进入老年代，还是一部分



如果所有的对象都进入，是不是会有一些浑水摸鱼？



比如新建的对象，刚好一次MinorGC后还存活，也就是说年龄只有1岁的对象进入老年代，这些对象可能在第二次MinorGC就可以回收，只是正好赶上了这趟车，这样进入老年代没一会就成为垃圾对象了



2、记得之前讲的说设置堆内存，新生代一般是比老年代大的。新生代如果触发MinorGC，表示这新生代满了



一般情况下，新生代满了，对象占用内存肯定是大于老年代可用空间的



所以不明白MinorGC前检查老年代可用空间是否大于新生代所有对象内存，大部分情况下，这个检查的结果都为true呀。难道只是为了文中所说的，规避极端情况吗？



那我直接进行-XX:-HandlePromotionFailure，之后进行FullGC，或MinorGC，如果是极端情况，再抛出OOM，这样不也很好吗。 请老师指点一下 



下面是我的今日思考题回答：

1、

Eden区和存对象的Survivor区满的时候触发MinorGC 



2、

检查新生对所有对象所占空间是否大于老年代可用空间， 如果小于，进行MinorGC。 



如果大于，查看"-XX:-HandlePromotionFailure"是否设置。



如果没设置，进行FullGC。如果设置如果没设置，进行FullGC。



如果设置，判断老年代空间是否大于之前MinorGC后进入老年代对象的平均大小。 如果大于，进行MinorGC。 如果小于，进行FullGC。 



3、

(1)新生代对象大小大于老年代空间，且没有设置"-XX:-HandlePromotionFailure" 



(2)设置了"-XX:-HandlePromotionFailure"，老年代可用空间小于之前每次MinorGC后进入老年代的平均大小



 4、

标记整理算法，老年代对象存活时间较长，赋值算法不太适合，标记-清理算法会产生内存碎片。标记整理可以规避。 



5、

(1)小于Survivor区域，进入Survivor区域



(2)大于survivor区域，小于老年代可用空间，进入老年代 



(3)大于survivor区域，大于老年代可用空间，进行FullGC，如果FullGC后，老年代可用空间仍小于存活对象，抛出OOM 



6、 

(1)经过15次(默认，可以设置)MinorGC的 



(2)某个年龄的对象大于survivor区域的



答：

1、所有对象都进入老年代 



2、不见得，新生代和老年代谁大谁小，看具体场景怎么设置，老年代更大其实很正常，所以一般要设置那个参数，突破第一重检查的限制



问题

是每次Minor GC之前都会去检查是否老年代的大小大于新生代所有内存的大小？还是每次Minor GC之前如果预估到Survivor区域不够了，才会去做这个检查？ 



如果第一种情况，那么假如Survivor能存的下回收后的对象，每次检查一下老年到貌似不必要。



如果第二种情况，到底是怎么预估的回收后的对象Survivor能放得下？难道遍历一次GCROOT然后计算他们的内存大小。感觉不太靠谱，遍历GC root是垃圾回收器做的事情，发生在“垃圾回收过程中”而不是“垃圾回收之前”



答：每次Minor GC前直接检查新生代全部对象的大小是否小于老年代可用内存大小，不是检查新生代的存活对象的大小，所以这个比较成本是很低的





问题

请教下，我们写好等代码在运行等过程中，对于创建的各种各样的对象，放入新生代的内存顺序一定首先是eden区，然后survivor1区吗？还是也可能是eden区和survivor2区？谢谢老师



答：仅仅放在Eden区里，Survivor是用来放每一次Minor GC后存活的对象的





非常棒的学员思考题回答

到底什么时候会尝试触发Minor GC？ 

答：当新生代的Eden区和其中一个Survivor区空间不足时。 



触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？ 

答：

1、先判断新生代中所有对象的大小是否 小于 老年代的可用区域 true 则 触发Minor GC，false则继续进行下面2中的判断 



2、如果设置了-XX:HandlePromotionFailure这个参数，那么进入第3步 如果没有设置-XX:HandlePromotionFailure参数，那么触发Full GC 



3、判断Minor GC历次进入老年代的平均大小是否 小于 老年代的可用区域 true 则触发Minor GC，false则会触发Full GC 什么时候在Minor GC之前就会提前触发一次Full GC？ 

答：当判断 新生代历次进入老年代对象的平均大小 大于 老年代的可用区域就会触发一次Full GC，让老年代腾出一些空间，腾出空间后再进行Minor GC。 



FullGC的算法是什么？ 

答：标记整理算法。 



Minor GC过后可能对应哪几种情况？ 

答： 

情况1：Minor GC前先判断：存活的对象所占的内存空间 < Survivor区域内存空间的大小，那么存活的对象进入Survivor区。 



情况2：Minor GC前先判断：Survivor区域内存空间的大小 < 存活的对象所占的内存空间 < 老年代的可用空间大小。那么存活的对象，直接进入老年代。 



情况3：Minor GC前先判断： (存活的对象所占的内存空间 > Survivor区域内存空间的大小) && (存活的对象所占的内存空间 > 老年代的可用空间大小)。那么会触发Full GC，老年代腾出空间后，再进行Minor GC。如果腾出空间后还不能存放存活的对象，那么会导致OOM即堆内存空间不足、堆内存溢出。 



哪些情况下Minor GC后的对象会进入老年代？ 

答：

1、 Survivor区 < 存活对象占用的空间 && 老年代可用区域 < 存活对象占用的空间 

2、经过XX:MaxTenuringThreshold次M





问题

老师，诚心求教，希望能帮忙解释清楚，反复看了几次，确实文章开头说的也是我们写好的代码在运行过程中，会不断的创建各种各样的对象



这些对象会优先存放在新生代的Eden和survivor1区，接着假如新生代的Eden和s1都快满了，就发生minor gc，存活对象移动到s2.



然后接着就会使用Eden和s2区来分配新的对象



那文章下面为什么又提到系统继续运行，继续在Eden区里分配各种对象？难道不该是系统继续运行，继续在Eden区和s2区里分配各种对象，发生minor gc后，再移动到s1吗？这里的描述前后理解困惑



答：同学，你可能理解错一点了，对象都是在Eden区分配的，然后一次Minor GC过后，存活对象转移到S1区，此时Eden区就清空了，对吧？



然后接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S1里的存活对象有哪些，都转移到S2区。



接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S2里的存活对象有哪些，都转移到S1区。S1和S2就是用来放存活对象的，Eden区用来让系统分配新的对象进去。





问题

非常感激老师的耐心解答，那是不是可以理解为minor gc触发条件是Eden区放不下新的对象为触发条件？



然后追问一个关于full gc，是不是存在minor gc检查历次的放入老年代的对象大小小于本次实际要挪移的对象大小情况，从而才会说有minor gc发生后，再次full gc再minor gc的情况？感谢，感谢



答：

1、对的 

2、不对，是历次进入老年代的对象大小小于当前老年代的内存大小，才会触发minor gc；否则先是full gc给老年代腾空间，再minor gc





问题

忍不住再追加一个确认，会不会存在minor gc前检查历次进入老年代的对象均值是10M，然后当前老年代剩余50M，明显大于历次的10M这个值，于是触发minor gc正常执行，但执行后发现本次实际要放入老年代的对象大小大于均值且大于50M的情况，从而再来一次fullgc和minor gc这样的情况？感恩分享



答：会的，如果是这种情况，就是会先执行minor gc，然后发现老年代内存不足，触发full gc






问题

老师，每次Minor GC后剩余的是200MB是根据2 8法则推测的吗，我们平时做优化假设也是按照这个法则来吗？那如果我想知道实际中真正剩余多少内存的对象有什么办法吗？



答：不是的，这个数字是根据线上生产日志判断出来的，后续会教大家看gc日志，很清晰可以看到每分钟minor gc的时候多少对象进入老年代





问题

打卡。今天这个案例很好的结合估算内存压力大小和新老代回收机制进行了产线问题排查，这个思路在以后的工作中也很重要，学习了。



答：是的，建议直接按照这个案例背景从头到尾画一下整个内存分析的全流程和优化过程






问题

老师，评估每次任务或者每秒系统产生的数据大小是不是有专门的工具可以结合起来看。



答：是的，后续会带着动手操作一些工具的使用，这里就是先讲原理，结合案例说明原理





问题

每个计算计算任务1万条数据需要计算10秒钟，假设此时计算出80个计算任务都执行成功了。。。卡在这里了



后来想明白了：假设1分钟100个计算任务，每个计算任务是10秒钟，在60秒到来的那一刻，只有50-60秒开始执行的计算任务是没有执行完毕的，占比1/6,100 / 6 = 16.66 。 所以可以大致估算还有20个计算任务还在计算中。



答：是的，线上生产系统大致就是这个比例



问题

关于空间分配担保有一点疑问 当老年代的可用内存空间小于新生代所有对象的总大小时, 无论有没有空间分配担保, 最坏的情况都是一次minor GC + Full Gc 



那为什么还需要这个分配担保?? 直接minor GC, 之后再进行那三种可能的判断不就行了, HandlePromotionFail的意义何在?



答：不是的，如果说没有开启一个检查，此时可能提前Full GC，那么这样就太频繁了；但是如果经过文章里说的检查机制，发现不需要Full GC那么就直接Minor GC；差别在于不需要频繁Full GC





问题

按照每一次Minor GC之前JVM都会检测老年代空间是否大于新生代对象的总大小。一般上线的环境下，控制Minor GC的频率后，如果资源是不是是尽量为老年代分配更大的空间。如果不行，就需要设置参数HandlePromationFail。



这样理解可以吗？老师



答：理解正确的，但是其实具体一个系统要如何分配Eden、Survivor、老年代的内存，其实是很有讲究的，主要得看系统运行的特点

# 022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

1、前文回顾



上周的文章已经给大家把整个JVM的核心运行原理全部梳理清楚了，大家现在应该对以下问题非常的清晰明了：



对象在新生代分配，然后什么时候会触发Minor GC


触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小，如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小

什么情况下Minor GC之前会提前触发Full GC，什么情况下会直接触发Minor GC

Minor GC之后有哪几种情况对象会进入老年代



而且大家也大概知道了垃圾回收器、垃圾回收线程、垃圾回收算法之间的关系，包括垃圾回收的过程中的“Stop the World”现象和场景对系统运行性能的影响。



这周我们就要来相对深入的研究一下常见的新生代和老年代的垃圾回收器的运行原理了，同时看看常见的垃圾回收参数一般会怎么来设置。



同时结合案例来研究一下在你上线一个新系统的时候，如何通过预估的手段和方法提前对系统的垃圾回收参数进行合理的设置。



2、最常用的新生代垃圾回收器：ParNew



一般来说，在之前多年里，假设没有最新的G1垃圾回收器的话，通常大家线上系统都是ParNew垃圾回收器作为新生代的垃圾回收器



当然现在即使有了G1，其实很多线上系统还是用的ParNew。



通常运行在服务器上的Java系统，都可以充分利用服务器的多核CPU的优势，所以大家可以想一下，假设你的服务器是4核CPU，如果对新生代垃圾回收的时候，仅仅使用单线程进行垃圾回收，是不是会导致没法充分利用CPU资源？



如下图：







比如上图，现在你在垃圾回收的时候，都把系统程序所有的工作线程全部停掉了，就一个垃圾回收线程在运行



那么此时4核CPU的资源根本没法充分利用，理论上4核CPU就可以支持4个垃圾回收线程并行执行，可以提升4倍的性能！



所以说，新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。



大家看下图，ParNew垃圾回收器如果一旦在合适的时机执行Minor GC的时候，就会把系统程序的工作线程全部停掉，禁止程序继续运行创建新的对象，然后自己就用多个垃圾回收线程去进行垃圾回收，回收的机制和算法就跟之前说的是一样的。







3、如何为线上系统指定使用ParNew垃圾回收器？

一般来说，对于线上系统部署启动的时候，我们之前都看过多种方式来设置JVM参数了，在Eclipse/IntelliJ IDEA中可以设置Debug JVM Arguments，使用“java -jar”命令启动时直接在后面跟上JVM参数即可



部署到Tomcat时可以在Tomcat的catalina.sh中设置Tomcat的JVM参数，使用Spring Boot也可以在启动时指定JVM参数。



那么在启动系统的时候如果要指定使用ParNew垃圾回收器，是用什么参数呢？



很简单，使用“-XX:+UseParNewGC”选项，只要加入这个选项，JVM启动之后对新生代进行垃圾回收的，就是ParNew垃圾回收器了。



那么Minor GC的时机，检查机制，包括垃圾回收的具体过程，以及对象升入老年代的机制，都是我们之前说过的那套原理了，只不过大家要知道，ParNew会使用多个线程来进行垃圾回收。



4、ParNew垃圾回收器默认情况下的线程数量

因为现在一般我们部署系统的服务器都是多核CPU的，所以为了在垃圾回收的时候充分利用多核CPU的资源，一旦我们指定了使用ParNew垃圾回收器之后，他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的。



比如我们线上机器假设用的是4核CPU，或者8核CPU，或者16核CPU，那么此时ParNew的垃圾回收线程数就会分别是4个线程、8个线程、16个线程



这个东西一般不用我们手动去调节，因为跟CPU核数一样的线程数量，是可以充分进行并行处理的。



比如下图，大家可以看到，每个线程都通过一个CPU在运行。







但是如果你一定要自己调节ParNew的垃圾回收线程数量，也是可以的，使用“-XX:ParallelGCThreads”参数即可，通过他可以设置线程的数量



但是建议一般不要随意动这个参数，如果要优化，具体结合后续的案例我们给大家展开。



5、本文总结

这篇文章篇幅不长，主要介绍一下ParNew垃圾回收器，其实垃圾回收器的工作原理之前上周就全部介绍过了



这周的第一篇文章，主要就是对ParNew垃圾回收器本身的多线程原理和相关的参数做一些说明。



6、昨日思考题

上篇文章让大家思考了一个问题，其实反而在这篇文章里要多花点时间来说明。



之前让大家思考的问题就是：



到底是用单线程垃圾回收好，还是多线程垃圾回收好？

到底是Serial垃圾回收器好还是ParNew垃圾回收器好？



对这个问题要给大家略微展开做点解释。



启动系统的时候是可以区分服务器模式和客户端模式的，如果你启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。



他们俩的区别就是，如果你的系统部署在比如4核8G的Linux服务器上，那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。



那么服务器模式和客户端模式的区别是啥呢？



服务器模式通常运行我们的网站系统、电商系统、业务系统、APP后台系统之类的大型系统，一般都是多核CPU



所以此时如果要垃圾回收，那么肯定是用ParNew更好，因为多线程并行垃圾回收，充分利用多核CPU资源，可以提升性能。如下图。







反之如果你部署在服务器上，但是你用了单线程垃圾回收，那么就有一些CPU是被浪费了，根本没用上



比如下图。







那么如果你的Java程序是一个客户端程序，比如类似百度云网盘的Windows客户端，或者是印象笔记的Windows客户端，运行在Windows个人操作系统上呢？



这种操作系统很多都是单核CPU，此时你如果要是还是用ParNew来进行垃圾回收，就会导致一个CPU运行多个线程，反而加重了性能开销，可能效率还不如单线程好



因为单CPU运行多线程会导致频繁的线上上下文切换，有效率开销，如下图。







所以如果是类似于那种运行在Windows上的客户端程序，建议采用Serial垃圾回收器，单CPU单线程垃圾回收即可，反而效率更高，如下图。





但是其实现在一般很少有用Java写客户端程序的，几乎很少见，Java现在主要是用来构建复杂的大规模后端业务系统的，所以常见的还是用“-server”指定为服务器模式，然后配合ParNew多线程垃圾回收器。



但是大家还是应该清楚单线程和多线程对垃圾回收的适用场景。



7、今日思考题

其实我们一直是鼓励大家在评论区提出有价值的提问的，有自己的思考在里面



昨天有个同学提了一个自己经历过的JVM的面试题，我觉得非常好，给出来让大家思考一下：



“一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答（这里指该同学回答）: 

加大分代年龄，比如默认15加到30; 

修改新生代老年代比例，比如新生代老年代比例改成2:1 

修改e区和s区比例，比如改成6:2:2



面试官说他们内部服务已经做到fullgc次数为0，只做ygc，想听听老师的意见



对于这个面试题，如果大家吃透了咱们这个专栏前三周的JVM原理和案例，完全可以把这个面试题回答的滴水不漏



结合案例和画图给面试官说明，而不是干巴巴的简单给几个方法，可以回答的有血有肉，让面试官无话可说。



其实要做到仅仅young gc，而几乎没有full gc是不难的，只要结合自己系统的运行，根据他的内存占用情况，GC后的对象存活情况，合理分配Eden、Survivor、老年代的内存大小，合理设置一些参数，即可做到。



End


# 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

1、前文回顾



本文我们就要进入最核心的老年代垃圾回收环节了，之前的文章大家看过之后对JVM的核心原理都有一定的了解了，年轻代的垃圾回收机制也都很清楚了，其实年轻代的垃圾回收通过复制算法来，还是比较简单的。



大家心里最希望的，就是对象都分配在新生代的Eden区，然后每次垃圾回收之后，存活对象都进入Survivor区，然后下一次垃圾回收后的存活对象都进入另外一个Survivor区。



这样几乎很少很少的对象会进入老年代里去，也就几乎不太会触发老年代的垃圾回收了。



但是理想很丰满，现实很骨干。其实大家想想，你们在写代码的时候，有谁会考虑垃圾回收啥的？不会有人考虑这个吧，就是不停的狂写代码，然后直接上线部署，根本没多少人会考虑自己的代码对垃圾回收的影响。



最多有经验的工程师上线之前，通过我们之前的案例讲解的方法估算一下系统的内存压力以及垃圾回收的运行模型，然后合理设置一下内存各个区域的大小，尽量避免太多对象进行老年代里去。



但是真实情况是，线上系统很可能就会因为各种各样的情况，导致很多对象进入老年代，然后甚至频繁触发老年代的Full GC。



之前我们用案例给大家演示过很多这种情况，比如说Survivor区太小，容纳不了每次Minor GC后的存活对象，导致对象频繁进入老年代，频繁触发老年代Full GC。



类似的情况其实很多，所以，咱们不能过于理想化的期待永远没有老年代GC，还是要对老年代的垃圾回收器是如何回收的，有一个了解和认识。



2、CMS垃圾回收的基本原理

一般老年代我们选择的垃圾回收器是CMS，他采用的是标记清理算法，其实非常简单，就是先用之前文章里讲过的标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉，如下图所示。







上面图里是一个老年代内存区域的对象分布情况，现在假设因为老年代内存空间小于了历次Minor GC后升入老年代对象的平均大小，判断Minor GC有风险，可能就会提前触发Full GC回收老年代的垃圾对象。



或者是一次Minor GC后的对象太多了，都要升入老年代，发现空间不足，出发了一次老年代的Full GC。



总之就是要进行Full GC了，此时所谓的标记-清理算法，其实就是我们之前给大家讲过的一个算法，先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。



先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉，如下图。







这种方法其实最大的问题，就是会造成很多内存碎片



大家看下图的红圈处就是所谓的内存碎片，这种碎片不大不小的，可能放不小 任何一个对象，那么这个内存就被浪费了，之前我们聊过这个问题。







这就是CMS采取的“标记-清理”算法。





3、如果Stop the World然后垃圾回收会如何？

现在大家思考一个问题，假设要先“Stop the World”，然后再采用“标记-清理”算法去回收垃圾，那么会有什么问题？



之前文章也说过了，如果停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长，很多响应无法处理。



所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。



4、CMS如何实现系统一边工作的同时进行垃圾回收？

CMS在执行一次垃圾回收的过程一共分为4个阶段：

初始标记

并发标记

重新标记

并发清理



我们一点一点来看。



首先，CMS要进行垃圾回收时，会先执行初始标记阶段，这个阶段会让系统的工作线程全部停止，进入“Stop the World”状态，如下图。







所谓的“初始标记”，他是说标记出来所有GC Roots直接引用的对象，这是啥意思呢？



比如下面的代码。



blob.png



在初始标记阶段，仅仅会通过“replicaManager”这个类的静态变量代表的GC Roots，去标记出来他直接引用的ReplicaManager对象，这就是初始标记的过程。



他不会去管ReplicaFetcher这种对象，因为ReplicaFetcher对象是被ReplicaManager类的“replicaFetcher”实例变量引用的



之前说过，方法的局部变量和类的静态变量是GC Roots。但是类的实例变量不是GC Roots。



如下图所示。





所以第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。



接着第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行



在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC Roots追踪。



所谓进行GC Roots追踪，意思就是对类似“ReplicaFetcher”之类的全部老年代里的对象，他会去看他被谁引用了？



比如这里是被“ReplicaManager”对象的实例变量引用了，接着会看，“ReplicaManager”对象被谁引用了？会发现被“Kafka”类的静态变量引用了。



那么此时可以认定“ReplicaFetcher”对象是被GC Roots间接引用的，所以此时就不需要回收他。如下图所示。







但是这个过程中，在进行并发标记的时候，系统程序会不停的工作，他可能会各种创建出来新的对象，部分对象可能成为垃圾，如下图所示。







第二个阶段，就是对老年代所有对象进行GC Roots追踪，其实是最耗时的



他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。



接着会进入第三个阶段，重新标记阶段



因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾



所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的，如下图。







所以此时进入第三阶段，要继续让系统程序停下来，再次进入“Stop the World”阶段。



然后重新标记下在第二阶段里新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况，如下图。







这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。



接着重新恢复系统程序的运行，进入第四阶段：并发清理



这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。



这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行，如下图。







5、对CMS的垃圾回收机制进行性能分析

其实大家看完CMS的垃圾回收机制之后，就会发现，他已经尽可能的进行了性能优化了



因为最耗时的，其实就是对老年代全部对相关进行GC Roots追踪，标记出来到底哪些可以回收，然后就是对各种垃圾对象从内存里清理掉，这是最耗时的。



但是他的第二阶段和第四阶段，都是和系统程序并发执行的，所以基本这两个最耗时的阶段对性能影响不大。



只有 第一个阶段和第三个阶段是需要“Stop the World”的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系统运行响应也不大。



明天的文章，我们就继续深入来看看CMS垃圾回收机制的各种细节以及一些参数一般如何设置。



6、昨日思考题

昨天的思考题，是一个学员真实面试中遇到的一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



该学员的回答: 

加大分代年龄，比如默认15加到30; 

修改新生代老年代比例，比如新生代老年代比例改成2:1 

修改e区和s区比例，比如改成6:2:2



其实让大家去梳理这个思路，就是希望大家多一些思考，多一些梳理和总结。答案就在我们之前讲过的案例里，大家只要结合那个案例分析，就知道解答这面试题的思路。



大家可以尝试着作答，将自己的答案发至评论区。



7、今日思考题

看完了新生代和老年代的垃圾回收机制之后，大家来思考一下：为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？



明天的文章我们会深入探讨CMS垃圾回收机制和对应的参数，同时解答这个问题。



End


# 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？


目录：

前文回顾

并发回收垃圾导致CPU资源紧张

Concurrent Mode Failure问题

内存碎片问题

昨日思考题解答

今日思考题




1、前文回顾

上篇文章用一步一图的方式给大家讲清楚了CMS垃圾回收的运行机制



简单来说，为了避免长时间“Stop the World”，CMS采用了4个阶段来垃圾回收，其中初始标记和重新标记，耗时很短，虽然会导致“Stop the World”，但是影响不大。



然后并发标记和并发清理，两个阶段耗时最长，但是是可以跟系统的工作线程并发运行的，所以对系统没太大影响。



这就是CMS的基本工作原理。



但是本文要更加深入的去说一说CMS垃圾回收期间的一些细节问题，同时给出CMS常见的JVM参数应该如何设置。



2、并发回收垃圾导致CPU资源紧张

首先大家回顾一下这个图。



CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。



并发标记的时候，需要对GC Roots进行深度追踪，看所有对象里面到底有多少人是存活的



但是因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时较高。并发清理，又需要把垃圾对象从各种随机的内存位置清理掉，也是比较耗时的。



所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。



我们用最普通的2核4G机器和4核8G机器来计算一下，假设是2核CPU，本来CPU资源就有限，结果此时CMS还会有个“(2 + 3) / 4” = 1个垃圾回收线程，去占用宝贵的一个CPU。



所以其实CMS这个并发垃圾回收的机制，第一个问题就是会消耗CPU资源。



3、Concurrent Mode Failure问题

第二个问题，是很多同学都很关注的一个问题，就是如下图



在并发清理阶段，CMS只不过是回收之前标记好的垃圾对象



但是这个阶段系统一直在运行，可能会随着系统运行让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“浮动垃圾”。





大家看上图那个红圈画的地方，那个对象就是在并发清理期间，系统程序可能先把某些对象分配在新生代，然后可能触发了一次Minor GC，一些对象进入了老年代，然后短时间内又没人引用这些对象了。



这种对象，就是老年代的“浮动垃圾”。



因为他虽然成为了垃圾，但是CMS只能回收之前标记出来的垃圾对象，不会回收他们，需要等到下一次GC的时候才会回收他们。



所以为了保证在CMS垃圾回收期间，还有一定的内存空间让一些对象可以进入老年代，一般会预留一些空间。



CMS垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就自动执行GC。



“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。



也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。



那么如果CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何？



这个时候，会发生Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。



此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生



然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。



所以在生产实践中，这个自动触发CMS垃圾回收的比例需要合理优化一下，避免“Concurrent Mode Failure”问题



接下来我们会用两篇文章结合案例来分析垃圾回收参数的设置。



4、内存碎片问题

之前给大家说过内存碎片的问题，就是老年代的CMS采用“标记-清理”算法，每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生。



如果内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间了，然后触发Full GC。



所以CMS不是完全就仅仅用“标记-清理”算法的，因为太多的内存碎片实际上会导致更加频繁的Full GC。



CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了



他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。



还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理。



如下图所示：





上图有一个画红圈的地方，就是说在垃圾回收之后，有一些内存碎片，接着会停止工作线程进行碎片整理，如下图：







大家可以看到，内存碎片整理完之后，存活对象都放在一起，然后空出来大片连续内存空间可供使用。



5、昨日思考题解答

昨天给大家出来一个思考题，意思是说，为啥老年代的Full GC要比新生代的Minor GC慢很多倍，一般在10倍以上？



其实原因很简单，大家分析一下他们俩的执行过程。



新生代执行速度其实很快，因为直接从GC Roots出发就追踪哪些对象是活的就行了，新生代存活对象是很少的，这个速度是极快的，不需要追踪多少对象。



然后直接把存活对象放入Survivor中，就一次性直接回收Eden和之前使用的Survivor了。



但是CMS的Full GC呢？



在并发标记阶段，他需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；



其次并发清理阶段，他不是一次性回收一大片内存，而是找到零零散散在各个地方的垃圾对象，速度也很慢；



最后完事儿了，还得执行一次内存碎片整理，把大量的存活对象给挪在一起，空出来连续内存空间，这个过程还得“Stop the World”，那就更慢了。



万一并发清理期间，剩余内存空间不足以存放要进入老年代的对象了，引发了“Concurrent Mode Failure”问题，那更是麻烦，还得立马用“Serial Old”垃圾回收器，“Stop the World”之后慢慢重新来一遍回收的过程，这更是耗时了。



所以综上所述，老年代的垃圾回收，就是一个字：慢



6、今日思考题

今天是一个小问题，让大家复习梳理一下，还记得说过几个触发老年代GC的时机吗？



第一是老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；



第二是老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；



第三是新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足。



上述情况都会导致老年代Full GC。



今天加了一个触发时机，就是“-XX:CMSInitiatingOccupancyFaction”参数



刨除掉上述几种情况，如果老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC。



希望大家认真回顾一下上述过程，把老年代Full GC的几个时机都仔细梳理一下。



End


# 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？


（提示：食用本案例之前，请务必充分理解专栏之前两周的文章！）



1、案例背景引入

按照惯例，我们接下来会用案例驱动来带着大家分析到底该如何在特定场景下，预估系统的内存使用模型



然后合理优化新生代、老年代、Eden和Survivor各个区域的内存大小，接着再尽量优化参数避免新生代的对象进入老年代，尽量让对象留在新生代里被回收掉。



我们这里的背景是电商系统，电商系统其实一般会拆分为很多的子系统独立部署，比如商品系统、订单系统、促销系统、库存系统、仓储系统、会员系统，等等



我们这里就以比较核心的订单系统作为例子来说明。



我们的案例背景是每日上亿请求量的电商系统，那么大家可以来推算一下每日上亿请求量的电商系统，他会每日有多少活跃用户？



一般按每个用户平均访问20次来计算，那么上亿请求量，大致需要有500万日活用户。



那么继续来推算一下，这500万的日活用户都是会进来进行大量的浏览，那么多少人会下订单？



这里可以按照10%的付费转化率来计算，每天大概有50万人会下订单，那么大致就是每天会有50万订单。



这50万订单算他集中在每天4小时的高峰期内，那么其实平均下来每秒钟大概也就几十个订单，大家是不是觉得根本没啥可说的？



因为几十个订单的压力下，根本就不需要对JVM多关注，基本上就是每秒钟占用一些新生代内存，隔很久新生代才会满，然后一次Minor GC后垃圾对象清理掉，内存就空出来了，几乎无压力。



2、特殊的电商大促场景

但是如果你要是考虑到特殊的电商大促场景，就不会这么想了



因为很多中小型的电商平台，确实平时系统压力其实没那么大，也没太大的高并发，每秒几千并发压力就算是高峰压力了。



但是如果遇到一些大促场景，比如双11什么的，情况就不同了。



假设在类似双11的节日里，零点的时候，很多人等着大促开始就要剁手购物，这个时候，可能在大促开始的短短10分钟内，瞬间就会有50万订单。



那么此时每秒就会有接近1000的下单请求，我们就针对这种大促场景来对订单系统的内存使用模型分析一下。



3、抗住大促的瞬时压力需要几台机器？

那么要抗住大促期间的瞬时下单压力，订单系统需要部署几台机器呢？



基本上可以按3台来算，就是每台机器每秒需要抗300个下单请求。这个也是非常合理的，而且需要假设订单系统部署的就是最普通的标配4核8G机器。



从机器本身的CPU资源和内存资源角度，抗住每秒300个下单请求是没问题的。



但是问题就在于需要对JVM有限的内存资源进行合理的分配和优化，包括对垃圾回收进行合理的优化，让JVM的GC次数尽可能最少，而且尽量避免Full GC，这样可以尽可能减少JVM的GC对高峰期的系统新更难的影响。





4、大促高峰期订单系统的内存使用模型估算



背景已经全部说完了，接下来咱们就得来预估订单系统的内存使用模型了.



基本上可以按照每秒钟处理300个下单请求来估算，其实无论是订单处理性能还是并发情况，都跟生产很接近



因为处理下单请求是比较耗时的，涉及很多接口的调用，基本上每秒处理100~300个下单请求是差不多的。



那么每个订单咱们就按1kb的大小来估算，单单是300个订单就会有300kb的内存开销



然后算上订单对象连带的订单条目对象、库存、促销、优惠券等等一系列的其他业务对象，一般需要对单个对象开销放大10倍~20倍。



此外，除了下单之外，这个订单系统还会有很多订单相关的其他操作，比如订单查询之类的，所以连带算起来，可以往大了估算，再扩大10倍的量。



那么每秒钟会有大概300kb * 20 * 10 = 60mb的内存开销。但是一秒过后，可以认为这60mb的对象就是垃圾了，因为300个订单处理完了，所有相关对象都失去了引用，可以回收的状态。



大家看下图





5、内存到底该如何分配？



假设我们有4核8G的机器，那么给JVM的内存一般会到4G，剩下几个G会留点空余给操作系统之类的来使用，不要想着把机器内存一下子都耗尽，其中堆内存我们可以给3G，新生代我们可以给到1.5G，老年代也是1.5G。



然后每个线程的Java虚拟机栈有1M，那么JVM里如果有几百个线程大概会有几百M



然后再给永久代256M内存，基本上这4G内存就差不多了。



同时还要记得设置一些必要的参数，比如说打开“-XX:HandlePromotionFailure”选项，JVM参数如下所示：（不熟悉这个参数的，可以回头复习一下专栏之前的文章）



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure”



但是“-XX:HandlePromotionFailure”参数在JDK 1.6以后就被废弃了，所以现在一般都不会在生产环境里设置这个参数了。在JDK 1.6以后，只要判断“老年代可用空间”> “新生代对象总和”，或者“老年代可用空间”> “历次Minor GC升入老年代对象的平均大小”，两个条件满足一个，就可以直接进行Minor GC，不需要提前触发Full GC了。



所以实际上，如果大家用的是JDK  1.7或者JDK 1.8，那么JVM参数就保持如下即可，后面也都不再加入这个参数了：

“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M”



此时JVM内存入下图所示。



接着就很明确了，订单系统的系统程序在大促期间不停的运行，每秒处理300个订单，都会占据新生代60MB的内存空间



但是1秒过后这60MB对象都会变成垃圾，那么新生代1.5G的内存空间大概需要25秒就会占满，如下图。





25秒过后就会要进行Minor GC了，此时因为有“-XX:HandlePromotionFailure”选项，所以你可以认为需要进行的检查，主要就是比较 “老年代可用空间大小”和“历次Minor GC后进入老年代对象的平均大小”，刚开始肯定这个检查是可以通过的。



所以Minor GC直接运行，一下子可以回收掉99%的新生代对象，因为除了最近一秒的订单请求还在处理，大部分订单早就处理完了，所以此时可能存活对象就100MB左右。



但是这里问题来了，如果“-XX:SurvivorRatio”参数默认值为8，那么此时新生代里Eden区大概占据了1.2GB内存，每个Survivor区是150MB的内存，如下图。





所以Eden区1.2GB满了就要进行Minor GC了，因此大概只需要20秒，就会把Eden区塞满，就要进行Minor GC了。



然后GC后存活对象在100MB左右，会放入S1区域内。如下图。







然后再次运行20秒，把Eden区占满，再次垃圾回收Eden和S1中的对象，存活对象可能还是在100MB左右会进入S2区，如下图。







此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8”



6、新生代垃圾回收优化之一：Survivor空间够不够



首先在进行JVM优化的时候，第一个要考虑的问题，就是你通过估算，你的新生代的Survivor区到底够不够



按照上述逻辑，首先每次新生代垃圾回收在100MB左右，有可能会突破150MB，那么岂不是经常会出现Minor GC过后的对象无法放入Survivor中？然后岂不是频繁会让对象进入老年代？



还有，即使Minor GC后的对象少于150MB，但是即使是100MB的对象进入Survivor区，因为这是一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代。

（关于jvm的垃圾回收规则，如果忘记了的同学，请参加专栏之前的文章）



所以其实按照我们这个模型来说，Survivor区域是明显不足的。



这里其实建议的是调整新生代和老年代的大小，因为这种普通业务系统，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，首先得先让对象尽量留在新生代里。



所以此时可以考虑把新生代调整为2G，老年代为1G，那么此时Eden为1.6G，每个Survivor为200MB，如下图。







这个时候，Survivor区域变大，就大大降低了新生代GC过后存活对象在Survivor里放不下的问题，或者是同龄对象超过Survivor 50%的问题。



这样就大大降低了新生代对象进入老年代的概率。



此时JVM的参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8”



其实对任何系统，首先类似上文的内存使用模型预估以及合理的分配内存，尽量让每次Minor GC后的对象都留在Survivor里，不要进入老年代，这是你首先要进行优化的一个地方。



7、新生代对象躲过多少次垃圾回收后进入老年代？



大家都知道，除了Minor GC后对象无法放入Survivor会导致一批对象进入老年代之外，还有就是有些对象连续躲过15次垃圾回收后会自动升入老年代。



其实按照上述内存运行模型，基本上20多秒触发一次Minor GC，那么如果按照“-XX:MaxTenuringThreshold”参数的默认值15次来说，你要是连续躲过15次GC，就是一个对象在新生代停留超过了几分钟了，此时他进入老年代也是应该的。



有些博客会说，应该提高这个参数，比如增加到20次，或者30次，其实那种说法根本是不对的



因为你对这个参数考虑必须结合系统的运行模型来说，如果躲过15次GC都几分钟了，一个对象几分钟都不能被回收，说明肯定是系统里类似用@Service、@Controller之类的注解标注的那种需要长期存活的核心业务逻辑组件。



那么他就应该进入老年代，何况这种对象一般很少，一个系统累计起来最多也就几十MB而已。



所以你说你提高“-XX:MaxTenuringThreshold”参数的值，有啥用呢？让这些对象在新生代里多停留几分钟？



所以说，考虑问题，一定不要人云亦云，要结合运行原理，自己推演和思考，不同的业务系统还都是不一样的。



其实这个参数甚至你都可以降低他的值，比如降低到5次，也就是说一个对象如果躲过5次Minor GC，在新生代里停留超过1分钟了，尽快就让他进入老年代，别在新生代里占着内存了。



总之，对于这个参数务必是结合你的系统具体运行的模型来考虑。



要记住，JVM没有万能的最佳参数，但是有一套通用的分析和优化的方法。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5”



8、多大的对象直接进入老年代？



另外有一个逻辑是说，大对象可以直接进入老年代 ，因为大对象说明是要长期存活和使用的



比如在JVM里可能会缓存一些数据，这个一般可以结合自己系统中到底有没有创建大对象来决定。



但是一般来说，给他设置个1MB足以，因为一般很少有超过1MB的大对象。如果有，可能是你提前分配了一个大数组、大List之类的东西用来放缓存的数据。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M”



9、别忘了指定垃圾回收器



同时大家别忘了要指定垃圾回收器，新生代使用ParNew，老年代使用CMS，如下JVM参数 ：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



ParNew垃圾回收器的核心参数，其实就是配套的新生代内存大小、Eden和Survivor的比例，只要你设置合理，避免Minor GC后对象放不下Survivor进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空间，那么Minor GC一般就没什么问题。



然后根据你的系统运行模型，合理设置“-XX:MaxTenuringThreshold”，让那些长期存活的对象，抓紧尽快进入老年代，别在新生代里一直待着。



这样基本上一个初步的优化好的JVM参数就结合你的业务出来了。明天我们继续结合案例来分析 老年代的垃圾回收和参数优化方式。



10、昨日思考题



上次让大家梳理了一下触发Full GC的几个时机，大家一定要好好梳理一下。



11、今日思考题



大家看完这个案例，可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型：



每秒占用多少内存？

多长时间触发一次Minor GC？

一般Minor GC后有多少存活对象？

Survivor能放的下吗？

会不会频繁因为Survivor放不下导致对象进入老年代？

会不会因动态年龄判断规则进入老年代？



End



# 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？

1、前文回顾



上一篇文章我们已经给大家介绍了一个每日百万日活以及上亿请求量的电商系统的案例背景，同时采用这个中型电商系统在大促期间的瞬时高峰下单场景，作为我们的JVM优化分析的一个场景，推测出来在大促高峰期，每秒每台机器会有300个下单请求。



进而推测出每秒钟会使用60MB的内存，然后根据这个背景推算出来了我们一台4核8G的机器上，应该如何合理的给JVM各个区域分配内存



进而可以保证每隔20多秒一次新生代GC后的100MB左右的存活对象，会进入200MB的Survivor区域内，一般不会因为Survivor塞不下或者是动态年龄判定规则让对象进入老年代中。



同时还根据Minor GC的频率，合理降低了大龄对象进入老年代的年龄，尽快让一些长期存活的对象赶紧进入老年代，不要停留在新生代里，如下图所示。







此时的JVM参数如下所示：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



2、在案例背景下什么时候对象会进入老年代？



接着我们来分析一个问题，在目前优化好的背景下，一般什么情况下会让一些对象进入老年代呢？



首先第一种情况，那绝对就是“-XX:MaxTenuringThreshold=5”这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。



这种对象一般就是一些@Service、@Controller之类的注解标注的那种系统业务逻辑组件，这种对象实例一般全局就有一个实例就可以了，要一直使用的



所以一般会长期被GC Roots引用，这种对象一般不会太多，大概最多一个系统就几十MB这种对象。



所以此时类似这样的长期存活的对象就会进入老年代中，如下图所示。





此外，按照我们的JVM参数，如果分配一个超过1MB的大对象，比如说你创建一个大数组或者是大List之类的，就会直接进入老年代。



但是这种大对象我们假设在这个案例里是没有的，所以可以忽略不计。



此外就是Minor GC过后可能存活的对象超过200MB放不下Survivor了，或者是一下子占到超过Surviovr的50%，此时会有一些对象进入老年代中。



但是我们之前对新生代的JVM参数进行优化，就是为了避免这种情况，经过我们的测算，这种概率应该是很低的。



但是虽说是很低，也不能完全是是没有这种情况，比如某一次GC过后可能刚好机缘巧合有超过200MB对象，就会进入老年代里。



我们可以做一个假设，大概就是这个订单系统在大促期间，每隔5分钟会在Minor GC之后有一小批对象进入老年代，大概200MB左右的大小，如下图所示。







3、大促期间多久会触发一次Full GC？

接着我们来研究一下，那么按照Full GC的触发条件，多久会触发一次Full GC？



首先来看看，Full GC的触发条件目前我们学习到的有以下4种：



（1）没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可以有1.8G



那么会导致每次Minor GC前一检查，都发现“老年代可用内存” < “新生代总对象大小”，这会导致每次Minor GC前都触发Full GC。



当然，上篇文章提到过了，现在JDK 1.6以后的版本废弃了这个参数，其实只要满足下面第二个条件就可以直接触发Minor GC，不需要触发Full GC。



（2）每次Minor GC之前，都检查一下“老年代可用内存空间” < “历次Minor GC后升入老年代的平均对象大小”



其实按照我们目前设定的背景，要很多次Minor GC之后才可能有一两次碰巧会有200MB对象升入老年代，所以这个“历次Minor GC后升入老年代的平均对象大小”，基本是很小的。



（3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了



（4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC



其实在真正的系统运行期间，可能会慢慢的有对象进入老年代，但是因为新生代我们优化过了内存分配，所以对象进入老年代的速度是很慢的。



所以很可能是在系统运行半小时~1小时之后，才会有接近 1GB的对象进入老年代。



此时可能会因为上述的条件234中任何一个满足了，就触发Full GC。



但是这三个条件一般都需要老年代近乎占满的时候，才有可能会触发。



大家可以思考一下，我们假设在大促期间，订单系统运行1小时之后，大促下单高峰期几乎都快过了，此时才可能会触发一次Full GC。



注意，这个推论很重要，因为按照大促开始10分钟就有50万订单来计算，其实大促开始后一堆用户等着下单剁手购物



那么1小时候就可能有两三百万订单了，这是一年难得罕见的节日大促才会有的，然后这个高峰期过后，基本订单系统访问压力就很小了，那么GC的问题几乎就更不算什么了。



所以经过新生代的优化，可以推算出，基本上大促高峰期内，也就可能1小时才1次Full GC，然后高峰期一过，随着订单系统慢慢运行，可能就要几个小时才有一次Full GC。



4、老年代GC的时候会发生“Concurrent Mode Failure”吗？

经过前面的推算，我们基本可知道，假设就是订单系统运行1小时之后，老年代大概有900MB的对象了，剩余可用空间仅仅只有100MB了，此时就会触发一次Full GC，如下图。





但是有一个很大的问题，就是CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，所以此时老年代空闲空间仅剩100MB了



然后此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，此时会如何？



如下图



这个时候就会触发“Concurrent Mode Failure”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old，直接禁止程序运行，然后单线程进行老年代垃圾回收，回收掉900MB对象过后，再让系统继续运行，如下图。





所以可以想一下，这种情况可能发生吗？



概率是挺小的，因为必须是CMS触发Full GC的时候，系统运行期间还让200MB对象进入老年代，这个概率其实本身就很小，但是理论上是有可能的。



大家此时需要思考一下，相对于这种小概率的事件而言，有必要去调整参数吗？



暂时看来是没有必要的，不需要针对小概率事件特意优化参数。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92”



5、CMS垃圾回收之后进行内存碎片整理的频率应该多高？

接着来看最后一个问题，在CMS完成Full GC之后，一般需要执行内存碎片的整理，可以设置多少次Full GC之后执行一次内存碎片整理，但是我们有必要修改这些参数吗？



其实没必要，因为通过前面的分析，在大促高峰期，Full GC可能也就1小时执行一次，然后大促高峰期过去之后，就没那么多的订单了，此时可能几个小时才会有一次Full GC。



所以就保持默认的设置，每次Full GC之后都执行一次内存碎片整理就可以，目前JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”



其实从本文可以看到，Full GC优化的前提是Minor GC的优化，Minor GC的优化的前提是合理分配内存空间，合理分配内存空间的前提是对系统运行期间的内存使用模型进行预估。



其实对很多普通的Java系统而言，只要对系统运行期间的内存使用模型做好预估，然后分配好合理的内存空间，尽量让Minor GC之后的存活对象留在Survivor里不要去老年代，然后其余的GC参数不做太多优化，系统性能基本上就不会太差。



6、昨日思考题

昨天让大家可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型，每秒占用多少内存，多长时间触发一次Minor GC，一般Minor GC后有多少存活对象，Survivor能放的下吗？会不会频繁因为Survivor放不下导致对象进入老年代？会不会因动态年龄判断规则进入老年代？



希望大家好好吸收这里的精华，真正能够从业务系统运行的层面以及内存使用模型的层面去看你的各种JVM参数在系统运行期间起到的作用。



7、今日思考题

今天的思考题跟昨天是一样的，大家去思考一下，对你的系统运行模型做出预估，看一般多久会塞满老年代触发Full GC？触发Full GC的时候是否需要优化CMS相关的各种参数？



End


# 027、第4周作业：看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？

第4周作业：

看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？



本周作业就是让大家可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小，然后去估算一下你的系统运行模型，每秒占用多少内存，多长时间触发一次Minor GC。



一般Minor GC后有多少存活对象，Survivor能放的下吗？会不会频繁因为Survivor放不下导致对象进入老年代？会不会因动态年龄判断规则进入老年代？



根据案例的思路看看，你的各个内存区域应该给多大的大小，保证新生代gc后的存活对象尽量都留在Survivor里。



另外，对你的系统运行模型做出预估，看一般多久会塞满老年代触发Full GC？触发Full GC的时候是否需要优化CMS相关的各种参数？



结合案例学到的知识，自己动手画图，把你们系统的运行模型和内存分配，gc触发，全流程和模型都画出来，一定要自己去分析、自己思考、自己画图，这样才真正把知识给吸收了。



# 028、第4周答疑：本周问题统一答疑
第4周答疑：本周问题统一答疑



学员评论：

看了看线上一个服务，24天，FGC 121次，真恐怖。参数使用的默认的，没有进行设置。新生代的最大容量为66m左右,老年代133m，YGC 79000多次,FGC 121次。好可怕。



答：对的，你们的系统应该用户不太介意性能问题，不然这个系统早就不行了



问题

分配担保这里捋了一下有点疑问，如果没有设置分配担保失败的话，那么老年代可用内存小于新生代所有对象内存大小时直接full gc吗？



那这样如果新生代很大，老年代还剩余很大的内存就进行fullgc，是不是有点过于着急？感觉太浪费了。这个【允许分配担保失败】jvm默认是不允许的吗？



答：没错，没有老年代担保失败的设置，就会频繁触发Full GC，所以一般都要打开





问题

老师，请教一下，一个机器能开多少线程？取决于什么？



答：给你一个大致的数字：如果是4核CPU，本身JVM就有一些后台线程，还有你使用的一些框架可能也会有后台线程。



所以你自己的系统一般开启线程数量在几十个，比如50左右的一个数量，基本就差不多了。



大概系统所有线程加起来有100+，此时高峰期这么多线程同时工作，CPU负载基本就满负荷了



学员总结

个人感觉单线程和多线程各有优缺点，单线程是占用cpu资源少，对于单核的服务器来讲是不错的



而多线程对于多核cpu更好，与之带来的优势也很明显，就是多线程显然处理起来效率更高，使得stop the world 问题恢复的更快





问题

我想到一个问题：文章说的新老年代内存划分应该是在jvm中是一种类似“规范”的原理。



但是那个minor gc之前会检查老年代大小，然后后续等一系列判断。这些原理是所有版本的jvm都一致的吗。跟垃圾回收器的选择是否有关系？



比如如果选择了g1 作为收集器，是否在minor  gc的过程也是一样？



答：基本上在g1之前都是这套原理，但是g1开始就变化了，从内存分配模型和垃圾回收机制，全部会变，所以后续有一周会专门剖析g1的原理



问题

老师，这个案例怎么也得16到17个线程同时并发处理，才能达到一分钟单台机器处理100个任务吧！



答：对的，生产系统单机开启了30+工作线程



问题

如果我在tomcat部署多个服务，JVM启动个数是根据服务来算的，还是根据tomcat来算的？我好像只能调试tomcat的堆栈分配情况。麻烦前辈解答下。



答：一个Tomcat启动多个Web应用，那JVM只有一个，就是Tomccat自己，你的Web应用都是一堆代码，由Tomcat根据 配置文件来对指定的请求调用你的代码



问题

看了今天文章，感觉和自己认知有点冲突，我之前一直的认知：minor gc是新生代的gc，major gc是老年代的gc，fullgc是新生代老年代和永久代的gc



marjor gc是包含在fullgc中的，然后stop the world会在full gc的时候发生,minor gc不会发生。这是我的认知。



但是文中说minor gc也会stop the world。这就有点冲突了。请老师指正，到底什么时候发生STW



答：看来你可能之前的认识是没有从本质认识垃圾回收和Stop the World



不管是老年代回收还是新生代回收，都要Stop the World，因为必须让程序别创建新对象，才能回收垃圾对象。



Full GC和Major GC其实是一个概念，都是指的老年代的GC，只不过一般会带着一次Minor GC，也就是Young GC，他们是一个概念多种名词



学员回答思考题

思考题，采用parnew+cms垃圾回收器如何只做ygc？



回答:和垃圾收集器没有什么关系，不同垃圾收集器，差别只在于性能和吞吐量的区别。并不影响垃圾回收时机。



根据堆中对象生存周期特点，合理分配eden s0 s1 大小，尽量让对象在新生代就被回收，需要注意的是要开启内存担保



答：是的，回答正确



问题

之前提到minor  gc是很快的，这么多文章看下来没有特别明确说为什么快



我的理解是:新生代垃圾回收存活很少 且采用了复制算法，比标记整理效率高。 老师还有其他原因？



答：其实就这个原因，存活对象少，迁移内存很快，然后一次性清理垃圾对象，这个速度就是快。



老年代要先挪动对象压在一起，存活对象那么多，这里涉及到漫长的对象移动的过程，所以速度慢



问题

思考题： 一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



学员回答：我觉的应该考虑两个方向：避免FullGC和避免年轻代对象进入老年代 



避免FullGC 

1、保证老年代可用空间大于新生代所有对象，避免MinorGC前进行FullGC 



2、如果1可以保证，那后面-XX：HandlePromotionFailure、进入老年代的对象平均大小等比较就不需要考虑了 



3、保证MinorGC后存活对象不大于Survivor空间 



避免年轻代对象进入老年代 

1、根据实际情况查看每次MinorGC后存活对象的大小，设置合适的Survivor区域大小，保证存活对象进入survivor区，而不是进入老年代 



2、根据对象存活的时间以及MinorGC的间隔时间，确定年龄。比如：3分钟一次MinorGC，而对象可以存活1个小时，那就把对象年龄设置到20，避免对象15岁进入老年代 



3、大对象如果偶尔创建一个，可以设置-XX:PretenureSizeThreshold，使其分配至年轻代。如果创建销毁频繁，就让其直接进入老年代，利用对象池避免频繁创建销毁



答：你思考的非常好，其实在我们的那个案例里就说明了思路



问题

为什么新生代用的是复制算法?老年代用的是标记整理算法？既然复制算法比较快，为什么老年代不采用新生代的这种优化版的复制算法呢？



答：因为老年代的存活对象太多了，采用复制算法来回挪动大量的对象，效率更差





问题

我觉得老年代垃圾回收慢，是在并发标记阶段对所有老年代对象进行GC Roots追踪慢，要追踪到根源,而新生代的对象可能90%以上都不会存活,所以新生代gc快



补充，cms回收过程有4个阶段，会进入两次STW,这个也是影响速度的很大原因吧



答：是的，老年代垃圾回收，这个GC Roots追踪所有对象，因为老年代存活对象太多，所以耗时更长。还有考虑一下垃圾回收和整理这个环节，明天会分析



问题

这种每周总结一次答疑非常好，这样我们就不用每篇文章都去看评论了。老师已经把精华的问题总结出来了 ，非常好 点赞，爱你 么么哒



答：是的，每周的作业是一定要做的，认真做每周的作业，绝对可以把一周的内容吃透，消化成自己肚子里的东西，看答疑可以拓宽思路，看别人怎么提问的





问题

老师有一个问题，都已经full gc了，程序还并行运行，创建出来的对象放那？会一直触发full gc吗？



如果对象太多堆放不下，会等着full gc完成吗？这个时候也是世界停止吗？



答：对的，会继续放老年代，还可能会同步触发Minor GC，也可能有新的对象进入老年代，还可能有些老年代的对象失去了引用，啥都会发生，所以并发标记环节，很多是不准确的



为什么老年代垃圾回收比年轻代慢很多？学员自己的回答：

年轻代一般存活对象少，采用复制算法，从GC root出发标记存活对象，直接把存活对象复制到另一块内存，其余直接清除。



对于老年代，对象存活量大，每次遍历堆分别去标记存活对象和垃圾对象，再遍历把垃圾对象清除了，最后还要移动存活对象，防止太多内存碎片。



因为存活量大，耗时的地方我觉得在gc root引用的追踪还有存活对象的移动



答：对的，理解很好





问题

老师今天讲的cms垃圾回收器 初始标记 并发标记 重新标记 并发清理 



其中重新标记老师说只会对并发标记改动的对象进行标记，是由什么结构存储了并发标记改动的对象吗？ 不然它这么快找到并发标记改动的对象



答：对的，他会内置记录在并发标记期间，被新建的对象，被变动的对象，有数据结构记录，所以这个阶段很快





问题

老师，当发生GC的时候，做标记的阶段，回收器是从Gc root出发去搜索吗？还是遍历堆里的所有对象，如果这样的话，该对象自身怎么知道谁在引用它呢？



还有第二阶段，它是怎么做到一边标记存活对象一边标记垃圾对象的？



答：

1、从GC Roots出发，去标记所有对象 

2、他只要让垃圾回收线程工作的同时，让系统的工作线程也同时工作不就可以了



为啥老年代垃圾回收慢很多？学员自己的回答：

老年代的垃圾回收慢主要是因为剩余的存活对象很多，可能达到90%，这样子就不得不采用标记整理法



标记的过程中，并发标记是很慢的，因为对象变量要不断往上追踪看有没有gc root引用，不像方法局部变量和类变量那样直接被gc root引用，查找对象gc roots引用可能要向上追踪的次数比较多，所以耗时间



另外一个耗时间的地方就是并发清理，这个过程慢的原因是为了使得内存紧凑些，尽量不要出现内存碎片，是个边清理变移动的过程。



以上是我的分析，老师看我理解的对吗？



答：对的，理解的非常好



问题

eden区内存大小超过old，如果没有开启允许担保失败参数的话，岂不是young gc之前都会full gc了?



答：对的，所以开启那个担保机制



问题

通过GC Roots查找，直接或间接引用到的对象，就是存活的，进行标记。剩下的就是垃圾对象。在并发清除阶段就会清除了。 是这样吗？



答：是的





问题

针对web服务，POJO类一般都是在新生代，而通过@service @controller @component 等注解创建的对象一般都是在老年代。



针对一些纯java代码的后台跑批服务，基本都是新生代，除了一些通过静态变量或者常量引用的类，或者通过单例创建的类（本质也是通过静态变量引用）。



答：是的，总结的很好



问题

初始标记从GC Roots开始查找直接引用的对象。 并发标记是从对象出发，查看对象是否直接或间接有GC Roots引用 由于并发标记会查看所有对象，且大多数对象都是存活的，所以过程会很耗时。 是这样吗？



答：其实并发标记也是从GC Roots出发的，通过每个对象的引用地址查看哪些对象是存活的，确实因为存活对象一般较多，所以很耗时



问题

full gc同时一般会伴随着一次minor GC，如果第一次full GC过程中，因为新创建的对象原因又达到了触发fullGC的条件，首先还是会先minorGC，然后尝试放入新生代



但此时老年代还没有回收完成，再触发一次MajorGC没什么意义，因为重新标记会干了这个事情。 



如果minorGC后，新创建的对象仍然放不进内存，需要等待MajorGC结束，如果MajorGC结束后仍然放不进去，就会OOM了



答：总结的很好





问题

老师 有点没明白1 eden + 2 survivor的设计 为了优化空间利用 一定得是三块吗？为什么不能是两块？9:1不是也行吗



答：你看，如果一个eden一个survivor，那么回收的时候把两块区域的存活对象标记出来，放哪儿去？必须有另外一个survivor来存放，然后一次性回收之前的那个eden和survivor



问题

问一哈，之前课程新生代复制算法，老年代采用标记整理算法，为何CMS作为老年代垃圾回收，是采用标记清除算法呀



答：仔细看看今天的文章就明白了，CMS其实在标记-清理之后，会加入一个整理的过程，他是两个算法都用了



问题

新生代只需要一次"stop the world"的时间，在此期间完成标记清除并把存活对象转到survivor或老年代吗？



答：没错



问题

老师，有个问题要问您，因为CMS在“初始标记阶段”只标记直接引用。那么在“并发标记阶段”是不是是在初始标记阶段的基础上进行的



比如初始标记 标记了一个直接引用为A类，那么在并发标记阶段就不用再从A类的GC Roots开始了，直接从A类继续往下找就可以了。然后没有被遍历过的GC Roots接着被遍历就好了。



还有就是老师 CMS是标记-清除算法的话，那要是有个大对象进入到老年代没因为内存碎片问题放不下，那还得进行一次Full GC，如果GC后还是放不下，是不是就OOM了？



答：对的，可以节约时间。



明天的文章会讲解这个情况，这种对象是浮动垃圾，如果在cms gc期间进入老年代发现没有内存了，会引发concurrent mode failure问题，然后直接用serial old垃圾回收器进行回收，如果回收过后还会没地方放，那么才会oom





老年代的垃圾回收之所以比新生代慢很多，我觉得有以下几个原因： 



1. ygc的把存活的对象直接复制到s区，而e区直接清空，不存在内存碎片化问题。



2. 从老年代的CMS而言，虽然它做到了尽可能的优化，但是其存在繁复的4步才能实现清理。



3. 本文介绍了老年代的垃圾回收机制，但是通过前面的文章我们知道，做了清理之后，是存在碎片化的问题，故而还需要搬运工把这些七零八落的存活对象重新排列，紧密的靠在一起，而老年代中存活的对象可能还是比较大的，那么就需要更多的搬运时间，这个过程也是比较耗时的。 



另外还想请教老师一个问题：当解决碎片化问题后，那么这些对象的引用地址都会发生变化，那么该引用该对象的变量是如何修订引用地址的呢？



答：这个修改引用地址是全透明的，其实内存地址变了，引用的地址也修改就可以了



学员总结

判断对象是否存活通过遍历GC Roots，遍历过程中可能会发现，能被GC Roots 关联到的对象中，新生代可能占到了1% ，老年代占到了99%，然后从被关联到的对象出发追踪存活对象。



所以1%对象的追踪时间和99%的对象追踪时间是不一样的，也就是说老年代追踪时间大概是新生代的99倍。再加上老年代需要碎片整理。所以老年代垃圾回收时间比新生代长的多





问题

老师，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况？



若有，jvm是怎么处理的，若没有，jvm是如何保证的呢？



答：新生代垃圾回收会直接Stop the World，系统不能运行了，所以必须等垃圾回收完了，才能再次gc；



老年代垃圾回收是有可能的，因为采用了并发收集的机制，一边回收，系统一边运行，也许没回收完就再次触发full gc，此时会进入stop the world，用serial old来回收



问题

看了昨天的评论，老师说了MinorGC其实也会Stop the World。我理解应该就是在跟踪复制阶段是不是？



如果真要用Stop，那么用时间来计算，是不是可以忽略不计，一般情况下。比如10ms，或者5ms就能完成这个步骤？烦请老师解惑下。



答：对的，新生代要stop the world，但是他速度很快，就是从gc roots出发标记出来少量存活对象，转移到空的survivor里，然后直接清空所有垃圾对象



问题

老师，我有个疑问，新生代我估算出来后，老年代该怎么设置。如果老年代过小了，也会有问题的吧。老年代和新生代有没有比较合适的分配比例。



答：没有通用比例，其实一切说通用的jvm优化参数，全都是瞎说的



因为通过目前20多篇文章的学习，大家就应该知道了，jvm参数优化，全部得基于每个不同系统的运行模型来分析，每个系统的jvm参数都应该是不同的，从看问题的本质，而不是找一个什么通用的比例



问题

请问在初始标记的时候是从GC Root出发找对象还是从老年代的每个对象开始看有没有被GC Root引用, 在并发标记的时候是从GC Root 出发还是第一次被标记过的对象开始, 在标记的过程中采用的是深度优先算法还是广度优先算法?



答：初始标记从GC Roots出发，仅仅标记直接引用的对象，但是并发标记也是从GC Roots追踪，只不过要一直顺着引用链条追踪看哪些对象是存活的



问题

我想请问一个问题就是通过什么方式可以得知系统进行了MinirGC或者FullGC？



答：有gc日志，还有很多的工具可以干这些事儿，后续我们会介绍的





学员评论

打卡，昨天又漏打卡了。跟着老师走，讲的言简意赅，比看深入理解虚拟机容易懂，配图好理解。看后自己绘图加深理解，基本JVM就容易回答面试题了。



结合实际项目考虑这些因素进去，事倍功半。老师辛苦了。



答：是的，接下来有两个案例解析，全程通过案例分析，教你们新生代和老年代的gc相关jvm参数如何根据系统去优化设置



问题

老师好，如果在垃圾回收时程序停止运行，那垃圾回收器用多线程回收还有什么意义呢，一样还是出现卡顿的现象



答：垃圾回收用多线程可以加快垃圾回收的速度啊，进而减少Stop the World的时间



问题

请问一下在Eden和Survivor区GC时也是从GC Root开始标记和跟踪对象, 在新生代的对象数量更多为什么在新生代就不耗时而在老年代GC的时候第二步并发清理的GC Root跟踪就很耗时?





答对的，GC Roots开始追踪，但是新生代存活对象极少，很快就追踪完毕了 ，老年代存活对象太多，追踪很耗时



学员评价

看过《深入JVM》一书和一些面试资料，再看本系列，还是有很大收获。 



主要是老师讲的很有思路条理，能让读的人深入理解。 



例如三区的分区思想，为啥分区，分区比例。 然后复制算法在三区里面怎么用的等等。 不止是理解这个技术点，还领会到了思路。



答多谢支持，继续加油学习



问题

标记清理后进行整理，不就是标记整理算法吗？为什么说两个算法都使用了呢？ 难道是我理解错了标记整理算法？标记整理算法不会有清理的过程？



答标记清理是先标记再清理，cms是这种算法，然后事后再整理；标记整理是先标记然后整理，最后才清理



问题

新创建的对象，到底是往Eden区放，还是Suivivor区域放？ 



我的理解是新的对象只会放入Eden中，而Survivor区只是用于存放每次Minor GC后的对象而已，新创建的对象是不会往Suivivor存放的



答没错，只放eden，survivor只放存活对象



问题

老师刚才的讲解解答了困扰我很久的疑惑，谢谢老师，那就是说，如果我需要控制对象不进入到老年代，那就必须保证s区存活对象不能超过50%，不然根据累加来看，年龄>（占比50%中的最大年龄）的对象就会进入到老年代。



答对的，所以要尽可能让每次gc后存活对象在survivor区的50%以内



问题

年轻代标记存活对象，那老年代的CMS回收器标记存活对象还是标记垃圾对象，如果只标记存活对象 ，那并发清理阶段，会有新的对象晋升到老年代，这些对象CMS可是没有做标记存活的，那清理的时候不就把这些对象也一起清理了吗？



答对的，所以文章里也说了，清理的时候仅仅清理标记的垃圾对象，然后并发清理的时候，新进入老年代的对象就是浮动垃圾，不会清理，所以可能会触发concurrent mode failure



问题

CMS设置的的空间占比1.6是92%，这之后就一直没有变化吗 

发生ConcurrentModeFailure，启用 SerialOld 后，是只有SerialOld在工作，还是SerialOld和CMS一起工作

只有“老年代可用空间大于历次新生代GC进入老年代的对象平均大小”这种情况会考虑老年代-XX:CMSInitiatingOccupancyFaction设置的占比吗，其他两种FullGC情况不需要考虑吗，还是说所有的FullGC都会考虑这个占比



答

后面通过工具会让大家看到这些参数的值 

那肯定只有Serial Old了，因为并发回收，人家一直创建对象，搞的老年代都不下了，赶紧要stop the world，让系统程序别运行了，然后Serial Old单线程直接回收，完事儿了，空出来了空间再让系统继续运行 

条件独立，触发任何一个都会有Full GC



问题

老师，如果是通过动态年龄进入到老年代的对象，这一批对象的年龄最多也就是1吧，不可能熬了几轮才根据动态年龄进入到老年代（这一批对象第一次进入到s区时是1，第二次minorgc发现对象占用内存超过S区一半，直接进入老年代），麻烦老师对这个详细解惑下。



答对的，其实是这个年龄以及低于这个年龄的对象占据超过Survivor 50%，比如1岁，2岁，3岁的对象加起来占据了50%了，此时超过3岁的就会直接进老年代



问题

Handlerpromotionfailure参数是jdk8默认开启的吗。看完文章，我忍不住想调优一下了



答对的，默认开启的，可以的，就是要鼓励你们按照文章思路去分析自己的系统运行的内存使用模型，然后去尝试合理分配内存大小



前期要学会的优化就是一定要减少对象进入老年代，避免进行Full GC，尽量保证就是Minor GC，做到这一点，基本JVM就没什么大问题





问题

总结一下自己看完的感悟，目前看到老师案例的调优思路主要是两点。



第一，让常驻对象尽快进入老年代，以免留在新生代占用空间。



第二，避免让使用一次或者两次的对象(比如订单对象)进入老年代，从而可以避免漫长的full gc。



答是的，其实核心的JVM优化就是这个思路，前期把原理都学通了，悟透了，后续的案例会动手实操，结合更多案例来体验不同的场景优化





学员总结

感觉CMS就像一个手脚勤快的小伙子，在合适的时机进行并行工作，提高效率，但总有漏网之鱼（浮游垃圾）。



在小伙子顶不住的时候（没足够空间了，Concurrent Mode Failure），在背后注视着一切的老者（Serial Old）走了出来，大喊一声：Stop the world！有条不紊的把所有垃圾都清理掉，深藏功与名。



但是，但老者也顶不住的时候，就会发生灾难性的OOM。但据说，学了这门课的同学，都不曾见过这样的灾难。（如有不当之处，请老师指正）





答这个文采写的相当好，描述的很准确



学员总结

老师，我的一些总结和问题，请大家指正，谢谢！



对象进入触发 -->哪些情况下有对象进入老年代？



我知道的在下面 



大对象直接分配到老年代 ---> 直接分配那如果一旦大于老年代可用也要触发fgc吧？ 

minorgc的年龄到了15（有参数设置） 

存活对象大于s区 --->这个存活对象包括年龄到了的对象吗？ 

动态年龄挤出对象 规则触发 

Minor Gc前没有配置空间担保参数 

Minor Gc前有配置空间担保参数，但老年代可用内存小于历次平均分配内存 

minor Gc回收后的存活对象大于S区，大于老年代可用内存 

老年代已用空间达到CMSInitiatingOccupancyFaction 设置比例自动触发。



答：总结的非常好





学员总结

首先，计算系统高峰的qps，每秒内存开销=qps*单个对象大小*扩大20倍*其他操作10倍。 根据系统可用内存分配堆大小。分配年轻代大小根据每秒产生的内存开销来计算。 

比如每秒60mb,2g给年轻代,默认eden:s1:s2为8:1:1,eden区有1.6g空间,26s左右会被占满，会进行minor gc。 

此时存活的对象大概会有百分之10,160mb，这些存活的对象进入s1。有可能新生代回收的对象存活的可能在200mb以上， 那这样就会造成这些对象会直接进入老年代。这样就可以继续往上调新生代空间的大小,也可以调节eden区和s1 s2的比例。 

空间担保参数也要打开，避免判断小于直接fullgc。系统中可能会有在内存中缓存大的对象,大的集合,这种对象一般都是要频繁使用或者要一直缓存的 ，这时候要设置直接晋升到老年代对象的大小。

还有在s1s2区设置晋升老年代年龄的设置，这个一般默认的我觉得目前就够用，要根据实际项目来设置. 垃圾回收器设置为parnew 还有cms。充分发挥多核处理器的优势。 

整体来说，我觉得就是优化尽量避免频繁fullgc，降低系统STW的次数还有时间。



答非常好



问题

老师，有几个问题请教一下： 

1、Minor GC前，年轻代中对象的总大小与老年代中可用内存比较，其中，可用内存是指剩余内存空间还是连续可用内存空间 



2、文章中说，老年代会默认预留8%的空间给并发回收期间，进入老年代的对象使用，若进入老年代的对象大于8%的空间，是否会触发Full GC 



3、若CMS在并发标记和并发回收时，进入老年代的对象又触发了Full GC，后一次的Full GC会立即执行还是等待前一次Full GC执行完毕



答

1、连续可用空间 

2、其实之前说过，这种情况会触发concurrent mode failure，用serial old进行垃圾回收，直接stop the world 

3、同上





问题

目前系统16G内存，jvm6G的内存，新生代5.5G，永久代设置128我M，老年代就是512减去128 等于384 M 



minor gc大概450秒运行一次也就是8分钟 每次在eden区12M左右的对象 一个supervisor区 560M内存 每次回收之后大概占比空间的 百分之40到百分之60之间，supervisor空间是够的 第二占比 在百分之60一下 同年对象占比超过50的概率很低 



之前晋升次数为31我 改成4了 一次minor gc8分钟，4次半小时，肯定需要进入老年代了 



目前系统运行离更新 半个月 full gc 3次，所以我觉得堆内存就是合理优化minor gc 让对象不会那么快进入老年代 做出合理的预估 其实也不是堆越大越好 是需要根据系统整体运行情况预估 如果预估不准确 就用工具检测 然后合理优化



答：这个作业分析是我目前见过最好的一个，分析的非常好，看来你是彻底吃透我们目前讲解的内容了



问题

堆内存的调整 我觉得应该是观察 supervisor区 是不是 minor gc后占比过多 超过百分之70 可能就需要加大堆内存 或者说 业务高峰期 非常快就占满eden区 也需要加大堆内存 具体还有什么情况 请老师指正！



答

你理解没错，其实jvm优化的第一步，就是分析系统运行的内存使用模型，然后合理预估，合理分配内存，保证对象都在新生代里，进入老年代的速度要很慢很慢，做到这一点，jvm就是很完美的一个状态



问题

最后那个设置多少次FullGC之后进行碎片整理，我是否可以这样理解：



如果Full GC相对频繁一些，那就设置多次FullGC再碎片整理。



如果Full GC不是很频繁，可以设置每次FullGC都碎片整理，反正也占用不了多少时间。



这里先不考虑Full GC频繁是否调优，只是单纯以碎片整理这个参数怎么设置来考虑



答：是的，你说的很对，其实我觉得你基本都理解了



# 029、大厂面试题：最新的G1垃圾回收器的工作原理，你能聊聊吗？

目录：


1、ParNew + CMS的组合让我们有哪些痛点？

2、G1垃圾回收器

3、G1是如何做到对垃圾回收导致的系统停顿可控的？

4、Region可能属于新生代也可能属于老年代

5、本文总结

6、今日思考题






1、ParNew + CMS的组合让我们有哪些痛点？

上周我们已经彻底把垃圾回收机制给讲清楚了，包括ParNew和CMS两个垃圾回收器对新生代和老年代进行垃圾回收的运行原理，大家都了解的很清楚了。



那么我们先来分析一下目前ParNew + CMS带给我们的痛点是什么？



Stop the World，这个是大家最痛的一个点！



无论是新生代垃圾回收，还是老年代垃圾回收，都会或多或少产生“Stop the World”现象，对系统的运行是有一定影响的。



所以其实之后对垃圾回收器的优化，都是朝着减少“Stop the World”的目标去做的。



在这个基础之上，G1垃圾回收器就应运而生了，他可以提供比“ParNew + CMS”组合更好的垃圾回收的性能。



2、G1垃圾回收器

G1垃圾回收器是可以同时回收新生代和老年代的对象的，不需要两个垃圾回收器配合起来运作，他一个人就可以搞定所有的垃圾回收。



他最大的一个特点，就是把Java堆内存拆分为多个大小相等的Region，如下图。







然后G1也会有新生代和老年代的概念，但是只不过是逻辑上的概念



也就是说，新生代可能包含了某些Region，老年代可能包含了某些Reigon，如下图。







而且G1最大的一个特点，就是可以让我们设置一个垃圾回收的预期停顿时间



也就是说比如我们可以指定：希望G1同志在垃圾回收的时候，可以保证，在1小时内由G1垃圾回收导致的“Stop the World”时间，也就是系统停顿的时间，不能超过1分钟。



这个就很厉害了，大家如果看明白了之前我们的很多JVM优化的思路，都明白一点，其实我们对内存合理分配，优化一些参数，就是为了尽可能减少Minor GC和Full GC，尽量减少GC带来的系统停顿，避免影响系统处理请求。



但是现在我们直接可以给G1指定，在一个时间内，垃圾回收导致的系统停顿时间不能超过多久，G1全权给你负责，保证达到这个目标。



这样相当于我们就可以直接控制垃圾回收对系统性能的影响了。



3、G1是如何做到对垃圾回收导致的系统停顿可控的？

其实G1如果要做到这一点，他就必须要追踪每个Region里的回收价值，啥叫做回收价值呢？



他必须搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收掉多少垃圾？



大家看下图，G1通过追踪发现，1个Region中的垃圾对象有10MB，回收他们需要耗费1秒钟，另外一个Region中的垃圾对象有20MB，回收他们需要耗费200毫秒。

03_Region追踪 改.jpg

然后在垃圾回收的时候，G1会发现在最近一个时间段内，比如1小时内，垃圾回收已经导致了几百毫秒的系统停顿了，现在又要执行一次垃圾回收，那么必须是回收上图中那个只需要200ms就能回收掉20MB垃圾的Region啊！



于是G1触发一次垃圾回收，虽然可能导致系统停顿了200ms，但是一下子回收了更多的垃圾，就是20MB的垃圾，如下图。

04_回收Region.jpg

所以简单来说，G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。



这就是G1的核心设计思路。



4、Region可能属于新生代也可能属于老年代

另外在G1中，每一个Region时可能属于新生代，但是也可能属于老年代的



刚开始Region可能谁都不属于，然后接着就分配给了新生代，然后放了很多属于新生代的对象，接着就触发了垃圾回收这个Region，如下图。

05_回收新生代region改.jpg



然后下一次同一个Region可能又被分配了老年代了，用来放老年代的长生存周期的对象，如下图所示。





所以其实在G1对应的内存模型中，Region随时会属于新生代也会属于老年代，所以没有所谓新生代给多少内存，老年代给多少内存这 一说了



实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。



5、本文总结

本文先初步的介绍一下G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配



然后触发垃圾回收的时候，可以根据设定的预期系统停顿时间，来选择最少回收时间和最多回收对象的Region进行垃圾回收，保证GC对系统停顿的影响在可控范围内，同时还能尽可能回收最多的对象。



大家把本文思路串起来看看，首先高屋建瓴的对G1垃圾回收器的整体设计思想有了一定的理解。



在接下来的文章中，我们会逐步深入去看更多技术细节，比如：

G1是如何工作的？

对象什么时候进入新生代的Region？

什么时候触发Region GC？

什么时候对象进入老年代的Region？

什么时候触发老年代的Region GC？



6、今日思考题

大家看看自己负责的系统，有没有谁是已经在生产用了G1垃圾回收器的？



如果没有的话，可以想想为什么自己还没用G1？如果用了的话，可以看看G1的效果如何？



End


# 030、G1分代回收原理深度图解：为什么回收性能比传统GC更好？

1、前文回顾



上篇文章我们给大家分析了一下G1垃圾回收器设计的思想，主要是把内存拆分为很多个小的Region，然后新生代和老年代各自对应一些Region，回收的时候尽可能挑选停顿时间最短以及回收对象最多的Region，尽量保证达到我们指定的垃圾回收系统停顿时间。



这篇文章我们继续一步一图，把G1垃圾回收器工作的时候，从对象在内存中的分配到垃圾回收的触发，给大家来分析一下。



2、如何设定G1对应的内存大小



大家看如下的图，我们都知道G1对应的是一大堆的Region内存区域，每个Region的大小是一致的。







那么首先思考两个问题：到底有多少个Region呢？每个Region的大小是多大呢？



其实这个默认情况下自动计算和设置的，我们可以给整个堆内存设置一个大小，比如说用“-Xms”和“-Xmx”来设置堆内存的大小。



然后JVM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048



因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。



比如说堆大小是4G，那么就是4096MB，此时除以2048个Region，每个Region的大小就是2MB。大概就是这样子来决定Region的数量和大小的，大家一般保持默认的计算方式就可以



如果通过手动方式来指定，则是“-XX:G1HeapRegionSize”，如下图。





刚开始的时候，默认新生代对堆内存的占比是5%，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。



因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”。



而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少，这些其实都是动态的。



大家看下图，刚开始就是一部分的Region是属于新生代的。







3、新生代还有Eden和Survivor的概念吗？



没错，其实在G1中虽然把内存划分为了很多的 Region，但是其实还是有新生代、老年代的区分



而且新生代里还是有Eden和Survivor的划分的，所以大家会发现之前学习的很多技术原理在G1时期都是有用的。



大家应该还记得之前说过的一个新生代的参数，“-XX:SurvivorRatio=8”，所以这里还是可以区分出来属于新生代的Region里哪些属于Eden，哪些属于Survivor。



比如新生代之前说刚开始初始的时候，有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region，如下图。







所以大家要明白在这里其实还是有Eden和Survivor的概念的，他们会各自占据不同的Region。



只不过随着对象不停的在新生代里分配，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。



4、G1的新生代垃圾回收



既然G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的



随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例60%。



一旦新生代达到了设定的占据堆内存的最大大小60%，比如都有1200个Region了，里面的Eden可能占据了1000个Region，每个Survivor是100个Region，而且Eden区还占满了对象，此时如下图所示。





这个时候还是会触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态



然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象，如下图。







但是这个过程跟之前是有区别的，因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。



那么G1就会通过之前说的，对每个Region追踪回收他需要多少时间，可以回收多少对象来选择回收一部分的Region，保证GC停顿时间控制在指定范围内，尽可能多的回收掉一些对象。



5、对象什么时候进入老年代？



大家都知道，在G1的内存模型下，新生代和老年代各自都会占据一定的Region，老年代也会有自己的Region



按照默认新生代最多只能占据堆内存60%的Region来推算，老年代最多可以占据40%的Region，大概就是800个左右的Region。



那么对象什么时候从新生代进入老年代呢？



可以说跟之前几乎是一样的，还是这么几个条件：



（1）对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代



（2）动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%



此时就会判断一下，比如年龄为1岁，2岁，3岁，4岁的对象的大小总和超过了Survivor的50%，此时4岁以上的对象全部会进入老年代，这就是动态年龄判定规则



大家看下图，所以经过一段时间的新生代使用和垃圾回收之后，总有一些对象会进入老年代中。







6、大对象Region



大家此时可能会疑惑了，唉？以前说是那种大对象也是可以直接进入老年代的，那么现在在G1的这套内存模型下呢？



实际上这里会有所改变，G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。



在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中



而且一个大对象如果太大，可能会横跨多个Region来存放。如下图。





肯定还有人会问，那堆内存里哪些Region用来存放大对象啊？



不是说60%的给新生代，40%的给老年代吗，那还有哪些Region给大对象？



很简单，之前说过了，在G1里，新生代和老年代的Region是不停的变化的



比如新生代现在占据了1200个Region，但是一次垃圾回收之后，就让里面1000个Region都空了，此时那1000个Region就可以不属于新生代了，里面很多Region可以用来存放大对象。



那么还有人会问了，大对象既然不属于新生代和老年代，那么什么时候会触发垃圾回收呢？



也很简单，其实新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回收的策略。



7、本文总结



本文就初步介绍了G1的内存模型和分配规则，包括了下面的一些知识：

每个Region多大

新生代包含多少Region，

新生代如何动态增加Region

Eden和Survivor两个区域仍然还是存在

什么时候触发新生代的垃圾回收

垃圾回收的复制算法

还有G1特有的预设GC停顿时间的作用

什么时候对象进入老年代

大对象的独立Region存放和回收



大家基本就搞清楚了新生代的内存分配、对象分配和垃圾回收的策略，还有对象进入老年代的时机



下一篇文章，我们就会分析G1的老年代的垃圾回收机制，相对来说会更为复杂。



8、今日思考题



看完了今天的文章之后，大家可以思考一下：



从新生代的垃圾回收来看，大家觉得G1垃圾回收器在新生代垃圾回收过程中，相比之前的ParNew而言，最大的进步在哪里？

End

# 031、动手实验：线上系统部署如果采用G1垃圾回收器，应该如何设置参数？

1、前文回顾



上篇文章大家已经搞清楚了G1的动态内存管理策略，他会根据情况动态的把Region分配给新生代、Eden、Survivor、老年代和大对象，但是新生代和老年代有一个各自的最大占比，然后在新生代的Eden满的时候，触发新生代垃圾回收。



新生代的垃圾回收还是采用了复制算法，只不过会考虑预设GC停顿时间，保证垃圾回收的停顿时间不能超过预设时间，因此会挑选一些Region来进行垃圾回收。



然后跟之前说的一样，如果一些对象在新生代熬过了一定次数的GC，或者是触发了动态年龄判定规则，或者是存活对象在Survivor放不下了，都会让对象进入老年代中。



而大对象则是进入单独的大对象Region，不再进入老年代。



所以实际上在G1中，还是会存在新生代的对象慢慢会因为各种情况进入老年代的。



2、什么时候触发新生代+老年代的混合垃圾回收？



G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%



意思就是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。



比如按照我们之前说的，堆内存有2048个Region，如果老年代占据了其中45%的Region，也就是接近1000个Region的时候，就会开始触发一个混合回收，如下图所示。





3、G1垃圾回收的过程



首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC  Roots直接能引用的对象，这个过程速度是很快的。



如下图，先停止系统程序的运行，然后对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描，标记出来他们直接引用的那些对象。







接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，如下图所示。







这里对GC Roots追踪做更加详细的说明，比如下面的代码



大家可以看到，Kafka这个类有一个静态变量是“replicaManager”，他就是一个GC Root对象，初始标记阶段，仅仅就是标记这个“replicaManager”作为GC Roots直接关联的对象，就是“ReplicaManager”对象，他肯定是要存活的。



然后在并发标记阶段，就会进行GC Roots追踪，会从“replicaManager”这个GC Root对象直接关联的“ReplicaManager”对象开始往下追踪



可以看到“ReplicasManager”对象里有一个实例变量“replicaFetcher”，此时追踪这个“replicaFetcher”变量可以看到他引用了“ReplicaFetcher”对象，那么此时这个“ReplicaFetcher”对象也要被标记为存活对象。



blob.png



这个并发标记阶段还是很耗时的，因为要追踪全部的存活对象。



但是这个阶段是可以跟系统程序并发运行的，所以对系统程序的影响不太大。



而且JVM会对并发标记阶段对对象做出的一些修改记录起来，比如说哪个对象被新建了，哪个对象失去了引用。



接着是下一个阶段，最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象，如下图所示。







最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。



接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的范围内。



比如说老年代此时有1000个Region都满了，但是因为根据预定目标，本次垃圾回收可能只能停顿200毫秒，那么通过之前的计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region，把GC导致的停顿时间控制在我们指定的范围内，如下图。







而且大家需要在这里有一点认识，其实老年代对堆内存占比达到45%的时候，触发的是“混合回收”



也就是说，此时垃圾回收不仅仅是回收老年代，还会回收新生代，还会回收大对象。



那么，到底是回收这些区域的哪些Region呢？



那就要看情况了，因为我们设定了对GC停顿时间的目标，所以说他会从新生代、老年代、大对象里各自挑选一些Region，保证用指定的时间（比如200ms）回收尽可能多的垃圾，这就是所谓的混合回收，如下图。







4、G1垃圾回收器的一些参数



大家在上面都看到了，一般在老年代的Region占据了堆内存的Region的45%之后，会触发一个混合回收的过程，也就是Mixed GC，分为了好几个阶段。



在这里最后一个环节，其实就是执行混合回收，从新生代和老年代里都回收一些Region。



但是最后一个阶段混合回收的时候，其实会停止所有程序运行，所以说G1是允许执行多次混合回收。



比如先停止工作，执行一次混合回收回收掉 一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。



有一些参数可以控制这个，比如“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次



意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。



如下图，假设一次混合回收预期要回收掉一共有160个Region，那么此时第一次混合回收，会回收掉一些Region，比如就是 20个Region。







接着恢复系统运行一会儿，然后再执行一次“混合回收”，如下图，再次回收掉20个Region。





如此反复执行8次混合回收阶段之后 ，不就把预订的160个Region都回收掉了？而且还把系统停顿时间控制在指定范围内。



那么为什么要反复回收多次呢？



因为你停止系统一会儿，回收掉一些Region，再让系统运行一会儿，然后再次停止系统一会儿，再次回收掉一些Region，这样可以尽可能让系统不要停顿时间过长，可以在多次回收的间隙，也运行一下。



还有一个参数，就是“-XX:G1HeapWastePercent”，默认值是5%



他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉



如下图。







这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意味着本次混合回收就结束了。



而且从这里也能看出来G1整体是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之后，再进行内存碎片的整理。



还有一个参数，“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收



否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的。



5、回收失败时的Full GC



如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去



此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。



一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢的。



6、本文总结



本文看完，大家基本上对老年代占堆内存45%的时候触发的Mixed垃圾回收的过程就很清楚了



包括如何标记，如何进行混合回收，回收时采用的复制算法，包括一些对应的参数的含义。



7、今日思考题



大家结合我们之前针对ParNew+CMS的组合分析过的JVM GC优化思路，可以考虑一下：



如果使用G1垃圾回收的时候，应该值得优化的是什么地方？

什么时候可能会导致G1频繁的触发Mixed混合垃圾回收？

如何尽量减少Mixed GC的频率？



End

# 032、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（上）？

目录：

1、案例背景引入

2、系统核心业务流程分析

3、系统的运行压力

4、本文总结与下文预告





1、案例背景引入



咱们接下来用一个真实的案例来给大家聊聊G1垃圾回收器的一些性能优化的手段和背后的原理



其实核心思想跟之前我们讲过的“ParNew+CMS”的垃圾回收器组合的优化思想是类似的，但是因为G1的运行原理有一些不一样的地方，所以说在优化上会略有不同。



首先我们来说说案例的背景，这是一个百万级注册用户的在线教育平台，主要目标用户群体是几岁到十几岁的孩子，注册用户大概是几百万的规模，日活用户规模大概在几十万。



系统的业务流程其实也不复杂，而且我们可以排除掉一些选课、排课、浏览课程详情以及付费购买之类的低频的行为。



为什么这么说呢？大家可以想一下，一个在线教育平台，本来用户也不是特别多，他不是一个电商平台，不会说每天每个人都会进来浏览幼儿课程详情。



所以一般业务流程就是，有人进来浏览一下 ，考虑一段时间，然后下定决心了给自己孩子报名一个在线的英语课程，或者数学课程之类的。



所以其实他的普通用户浏览课程详情、下单付费、选课排课，这些都是绝对的低频行为，我们几乎不用考虑到系统的运行中去，可以暂时忽略掉。



那么对于这样的一个系统，他最关键的高频行为是什么呢？



上课！



也就是说，大家从这个系统的本质来思考一下，这样的一个平台，他的使用人群是幼儿园的孩子到中小学的孩子



他们平时白天都要上学，一般也就是晚上放学之后到八九点钟的样子，是最活跃使用这个平台的时候，还有就是周末也是最活跃使用这个平台的时候。



这里尤为关键的需要注意的，就是每天晚上那两三小时的高峰时期，几乎你可以认为每天几十万日活用户（那些小孩儿）都会集中在这个时间段来平台上上在线课程，比如青少年英语课，或者数学课之类的。



所以这个晚上两三小时的时间段里，将会是平台每天绝对的高峰期，而且白天几乎没什么流量，可能99%的流量都集中在晚上，如下图所示。







2、系统核心业务流程分析



接着我们来明确一下，这样的一个系统，孩子们在上课的时候主要高频使用的是哪些功能呢？



其实非常的简单，现在如果大家家里有孩子，平时对一些在线教育APP有一定了解的话，应该知道现在在线教育APP都会尤为主打的是互动环节。



给大家举个例子，比如说给五六岁的孩子上的幼儿英语课，大家觉得，还会跟20年前一样，给他们放非常枯燥的“李雷和韩梅梅”的情节么？然后机械式的去跟读？



那肯定不是了！现在尤为强调的是在欢快的娱乐游戏中进行教学，让孩子们快乐的学习英语、数学之类学科的知识。



所以说，在那几十万用户晚上高峰时间段使用系统上课的时候，尤为核心的业务流程，就是大量的游戏互动环节



通过游戏互动让孩子们感兴趣，愿意学，而且通过游戏强互动让他们保持注意力，促使他们对学习到的东西进行输出，提升学习的效果，大家看下图。







也就是说，这个游戏互动功能，一定会承载用户高频率、大量的互动点击



比如在完成什么任务的时候必须要点击很多的按钮，频繁的进行互动，然后系统后台需要接收大量的互动请求，并且记录下来用户的互动过程和互动结果。



系统得记录下来用户完成了多少个任务，做对了几个，做错了几个，诸如此类的。



3、系统的运行压力



现在我们开始来分析一下这个系统运行时候对内存使用产生的一个压力



其实核心点就是搞明白在晚上两三小时高峰期内，每秒钟会有多少请求，每个请求会连带产生多少对象，占用多少内存，每个请求要处理多长时间。



首先我们来分析一下晚上高峰期内几十万用户同时在线使用平台，每秒钟会产生多少请求？



我们可以大致来估算一下，比如说晚上3小时高峰期内有总共60万活跃用户，平均每个用户大概会使用1小时左右来上课，那么每小时大概会有20万活跃用户同时在线学习。



这20万活跃用户因为需要进行大量的互动操作，所以大致可以认为是每分钟进行1次互动操作，一小时内会进行60次互动操作



那么20万用户在1小时内会进行1200万次互动操作，平均到每秒钟大概是3000次左右的互动操作，这是一个很合理的数字。



那么每秒钟要承载3000并发请求，根据经验来看，一般系统的核心服务需要部署5台4核8G的机器来抗住是差不多的，每台机器每秒钟抗个600请求，这个压力可以接受，一般不会导致宕机的问题。



那么每个请求会产生多少个对象呢？



一次互动请求不会有太复杂的对象，他主要是记录一些用户互动过程的，可能会跟一些积分之类的东西有关联



大家如果玩儿过在线教育APP都知道，每次你完成一个活动，一般会给你累加一些对应的“XX币“，“XX宝石”之类的东西。



所有大致估算一下，一次互动请求大致会连带创建几个对象，占据几KB的内存，比如我们就认为是5KB吧那么一秒600请求会占用3MB左右的内存。



4、本文总结与下文预告



基于百万用户在线教育平台的G1垃圾回收优化案例，分为上下两文



本文先按照惯例，把整个系统的背景、核心业务流程、高峰运行压力、机器部署、每秒请求压力、每秒内存使用压力，都给分析了出来。



接着下文就会基于这个每秒内存使用压力，结合G1垃圾回收器的运行原理，来给大家分析在这个压力之下，G1垃圾回收机制会如何来运行，这个过程中可能会产生哪些问题，如何对G1的一些参数进行基本的优化来调整垃圾回收的性能。



但是G1本身运行机制极为复杂，所以真的要搞懂他很多优化的细节，必须结合后面几十个不同的案例，不同的场景来说明，一个案例也仅仅能把部分优化方式给说清楚而已。





End

# 033、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（下）？

1、前文回顾



上篇文章我们针对一个案例背景进行了系统的分析，其实这套系统分析方法论大家如果一路跟着学习到如今，都已经非常的熟练了，可以说这是一个优秀工程师必须具备的JVM压力分析的能力。



作为开发业务系统的工程师，不一定说要深入理解JVM的各种底层原理和源码，因为也没那么多精力去研究那些



但是务必要能够合理的分析自己系统的内存压力，然后合理的优化JVM的参数，尽可能降低JVM GC的频率，同时降低JVM GC导致的系统停顿的时间。



本文我们接着上文的案例继续来分析，在这个案例背景之下来看看，G1垃圾回收器在使用的时候有哪些地方是值得优化的。



2、G1垃圾回收器的默认内存布局



接着我们来看看G1垃圾回收器的默认内存布局，之前说过我们采用的是4核8G的机器来部署系统，然后每台机器每秒会有600个请求会占用3MB左右的内存空间。



那么假设我们对机器上的JVM，分配4G给堆内存，其中新生代默认初始占比为5%，最大占比为60%，每个Java线程的栈内存为1MB，元数据区域（永久代）的内存为256M，此时JVM参数如下：



“-Xms4096M -Xmx4096M  -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC“



“-XX:G1NewSizePercent”参数是用来设置新生代初始占比的，不用设置，维持默认值为5%即可。



“-XX:G1MaxNewSizePercent”参数是用来设置新生代最大占比的，也不用设置，维持默认值为60%即可。



此时堆内存共4G，那么此时会除以2048，计算出每个Region的大小，此时每个Region的大小就是2MB，刚开始新生代就占5%的Region，可以认为新生代就是只有100个Region，有200MB的内存空间，如下图所示。







3、GC停顿时间如何设置？



在G1垃圾回收器中有一个至关重要的参数会影响到GC的表现，就是“-XX:MaxGCPauseMills”，他的默认值是200毫秒



也就是说咱们希望每次触发一次GC的时候导致的系统停顿时间（也就是“Stop the World”）不要超过200毫秒，避免系统因为GC长时间卡死。



这个参数我们可以先保持一个默认值，继续往下分析看看，不着急忙下结论。



4、到底多长时间会触发新生代GC？



有一个问题，就是系统运行起来之后，会不停的在新生代的Eden区域内分配对象，按照之前的推算是每秒分配3MB的对象，如下图。







那么之前是说“Eden区域的空间不够了，就触发新生代gc”，但是到底什么时候Eden区域会内存不够呢？



之前说过“-XX:G1MaxNewSizePercent”参数限定了新生代最多就是占用堆内存60%的空间



那么难道必须得随着系统运行一直给新生代分配更多的Region，直到新生代占据了60%的Region之后，无法再分配更多的Region了，再触发新生代gc？



G1肯定不是这么搞的，后续我们会通过几十个案例带着大家来实操体验各种JVM运行场景和通过工具来查看内存占用情况，GC频率和效果，但是现在我们就初步给大家说说G1的运行原理。



我们首先假设一个前提，这个纯碎就是我们人为设定的，就是假设在这个系统里，G1回收掉300个Region（600MB内存），大致需要200ms。



那么很有可能系统运行时，G1呈现出如下的运行效果。



首先，随着系统运行，每秒创建3MB的对象，大概1分钟左右就会塞满100个Region（200MB内存），如下图所示。



此时很可能G1会觉得，要是我现在就触发一次新生代gc，那么回收区区200MB只需要大概几十ms，最多就让系统停顿几十ms而已，跟我的主人设定的“-XX:MaxGCPauseMills”参数限制的200ms停顿时间相差甚远。



要是我现在就触发新生代gc，那岂不是会导致回收完过后接着1分钟再次让新生代这100个Region塞满，接着又触发新生代gc？



那这样算下来，岂不是每分钟都要执行一次新生代gc？是不是太频繁了？好像没这个必要吧！



所以还不如给新生代先增加一些Region，然后让系统继续运行着在新生代Region中分配对象好了，这样就不用过于频繁的触发新生代gc了，此时如下图。







然后系统继续运行，一直到可能300个Region都占满了，此时通过计算发现回收这300个Region大概需要200ms，那么可能这个时候就会触发一次新生代gc了。



所以大家通过这一小节的分析就明白了，其实G1里是很动态灵活的，他会根据你设定的gc停顿时间给你的新生代不停分配更多Region



然后到一定程度，感觉差不多了，就会触发新生代gc，保证新生代gc的时候导致的系统停顿时间在你预设范围内。



但是大家觉得上述的数字一定精准吗？



No！



完全只是示范一下做一个示例，其实这个G1到底会分配多少个Region给新生代，多久触发一次新生代gc，每次耗费多长时间，这些都是不确定的，必须通过一些工具去查看系统实际情况才知道，这个提前是无法预知的。



但是大家需要知道的，就是G1它本身是这样的一个运行原理，他会根据你预设的gc停顿时间，给新生代分配一些Region，然后到一定程度就触发gc，并且把gc时间控制在预设范围内，尽量避免一次性回收过多的Region导致gc停顿时间超出预期。



5、新生代gc如何优化？



此时大家就可以思考一下了，那么新生代gc如何优化？



其实，垃圾回收器是一代比一代先进，内部实现机制越来越复杂，但是对我们来说优化的时候越来越简单了。



比如对于G1而言，我们首先应该给整个JVM的堆区域足够的内存，比如我们在这里就给了JVM超过5G的内存，其中堆内存有4G的内存。



接着就应该合理设置“-XX:MaxGCPauseMills”参数



如果这个参数设置的小了，那么说明每次gc停顿时间可能特别短，此时G1一旦发现你对几十个Region占满了就立即触发新生代gc，然后gc频率特别频繁，虽然每次gc时间很短。



比如说30秒触发一次新生代gc，每次就停顿30毫秒。



如果这个参数设置大了呢？



那么可能G1会允许你不停的在新生代理分配新的对象，然后积累了很多对象了，再一次性回收几百个Region



此时可能一次GC停顿时间就会达到几百毫秒，但是GC的频率很低。比如说30分钟才触发一次新生代GC，但是每次停顿500毫秒。



所以这个参数到底如何设置，需要结合后续给大家讲解的系统压测工具、gc日志、内存分析工具结合起来进行考虑，尽量让系统的gc频率别太高，同时每次gc停顿时间也别太长，达到一个理想的合理值。



6、mixed gc如何优化？



说完了这个新生代gc之后，那接下来就是mixed gc的优化了



对于这个mixed gc的触发，大家都知道是老年代在堆内存里占比超过45%就会触发。



大家之前都很清楚了年轻代的对象进入老年代的几个条件了，要不然是新生代gc过后存活对象太多没法放入Survivor区域，要不然是对象年龄太大，要不然是动态年龄判定规则。



其中尤其关键的，就是新生代gc过后存活对象过多无法放入Survivor区域，以及动态年龄判定规则



这两个条件尤其可能让很多对象快速进入老年代，一旦老年代频繁达到占用堆内存45%的阈值，那么就会频繁触发mixed gc。



所以mixed gc本身很复杂，很多参数可以优化，但是优化mixed gc的核心不是优化他的参数，而是跟我们之前分析的思路一样，尽量避免对象过快进入老年代，尽量避免频繁触发mixed gc，就可以做到根本上优化mixed gc了。



那么G1里面跟之前的ParNew+CMS的组合是不同的，我们到底应该如何来优化参数呢？



其实核心的点，还是“-XX:MaxGCPauseMills”这个参数。



大家可以想一下，假设你“-XX:MaxGCPauseMills”参数设置的值很大，导致系统运行很久，新生代可能都占用了堆内存的60%了，此时才触发新生代gc。



那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。



或者是你新生代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。



所以这里核心还是在于调节“-XX:MaxGCPauseMills”这个参数的值，在保证他的新生代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发mixed gc。



至于到底如何优化这个参数，一切都要结合后续大量工具的讲解和实操演练了，到这里为止，至少大家对原理性的东西都很了解了。



7、今日思考题



到底为止，大家已经基本学明白了G1的运行原理以及基本的优化思路，那么我想问大家两个问题：

G1这种垃圾回收器到底在什么场景下适用呢？

有了G1以后，是不是还有一些场景采用“ParNew+CMS”垃圾回收器也可以呢？



End

# 034、第一阶段复习：当你开发完一个系统准备部署上线时，如何设置JVM参数？

第一阶段复习：

当你开发完一个系统准备部署上线时，如何设置JVM参数？

各位同学，不知不觉，我们已经完成了头5周的内容了，对JVM的核心运行原理以及JVM GC的原理都进行了分析



并且，我们还结合了多个案例，给大家讲解了如何在开发好一个系统之后，合理的预估系统压力，合理的设置JVM的各种参数，在系统压测和上线之前，也让JVM参数尽量合理一些

本周作业是阶段性复习作业，希望大家能够对这5周的内容做一个全面的梳理，自己写一些笔记，把学习到的知识体系都梳理一下，形式不限，可以画图，也可以做思维导图，总之就是希望大家用自己的方式，对目前为止学习到的内容深度思考和消化总结

学了不练，学了不复习，学了不总结，基本等于白学。希望大家记住这句话。



所以我们的专栏尤为重视每日思考题、每周作业还有阶段性的复习总结，尤其希望大家每个人都自己去做这个事儿，不要什么都希望我们整理好了发给你

记住，自己思考和总结出来的东西，跟我们总结好发给你的东西，效果是完全不同的，一定要自己去做

下周开始将要全面进入JVM实操环节，用可以运行的代码模拟出各种场景和故障，然后让大家动手体验如何分析JVM内存，如何分析GC日志，如何动手优化参数得到想要的结果，然后结合几十个案例来进行实操，让大家绝对务必要掌握在实际工作可以玩儿转JVM的优化

