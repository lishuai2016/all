[Java线程：概念与原理](http://www.cnblogs.com/riskyer/p/3263032.html)
[Java总结篇系列：Java多线程（三）](http://www.cnblogs.com/lwbqqyumidi/p/3821389.html)
[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/gf771115/article/details/51682561)
[Java总结篇系列：Java多线程（一）](http://www.cnblogs.com/lwbqqyumidi/p/3804883.html)
[JAVA多线程实现的三种方式](https://blog.csdn.net/aboy123/article/details/38307539)
[Java 多线程 并发编程](https://blog.csdn.net/escaflone/article/details/10418651)







常见线程名词解释

主线程：JVM调用程序main()所产生的线程。

当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。

后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束

前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。

线程类的一些常用方法：

　　sleep(): 强迫一个线程睡眠Ｎ毫秒。

　　isAlive(): 判断一个线程是否存活。

　　join(): 等待线程终止。

　　activeCount(): 程序中活跃的线程数。

　　enumerate(): 枚举程序中的线程。

    currentThread(): 得到当前线程。

　　isDaemon(): 一个线程是否为守护线程。

　　setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)

　　setName(): 为线程设置一个名称。

　　wait(): 强迫一个线程等待。

　　notify(): 通知一个线程继续运行。

　　setPriority(): 设置一个线程的优先级。


join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。
Thread t = new AThread(); t.start(); t.join();

为什么要用join()方法

在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。

yield():暂停当前正在执行的线程对象，并执行其他线程。

        Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。

         yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

sleep()和yield()的区别

        sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。

        sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程

       另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。


生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用...伟大啊 ! !)。


注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。


1.进程和线程的概念及线程的优点
进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。
线程可以理解成是进程中独立运行的子任务。
线程的优点是最大限度的利用CPU的空闲时间来处理其他任务，提升系统的运行效率。


2.使用多线程
实现多线程编程的方式主要有两种，一种是继承Thread类，另一种是实现Runnable接口。Thread类实现了Runnable接口。使用继承Thread类的方式，最大的局限就是不支持多继承，所以推荐使用实现Runnable接口方式。使用多线程技术，代码的运行结果与代码的执行顺序或调用顺序是无关的。
多线程并发访问一个类的某个实例的实例变量时会出现线程不安全的问题，而方法级别的变量是线程安全的。synchronized关键字可以在任意的对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。线程要想执行临界区中的代码，需要拿到对应的锁，在多线程的情况下会有多个线程同时去争一把锁，直到拿到锁为止。


3.currentThread方法
currentThread()方法可返回当前代码段正在被哪个线程调用的信息。例如，Thread.currentThread().getName()返回当前线程的线程名称。


4.isAlive方法
isAlive()方法的功能是判断当前线程是否处于活动状态。活动状态是指线程已经启动尚未终止，线程处于正在运行或准备开始运行的状态。


5.sleep方法
sleep()方法的作用是在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)，需要注意，此时并不会释放所持有的锁。


6.getId方法
getId()方法的作用是取得线程的唯一标识。


7.start方法
start()方法用于真正去启动一个线程，等待调度执行。


8.run方法
run()方法是线程被调度执行时真正执行的方法。


9.停止线程
在Java中有以下3种方法可以停止正在运行的线程：
1)使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2)使用stop方法强行终止，但是不推荐这个方法，因为这个方法可能产生不可预料的结果，而且这个方法已经被官方标记为废弃，不建议使用了。
3)使用interrupt方法中断线程，需要结合interrupted方法，通过抛异常的方式。
Thread类中提供了以下两个方法用于判断线程的状态是不是停止：
1)interrupted()测试当前线程是否已经中断，即判断当前运行interrupted()方法的线程的中断状态是否为true，interrupted()方法被调度执行后会清除掉中断状态为false。
2)isInterrupted()测试线程是否已经中断，但是不会清除掉中断状态。


10.暂停线程
暂停线程意味着线程还可以恢复。在Java的多线程中，使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。
使用这两个方法时需要注意以下两点：
1)suspend和resume使用不当，会造成公共的同步对象的独占，使其它线程无法访问公共同步对象。
2)suspend和resume也会容易出现因为线程暂停而出现的数据不同步的情况。


11.yield方法
yield方法的作用是放弃当前的CPU资源，将其让给其它任务去占用CPU执行时间，放弃的时间不确定，可能会马上再次获得CPU时间片。


12.线程的优先级
在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。在Java中，设置了1~10这10个优先级等级，默认MIN_PRIORITY=1，NORM_PRIORITY=5，MAX_PRIORITY=10。线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A线程优先级相同。优先级对于线程的运行是有随机性的。


13.守护线程
在Java中有两种线程，一种是用户线程，一种是守护线程。守护线程是一种特殊的线程，它具有陪伴的特性，当线程中不存在非守护线程了，守护线程也就自动销毁了。 
