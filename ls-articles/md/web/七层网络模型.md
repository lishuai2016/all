网络传输的数据格式（七层协议的表示层）

序列化和反序列化的组件

　　


序列化：将对象或数据结构转换成约定格式数据的过程。
反序列化：将约定格式的数据转换成对象或数据结构的过程。

  通常我们将这种“约定格式的数据”称之为序列化协议。根据协议的特点序列化协议可以细分为文本序列化协议（以下简称文本协议）和二进制序列化协议（以下简称二进制协议）。文本协议是指序列化的数据肉眼可以阅读，比如XML协议，而二进制协议序列化的数据不便于阅读，比如Java中标准的Serializable协议。序列化协议主要应用于两个方面，第一：数据网络传输；第二：数据持久化。在当今这个纷繁复杂的世界上，每一个程序、每一个系统都会有数据的持久化过程以及系统与系统之间都会有数据往来，互通有无。

通俗的来说，序列化主要用于将存储对象状转换为另一种通用格式，比如存储为二进制、xml、json等等，而反序列化通常是从这种格式转换回来的过程。

   使用序列化主要是因为跨平台和对象存储的需求，因为网络上只允许字符串或者二进制格式，而文件需要使用二进制流格式，如果想把一个内存中的对象存储下来就必须使用序列化转换为xml（字符串）、json（字符串）或二进制（流）等。

一、序列化和反序列化产生原理

互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象--这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。

- 序列化： 将数据结构或对象转换成二进制串的过程

- 反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程


所谓不同的序列化协议是在这里根据不同的协议格式来把对象转化为二进制的？？？？

假如对于文本序列化协议XML和json可以这样说，那么对于二进制的序列化协议该怎么转化的？？？？



二、序列化的作用

1 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
2 在网络上传送对象的字节序列。

　　在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

　　当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。


对于客户端和服务端的数据传输通常会有以下几点考虑：
1.网络数据大小——占用带宽，传输效率：虽然对单个用户来说，数据量传输很小，但是对于服务器端要承受众多的高并发数据传输，必须要考虑到数据占用带宽，尽量不要有冗余数据，这样才能够少占用带宽，少占用资源，少网络IO，提高传输效率；

2.网络数据安全性——敏感数据的网络安全：对于相关业务的部分数据传输都是敏感数据，所以必须考虑对部分传输数据进行加密；

3.编码复杂度——序列化和反序列化复杂度，效率，数据结构的可扩展性，可维护性：对于平台相关业务的代码实现也需要考虑到数据发送方和数据接收方数据处理的复杂度和数据结构的可扩展性，可维护性，人力成本和实施复杂度也必须考虑在内；

4.协议通用性——大众规范：数据类型必须是跨平台，数据格式是通用的，大家普遍能接受上手的；

以下我们通过几种不同类别的协议数据类型进行比较：
自定义二进制



优点：信息体积小，对应以上”1“
缺点：编码复杂度高（自己定义消息格式，自己编写序列化和反序列化方法，自己进行容错处理，可扩展性不强，比如添加个字段，就必须改两端的逻辑处理），对应以上”3“；

提供序列化和反序列化库的开源协议
比如protocol buffers， json，  Thrift
优点：是一种流行的通用数据格式，扩展相当方便，序列化和反序列化相当方便（有相应库），错误处理方便（库支持）；

文本化协议
比如xml，json
优点：序列化，反序列化容易（库支持），调试方便，可视化强
缺点：相对于二进制存储占用体积大

如果是你，你会选择哪种协议？
我会选择json，因为他是“提供序列化和反序列化库的开源协议还是文本化的协议”，原因如下：
1.自定义二进制格式进行传输的工作，整个过程在定义消息，write，read的过程过于复杂，还很容易出错，对于很多数据交互的程序，会花费大量的时间在上面；

2.自定义二进制格式不便于扩展，但json可以很好地解决这种问题；

3.虽然相比较二进制，json的占用空间稍大，但是我们可以通过网络数据压缩来解决，况且json本身也是轻量级的，传输效率也很高；

4.去看《unix编程艺术》吧，第5章--文本化，好协议产生好实践；第6章--透明性：来点儿光 会告诉你使用文本化协议的好处；





七层协议

应用层

与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。示例：TELNET，HTTP，FTP，NFS，SMTP等。

表示层

这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。

会话层

它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。

传输层

这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。

网络层

这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。

数据链路层

它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。

物理层

OSI的物理层规范是有关传输介质的特这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。


