---
title: SQL注入
categories: 
- mysql
tags:
---



# 如何理解SQL注入（攻击）？

SQL注入是一种将SQL代码添加到输入参数中，传递到服务器解析并执行的一种攻击手法。
SQL注入攻击是输入参数未经过滤，然后直接拼接到SQL语句当中解析，执行达到预想之外的一种行为，称之为SQL注入攻击。

# SQL注入是怎么产生的？
1）WEB开发人员无法保证所有的输入都已经过滤
2）攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）
3）数据库未做相应的安全配置

# 如何进行SQL注入攻击？

以php编程语言、mysql数据库为例，介绍一下SQL注入攻击的构造技巧、构造方法
## 数字注入

在浏览器地址栏输入：learn.me/sql/article.php?id=1，这是一个get型接口，发送这个请求相当于调用一个查询语句：
$sql = "SELECT * FROM article WHERE id =",$id
正常情况下，应该返回一个id=1的文章信息。那么，如果在浏览器地址栏输入：learn.me/sql/article.php?id=-1 OR 1 =1，这就是一个SQL注入攻击了，
可能会返回所有文章的相关信息。为什么会这样呢？
这是因为，id = -1永远是false，1=1永远是true，所有整个where语句永远是ture，所以where条件相当于没有加where条件，那么查询的结果相当于整张表的内容

## 字符串注入
有这样一个用户登录场景：登录界面包括用户名和密码输入框，以及提交按钮。输入用户名和密码，提交。
这是一个post请求，登录时调用接口learn.me/sql/login.html，首先连接数据库，然后后台对post请求参数中携带的用户名、密码进行参数校验，
即sql的查询过程。假设正确的用户名和密码为user和pwd123，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句：
SELECT * FROM user WHERE username = 'user' ADN password = 'pwd123'
由于用户名和密码都是字符串，SQL注入方法即把参数携带的数据变成mysql中注释的字符串。mysql中有2种注释的方法：

1）'#'：'#'后所有的字符串都会被当成注释来处理
用户名输入：user'#（单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句：
SELECT * FROM user WHERE username = 'user'#'ADN password = '111'
'#'后面都被注释掉了，相当于：
SELECT * FROM user WHERE username = 'user' 

2）'-- ' （--后面有个空格）：'-- '后面的字符串都会被当成注释来处理
用户名输入：user'-- （注意--后面有个空格，单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句：
SELECT * FROM user WHERE username = 'user'-- 'AND password = '111'
SELECT * FROM user WHERE username = 'user'-- 'AND password = '1111'
'-- '后面都被注释掉了，相当于：
SELECT * FROM user WHERE username = 'user'
因此，以上两种情况可能输入一个错误的密码或者不输入密码就可登录用户名为'user'的账号，这是十分危险的事情。



# 如何预防SQL注入？

1）严格检查输入变量的类型和格式

对于整数参数，加判断条件：不能为空、参数类型必须为数字
对于字符串参数，可以使用正则表达式进行过滤：如：必须为[0-9a-zA-Z]范围内的字符串

2）过滤和转义特殊字符
在username这个变量前进行转义，对'、"、\等特殊字符进行转义，如：php中的addslashes()函数对username参数进行转义

3）利用mysql的预编译机制
把sql语句的模板（变量采用占位符进行占位）发送给mysql服务器，mysql服务器对sql语句的模板进行编译，
编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给mysql服务器，直接进行执行，
节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。
具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。


一切输入都是不安全的：
对于接口的调用参数，要进行格式匹配，例如admin的通过name查询的接口，与之匹配的Path应该使用正则匹配（因为用户名中不应该存在特殊字符），
从而确保传入参数是程序控制范围之内的参数，即只接受已知的良好输入值，拒绝不良输入。注意：验证参数应将它与输出编码技术结合使用。

利用分层设计来避免危险：
前端尽量静态化，尽量少的暴露可以访问到DAO层的接口到公网环境中，如果现有项目，很难修改存在注入的代码，
可以考虑在web服务之前增加WAF进行流量过滤，当然代码上就不给hacker留有攻击的漏洞才最好的方案。也可以在拥有nginx的架构下，
采用OpenRestry做流量过滤，将一些特殊字符进行转义处理。

尽量使用预编译SQL语句：由于动态SQL语句是引发SQL注入的根源。应使用预编译语句来组装SQL查询。

规范化：将输入安装规定编码解码后再进行输入参数过滤和输出编码处理；拒绝一切非规范格式的编码。



# orm框架SQL注入的问题

mybatis 
1、${}与#{}的差别在哪里？
原来在mybatis中如果以${}形式声明为SQL传递参数，mybatis将不会进行参数预处理，会直接动态拼接SQL语句，此时就会存在被注入的风险，
所以在使用mybatis作为持久框架时应尽量避免采用${}的形式进行参数传递，
如果无法避免（有些SQL如 like、in 、order by等，程序员可能依旧会选择 ${}的方式传参），那就需要对传入参数自行进行转义过滤。
JPA是Sun公司用来整合ORM技术，实现天下归一的ORM标准而定义的Java Persistence API（java持久层API），
JPA只是一套接口，目前引入JPA的项目都会采用Hibernate作为其具体实现，随着无配置Spring Boot框架的流行，
JPA越来越具有作为持久化首选的技术，因为其能让程序员写更少的代码，就能完成现有的功能，例如强大的JpaRepository，
常规的SQL查询只需按照命名规则定义接口，便可以不写SQL（JPQL/SQL）就可以实现数据的查询操作，从SQL注入防范的角度来说，
这种将安全责任抛给框架远比依靠程序员自身控制来的保险。因此如果项目使用JPA作为数据访问层，基本上可以很大程度的消除SQL注入的风险

2、In 后面的注入点
在sql语句中的In之后常常存在注入点，当进行同条件多值查询的时候，Select * from admin where id in (#{id}) 这种形式的语句会报错
因此需要这样写 select  * from admin where id in {${id}} 导致SQL拼接。

3、模糊查询
在渗透实战中经常发现一些采用了MyBatis框架网站的搜索功能处常常存在SQL注入，原因就是模糊查询的时候，有时会用到参数拼接的形式，
比如 ： select * from admin where name like ‘%${name}%’，这种情况就存在 SQL注入。


[参考](https://blog.csdn.net/github_36032947/article/details/78442189 )